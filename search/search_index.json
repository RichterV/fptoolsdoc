{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ForestPyTools","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>\ud83d\udcc4 License</p> <p>This library is licensed under the Creative Commons BY-NC 4.0.</p> <p>\u2714\ufe0f Personal and educational use allowed \u274c Commercial use is prohibited without the author's explicit permission.</p> <p>Author: Vinicius Richter</p> <p></p>"},{"location":"#forestpytools_1","title":"\ud83c\udf32 ForestPyToolsFP Tools features","text":"<p>ForestPyTools is a Python library developed to simplify planted forest measurement management. Focused on practical applications, the library provides simple, accessible tools that can be easily integrated into scientific and operational workflows in the forestry sector.</p> <p>Process forest management end-to-end, easy as can be.</p> <p>With this library, you'll be able to plan forest inventories and volumetrics as well as process all data stemming from your forest plantation. FP Tools brings together various forestry processing methodologies into a single library, providing ease in model selection and forest performance analysis.</p> <p>This library was created as part of a master\u2019s project by student Vinicius Richter, aiming to facilitate the processing of forest inventory information and bridge the gap between IT professionals and forest engineers.</p> <p></p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Learn how to take the first steps in using the library, from installation to efficiently leveraging forest processing.</p>"},{"location":"#forest-inventory-planing-plots-allocation-on-qgis","title":"Forest Inventory Planing (plots allocation on QGIS)","text":"<p>In this module, you will be able to plan forest inventories by allocating plots with our plugin for QGIS.</p>"},{"location":"#forest-inventory-planing","title":"Forest Inventory planing","text":"<p>In this module, you will be able to plan forest inventories by allocating plots.</p>"},{"location":"#hypsometric-relationship","title":"Hypsometric Relationship","text":"<p>In this module, you'll be able to perform the hypsometric relationship of a forest inventory using various equations as well as make use of artificial neural networks.</p>"},{"location":"#tree-volume-planning","title":"Tree Volume Planning","text":"<p>In this module, you will be able to plan tree volume measurements as part of forest inventories, selecting tools for estimating tree and stand volume.</p>"},{"location":"#volumetrics","title":"Volumetrics","text":"<p>In this module, you will be able to process tree volume data and fit volumetric and taper functions.</p>"},{"location":"#sampling-stats","title":"Sampling Stats","text":"<p>This module allows calculating parameters for simple and stratified sampling based on the volumes of the sampling units.</p>"},{"location":"#assortments","title":"Assortments","text":"<p>In this module, you will be able to generate reports on the total volume and assortments produced by the forest.</p>"},{"location":"#forest-report","title":"Forest Report","text":"<p>In this module, you will be able to generate a forest report at different levels based on the previous processing performed.</p>"},{"location":"#clutter-forecast","title":"Clutter Forecast","text":"<p>In this module, you will be able to estimate future forest production using clutter model.</p>"},{"location":"#ann-forecast","title":"ANN Forecast","text":"<p>In this module, you will be able to estimate future forest production using artificial neural networks.</p>"},{"location":"#stratifier","title":"Stratifier","text":"<p>In this module, you can use inventory data to find the ideal stratification for your planting.</p>"},{"location":"#utils","title":"Utils","text":"<p>Extra module with complementary functions.</p>"},{"location":"about_the_author/","title":"About the Author","text":"Richter V. Bachelor\u2019s degree in Forestry Engineering and is currently pursuing a Master\u2019s degree in Forestry Engineering with a specialization in forest growth and production at the Federal University of Santa Maria. Works in the fields of artificial intelligence, computer vision, Python programming, forest inventory, remote sensing and forest management.  <p>    View portfolio </p>"},{"location":"ann_forecast/","title":"ANN Forecast","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Use continuous forest inventory databases to predict forest growth and production. Utilize artificial neural networks for greater flexibility. With this module, you will be able to estimate volume, the number of stems, basal area, among other variables of interest.</p>"},{"location":"ann_forecast/#class-parameters","title":"Class Parameters","text":""},{"location":"ann_forecast/#ann-trainer","title":"ANN Trainer","text":"<pre><code>AnnTrainer(df, y, *train_columns, iterator=None)\n</code></pre> Parameters Description df The dataframe containing the continous processed forest inventory data. y The target variable for training the ANN (Y), the variable on which the ANN will be trained to predict. *train_columns (<code>*args</code>) Names of the columns that will be used to train the artificial neural network so that it can predict the values of Y. Must be numeric. iterator (Optional) Name of the column that contains the <code>iterator</code>. An artificial neural network will be adjusted for each <code>iterator</code>."},{"location":"ann_forecast/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>  AnnTrainer.fit_model(save_dir=None)#(1)!\n</code></pre></p> <ol> <li>save_dir = Directory where the <code>.pkl</code> ann file will be saved.</li> </ol> Methods Description .fit_model() Adjust the model using <code>*train_columns</code> to predict the variable Y."},{"location":"ann_forecast/#ann-structures","title":"Ann structures","text":"<p>6 different structures of artificial neural networks will be tested. Only the result from 1 model will be returned. The model returned will be selected by the ranking function. For the 'ann' model, the module sklearn.neural_network.MLPRegressor is used. --- title: ANN Parameters --- classDiagram     direction LR      class MLPRegressor {       Epochs: 3000       Activation: logistic       Solver Mode: lbfgs       Batch size: dynamic       Learning rate init: 0.1       Learning rate mode: adaptive     }      class Model-0 {       Hidden layer sizes: (15, 25, 20, 30, 10)     }     class Model-1 {       Hidden layer sizes: (35, 10, 25, 35, 15)      }     class Model-2 {       Hidden layer sizes: (25, 15, 30, 20)      }     class Model-3 {       Hidden layer sizes: (15, 35, 45)     }     class Model-4 {       Hidden layer sizes: (35, 10, 25, 35, 15)     }     class Model-5 {        Hidden layer sizes: (35, 10, 25, 35, 15, 20, 15, 30)     }       MLPRegressor &lt;|-- Model-0     MLPRegressor &lt;|-- Model-1     MLPRegressor &lt;|-- Model-2     MLPRegressor &lt;|-- Model-3     MLPRegressor &lt;|-- Model-4     MLPRegressor &lt;|-- Model-5</p>"},{"location":"ann_forecast/#ann-predictor","title":"ANN Predictor","text":"<pre><code>AnnPredictor(pkl_file)\n</code></pre> Parameters Description pkl_file Directory of the <code>.pkl</code> file that will be used for prediction."},{"location":"ann_forecast/#class-methods_1","title":"Class Methods","text":"<p>methods and parameters<pre><code>  AnnPredictor.predict(df, *args)#(1)!\n</code></pre></p> <ol> <li>Returns the prediction of <code>Y</code> for the <code>*args</code> columns. The <code>*args</code> columns must be the same as those used in <code>*train_columns</code> for training.  </li> </ol>"},{"location":"ann_forecast/#example-usage","title":"Example Usage","text":"<p>The main advantage of using artificial neural networks in the estimation of forest variables lies in the possibility of including a large number of variables in the prediction. However, currently, the neural networks in this module operate preferably with continuous variables. Therefore, when one wishes to use categorical variables, it is recommended to apply some kind of transformation, such as one-hot encoding, to convert them into a numerical format before inserting them into the network.</p> <p>As an example, we will use an adaptation of the data obtained by Arce and Dobner Jr. (2024) for Eucalyptus dunnii. The dataset consists of 81 permanent plots, with ages ranging from 3 to 9 years, measured continuously over time.</p> <p> Download the file. </p> <p>First 5 rows of the file:</p> Chave_Parcela Area_m2 Idade N_ha d m\u00e9dio h m\u00e9dio H dom G_m2_ha V_m3_ha S 14401109002_P1 300 3 933 7.47 6.8 7.4 4.2 6.0 15.4 14401109002_P1 300 4 933 10.3 10.1 10.8 8.0 24.5 15.4 14401109002_P1 300 5 933 14.0 12.8 13.7 14.9 67.1 15.4 14401109002_P1 300 6 933 14.1 14.5 15.4 15.1 77.2 15.4 14401109002_P1 300 7 867 16.6 16.1 16.5 19.4 112.8 15.4 <p>In this case, we will use the columns \"Idade\", \"N_ha\", \"d m\u00e9dio\", \"h m\u00e9dio\", \"H dom\", \"G_m2_ha\", and \"S\" to predict the value of \"V_m3_ha\".</p> <p>exemplo_previsao_rna.py<pre><code>from fptools.forecast import AnnTrainer, AnnPredictor#(1)!\n\nimport pandas as pd#(2)!\n\nfrom sklearn.model_selection import train_test_split#(3)!\n</code></pre></p> <ol> <li>Importa a classe <code>AnnTrainer</code> e <code>AnnPredictor</code> do m\u00f3dulo <code>forecast</code>.</li> <li>Importa <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> <li>Importa <code>train_test_split</code> para dividir dados em treino e valida\u00e7\u00e3o.</li> </ol> <p>exemplo_previsao_rna.py<pre><code>path = r\"Your/directory/to/dados_ann.xlsx\"#(1)!\ndados = pd.read_excel(path)#(2)!\n\ndados_treino, dados_validacao = train_test_split(dados,\n                                                test_size=0.2,\n                                                random_state=42)#(3)!\n\ntrain_columns = [\"Idade\",\n                 \"N_ha\",\n                 \"d m\u00e9dio\",\n                 \"h m\u00e9dio\",\n                 \"H dom\",\n                 \"G_m2_ha\",\n                 \"S\"]#(4)!\n\nann = AnnTrainer(dados_treino, \"V_m3_ha\", *train_columns)#(5)!        \n\nmetrics = ann.fit_model(r\"Your/directory/to/save\")#(6)!  \n</code></pre></p> <ol> <li>Define the directory where the data in xlsx format is located, saving it in the variable <code>path</code>.</li> <li>Load the data and save it in the variable <code>dados</code>.</li> <li>Save 80% of the data as training data in the variable <code>dados_treino</code> and 20% as validation data in the variable <code>dados_validacao</code>, using a random seed of 42.</li> <li>Create a variable called <code>train_columns</code> containing the list of column names to be used for training.</li> <li>Instantiate the class <code>AnnTrainer</code>, saving it in the variable <code>ann</code>, passing the training data, the column <code>V_m3_ha</code> as the target variable, and the list of training columns.</li> <li>Fit the neural network model, saving the metrics in the variable <code>metrics</code> and the generated <code>.pkl</code> file in the defined directory.</li> </ol> <p>After that, the trained model will be ready for use. We can test the performance of our model by using it to predict the validation data saved in <code>dados_validacao</code>.</p> <p>exemplo_previsao_rna.py<pre><code>from fptools.utils import get_metrics #(1)!\n\npredictor = AnnPredictor(\n                        r\"Your/directory/to/save/V_m3_ha_ann_predictor.pkl\"\n                        )#(2)!\n\ndados_validacao['V_m3_ha_predicted'] = predictor.predict(\n                                                         dados_validacao,\n                                                        *train_columns\n                                                        )#(3)!\n\nmae, mape, mse, rmse, r_squared, exp_var, m_error = get_metrics(\n                                                                dados_validacao['V_m3_ha'],\n                                                                dados_validacao['V_m3_ha_predicted']\n                                                                )#(4)!\nmetrics_val = pd.DataFrame({\n    'MAE': [mae],\n    'MAPE': [mape],\n    'MSE': [mse],\n    'RMSE': [rmse],\n    'R squared': [r_squared],\n    'Explained Var': [exp_var],\n    'Mean Error': [m_error]\n})#(5)!\n</code></pre></p> <ol> <li>Import the function <code>get_metrics</code> from the <code>utils</code> module for later metric calculation.</li> <li>Instantiate the class <code>AnnPredictor</code>, saving it in the variable <code>predictor</code>, and passing the <code>.pkl</code> file generated during the neural network training.</li> <li>Create the column <code>V_m3_ha_predicted</code> in the <code>dados_validacao</code> DataFrame, containing the predictions made by the trained ANN for the training columns in the <code>dados_validacao</code> DataFrame.</li> <li>Use the <code>get_metrics</code> function to obtain the metrics between the actual values <code>V_m3_ha</code> and the predicted values <code>V_m3_ha_predicted</code> from the <code>dados_validacao</code> DataFrame. The returned metrics are: MAE (Mean Absolute Error), MAPE (Mean Absolute Percentage Error), MSE (Mean Squared Error), RMSE (Root Mean Squared Error), R\u00b2 (Coefficient of Determination), EXP_VAR (Explained Variance Score), and ME (Mean Error).</li> <li>Create a DataFrame with the validation metrics.</li> </ol>"},{"location":"ann_forecast/#outputs","title":"Outputs","text":""},{"location":"ann_forecast/#tables","title":"Tables","text":"<p><code>metrics</code>(1)</p> <p>{ .annotate }</p> <ol> <li>Table with the performance metrics of the ANN during training.</li> </ol> Iterator Model MSE RMSE MAE MAPE R\u00b2 Explained Variance Max Error Not used V_m3_ha_ann_predictor 32.29 5.68 3.05 4.23 0.99 0.99 0.14 <p><code>metrics_val</code>(1)</p> <ol> <li>Table with the performance metrics of the ANN on validation.</li> </ol> MAE MAPE MSE RMSE R\u00b2 Explained Variance Mean Error 2.99 3.28 26.13 5.11 0.99 0.99 0.12"},{"location":"ann_forecast/#files","title":"Files","text":"<p><code>V_m3_ha_ann_predictor.pkl</code>(1)</p> <ol> <li><code>.pkl</code> file containing the trained ANN parameters.</li> </ol> <p> Download the file. </p>"},{"location":"ann_forecast/#references","title":"References","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"assortments/","title":"Assortments","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Obtain the products generated by the forest inventory based on a product table. Use fitted taper functions to estimate commercial and non-commercial volume generated by the forest. Estimate volumes using fitted volumetric equations.</p>"},{"location":"assortments/#class-parameters","title":"Class Parameters","text":"<pre><code>Assortments(df, assortments_priority=None)\n</code></pre> Parameters Description df The dataframe containing the assortments data. assortments_priority (Optional) The name of the column who defines the assortments priority. If <code>None</code>, uses the default order from the dataframe."},{"location":"assortments/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>  Assortments.get_assortments(model, model_path, trees_df, tree_dbh, tree_height,\n                              stump=0.1, initial_height=None)#(1)!\n\n  Assortments.get_taper_volumes(model, model_path, trees_df, tree_dbh,\n                                tree_height, bark_factor=None, stump=0.1)#(2)!\n\n  Assortments.get_volumes(model, model_path, trees_df, tree_dbh,\n                          tree_height, bark_factor=None)#(3)!\n</code></pre></p> <ol> <li> <p>model = The name of the taper function or 'ann' to be used to calculate the assortments. model_path = Path to the <code>.json</code> file containing the coefficients of the fitted models or the <code>.pkl</code> file containing the fitted artificial neural network. trees_df = Pandas DataFrame containing the inventory for which the assortments should be calculated. tree_dbh = The name of the column containing the diameter at breast height (DBH) values in centimeters. tree_height = The name of the column containing the total height values of the trees in meters. stump = (Optional) Stump height value (meters) to be considered in the assortment calculation. If <code>stump==None</code>, it defaults to <code>0.1</code>. initial_height = (Optional) Height (meters) at which the products begin to be generated. Useful for cases where the base of the tree was damaged by fire or used for resin extraction.</p> </li> <li> <p>model = The name of the taper function or taper 'ann' to be used to calculate the volume. model_path = Path to the <code>.json</code> file containing the coefficients of the fitted models or the <code>.pkl</code> file containing the fitted artificial neural network. trees_df = Pandas DataFrame containing the inventory for which the volumes should be calculated. tree_dbh = The name of the column containing the diameter at breast height (DBH) values in centimeters. tree_height = The name of the column containing the total height values of the trees in meters. bark_factor = (Optional) Value of the bark factor to be used to calculate volumes without bark. stump = (Optional) Stump height value (meters) to be considered in the volumes calculation. If <code>stump==None</code>, it defaults to <code>0.1</code>.  </p> </li> <li> <p>model = The name of the volumetric function or volumetric 'ann' to be used to calculate the volume. model_path = Path to the <code>.json</code> file containing the coefficients of the fitted models or the <code>.pkl</code> file containing the fitted artificial neural network. trees_df = Pandas DataFrame containing the inventory for which the volumes should be calculated. tree_dbh = The name of the column containing the diameter at breast height (DBH) values in centimeters. tree_height = The name of the column containing the total height values of the trees in meters. bark_factor = (Optional) Value of the bark factor to be used to calculate volumes without bark.  </p> </li> </ol> Methods Description .get_assortments() Returns the <code>trees_df</code> dataframe with additional columns indicating the number of products generated for each assortment, as well as the volume generated for each assortment in each tree. Calculates also the comercial volume, the total volume of the tree and also the wasted volume. .get_taper_volumes() Returns the <code>trees_df</code> with the volumes calculated based on the integration of taper functions. It calculates the total volume with bark and without bark. .get_volumes() Returns the <code>trees_df</code> with the volumes calculated based on the fitted volumetric functions. It calculates the total volume with bark and without bark."},{"location":"assortments/#example-usage","title":"Example Usage","text":"<p>Consider a forest inventory dataset composed of 50 Eucalyptus trees, for which diameter at breast height (DBH) and total height were measured.</p> <p> Download the file. </p> <p>First 5 rows of the file:</p> Fazenda \u00c1rvore DAP (cm) HT (m) Fazenda 1 1 24.8 28.0 Fazenda 1 2 21.2 27.1 Fazenda 1 3 26.8 37.8 Fazenda 1 4 37.6 43.0 Fazenda 1 5 35.7 42.8 <p>For this module to work, it is necessary to specify a DataFrame containing the description of the products to be extracted from each tree. This table must include, for each product, the following information: product name, minimum and maximum length, minimum diameter, cutting loss (caused by the equipment saw), and optionally, a column defining the extraction priority for each product.</p>"},{"location":"assortments/#example-of-assortments-table","title":"Example of assortments table","text":"Product Length min (m) Length max (m) D min (cm) Loss (cm) Priority Prod. 1 4.5 5 15 0.5 1 Prod. 2 2 2 8 0.5 2 Prod. 3 1 1 3 0.5 3 <p>The column order must be followed.</p> <p>taper_functions_example.py<pre><code>from fptools.assortments import Assortments#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import <code>Assortments</code> class.</li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>For this example, we will use the equations fitted for the iterator \"Fazenda 1\". Thus, we will filter the data to calculate products only for the trees from \"Fazenda 1\". We will use the files generated by the Volumetrics module.</p> <p> Download the file taper_functions_coefficients_Fazenda 1.json. </p> <p> Download the file volumetrics_functions_coefficients_Fazenda 1.json. </p> <p>taper_functions_example.py<pre><code>assortments_df = pd.read_excel(r'C:\\your\\path\\sortimentos.xlsx')#(1)!\n\ninventory_df = pd.read_excel(r'C:\\your\\path\\dados_inventario.xlsx')#(2)!\n\ninventory_df = inventory_df[inventory_df['Fazenda'] == \"Fazenda 1\"]#(3)!\n\nProd = Assortments(assortments_df)#(4)!\n\nassortments = Prod.get_assortments('kozak',\n                                   r\"D:\\Your\\path\\for\\taper_functions_coefficients_Fazenda 1.json\",\n                                   inventory_df, \"DAP\", \"HT\")#(5)!\n\ntaper_volumes = Prod.get_taper_volumes('bi',\n                                       r\"D:\\Your\\path\\for\\taper_functions_coefficients_Fazenda 1.json\",\n                                       inventario, \"DAP\", \"HT\", .9)#(6)!  \n\nvolumes = Prod.get_volumes('meyer', \n                           r\"D:\\Your\\path\\for\\volumetrics_functions_coefficients_Fazenda 1.json\",\n                           inventario, \"DAP\", \"HT\", .85)#(7)!\n</code></pre></p> <ol> <li>Loads the <code>assortments_df</code> DataFrame from an <code>xlsx</code> file.  </li> <li>Loads the <code>inventory_df</code> DataFrame from an <code>xlsx</code> file.  </li> <li>Filters the data to include only rows where the <code>Fazenda</code> column is equal to <code>Fazenda 1</code>.  </li> <li>Creates the <code>Prod</code> variable containing the <code>Assortments</code> class using the <code>assortments_df</code> DataFrame as the products.  </li> <li>Calculates assortments for each tree in the <code>inventory_df</code> using the <code>kozak</code> model, the <code>DAP</code> column for DBH values, and the <code>HT</code> column for tree height values, storing the result in the <code>assortments</code> variable.  </li> <li>Calculates volumes by integrating the <code>bi</code> function for each tree in the <code>inventory_df</code> using the <code>bi</code> model, the <code>DAP</code> column for DBH values, and the <code>HT</code> column for tree height values. A bark factor of <code>90%</code> is also applied.  </li> <li>Calculates volumes using the volumetric function for each tree in the <code>inventory_df</code> using the <code>meyer</code> model, the <code>DAP</code> column for DBH values, and the <code>HT</code> column for tree height values. A bark factor of <code>85%</code> is also applied.</li> </ol>"},{"location":"assortments/#outputs","title":"Outputs","text":""},{"location":"assortments/#tables","title":"Tables","text":"<p><code>assortments</code>(1)</p> <ol> <li>Initial DataFrame with the following additional columns:    For each product defined in the <code>assortments_df</code> table, two columns will be created: one indicating the number of products extracted per tree and another showing the total volume generated (in cubic meters) for that product.    Additionally, the DataFrame will include the columns <code>commercial_volume</code>, <code>tree_volume</code>, and <code>wasted_volume</code>, which represent, respectively, the utilized commercial volume, the total tree volume, and the volume of wasted wood.</li> </ol> Fazenda \u00c1rvore DAP HT Prod. 1_quantity Prod. 1_volume Prod. 2_quantity Prod. 2_volume Prod. 3_quantity Prod. 3_volume commercial_volume tree_volume wasted_volume Fazenda 1 1 24.84076433 28 2 0.36529298 5 0.160465831 6 0.022446226 0.548205036 0.548793726 0.00058869 Fazenda 1 2 21.17834395 27.1 1 0.15662905 7 0.205798888 5 0.016228224 0.378656162 0.379971069 0.001314907 Fazenda 1 3 26.81528662 37.8 4 0.738422477 5 0.129884459 5 0.016047425 0.884354362 0.88558894 0.001234578 Fazenda 1 4 37.57961783 43 6 1.899253966 3 0.090801352 5 0.021413892 2.01146921 2.01247906 0.00100985 Fazenda 1 5 35.66878981 42.8 6 1.705021305 3 0.07966354 5 0.018106349 1.802791194 1.803503982 0.000712789 <p><code>taper_volumes</code>(1)</p> <ol> <li>Initial DataFrame with the following additional columns: <code>Tree_volume</code>: Total tree volume calculated by integrating the specified taper function. <code>Tree_volume_without_bark</code>: <code>Tree_volume</code> multiplied by the specified bark factor.</li> </ol> Fazenda \u00c1rvore DAP HT Tree_volume Tree_volume_without_bark Fazenda 1 1 24.84076433 28 0.545157869 0.490642083 Fazenda 1 2 21.17834395 27.1 0.38299769 0.344697921 Fazenda 1 3 26.81528662 37.8 0.870697291 0.783627562 Fazenda 1 4 37.57961783 43 2.005436616 1.804892954 Fazenda 1 5 35.66878981 42.8 1.790646854 1.611582169 <p><code>volumes</code>(1)</p> <ol> <li>Initial DataFrame with the following additional columns: <code>Tree_volume</code>: Total tree volume calculated using the specified volumetric equation. <code>Tree_volume_without_bark</code>: <code>Tree_volume</code> multiplied by the specified bark factor.</li> </ol> Fazenda \u00c1rvore DAP HT Tree_volume Tree_volume_without_bark Fazenda 1 1 24.84076433 28 0.545157869 0.490642083 Fazenda 1 2 21.17834395 27.1 0.38299769 0.344697921 Fazenda 1 3 26.81528662 37.8 0.870697291 0.783627562 Fazenda 1 4 37.57961783 43 2.005436616 1.804892954 Fazenda 1 5 35.66878981 42.8 1.790646854 1.611582169 <p>If the user wants to use one of the neural network models trained for each function, simply replace the model name with <code>ann</code> and specify the directory of the <code>.pkl</code> file containing the parameters of the trained neural network.</p> <p> Download the file taper_model_ann_Fazenda 1.pkl. </p> <p> Download the file volumetric_ann_Fazenda 1.pkl. </p> <p>taper_functions_example.py<pre><code>assortments = Prod.get_assortments('ann',\n                                   r\"D:\\Your\\path\\for\\taper_model_ann_Fazenda 1.pkl\",\n                                   inventory_df, \"DAP\", \"HT\")#(1)!\n\ntaper_volumes = Prod.get_taper_volumes('ann',\n                                       r\"D:\\diretorio\\para\\taper_model_ann_Fazenda 1.pkl\",\n                                       inventario, \"DAP\", \"HT\", .9)#(2)!  \n\nvolumes = Prod.get_volumes('ann', \n                           r\"D:\\Your\\path\\for\\volumetric_ann_Fazenda 1.pkl\",\n                           inventario, \"DAP\", \"HT\", .85)#(3)!\n</code></pre></p> <ol> <li>Calculates assortments for each tree in the <code>inventory_df</code> using artificial neural networks, the <code>DAP</code> column for DBH values, and the <code>HT</code> column for tree height values, saving the result in the <code>assortments</code> variable.  </li> <li>Calculates volumes by integrating the artificial neural network for each tree in the <code>inventory_df</code>, using the <code>DAP</code> column for DBH values and the <code>HT</code> column for tree height values. A bark factor of <code>90%</code> is also applied.  </li> <li>Calculates volumes using a volumetric artificial neural network for each tree in the <code>inventory_df</code>, using the <code>DAP</code> column for DBH values and the <code>HT</code> column for tree height values. A bark factor of <code>85%</code> is also applied.</li> </ol>"},{"location":"bug_report/","title":"Bug Report","text":"<p>If you encountered any issues or would like to suggest an improvement, please feel free to access the bug report form. Your feedback helps us improve the tool.</p>"},{"location":"clutter_forecast/","title":"Clutter Forecast","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Use continuous forest inventory databases to predict forest growth and production. Utilize traditional method Clutter model. With this module, you will be able to estimate volume and basal area.</p>"},{"location":"clutter_forecast/#class-parameters","title":"Class Parameters","text":""},{"location":"clutter_forecast/#clutter-trainer","title":"Clutter Trainer","text":"<pre><code>ClutterTrainer(df, age1, age2, ba1, ba2, site, vol, iterator=None)\n</code></pre> Parameters Description df The dataframe containing the continous processed forest inventory data. age1 Name of the column containing the age of the previously sampled plot. age2 Name of the column containing the age of the subsequently sampled plot. ba1 Name of the column containing the basal area of the previously sampled plot. ba2 Name of the column containing the basal area of the subsequently sampled plot. site Name of the column containing the site index of the stand. vol Name of the column containing the volume of the subsequently sampled plot. iterator (Optional) Name of an iterator that will be used to group the data. Example of an iterator: Genetic material, Stratum."},{"location":"clutter_forecast/#example-of-clutter-input","title":"Example of clutter input","text":"Iterator Plot age1 age2 ba1 ba2 site vol GM 1 1 2.5 3.5 7.57 8.42 7.83 44.04 GM 1 1 3.5 4.5 8.42 14 8.73 51.42 GM 1 2 2.1 3.1 4.94 5.51 6.98 38.06 GM 1 2 3.1 4.33 5.51 6.45 7.45 39.26 GM 2 1 2 3 7.3 8.25 11.37 74.63 GM 2 1 3 4 8.25 9.13 11.69 68.27 GM 2 1 4 5 9.13 12.79 12.83 72.76 GM 2 1 5 6 12.79 15.63 14 73.87"},{"location":"clutter_forecast/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>  ClutterTrainer.fit_model(save_dir=None)#(1)!\n</code></pre></p> <ol> <li>save_dir = Directory where the coefficients and parameters of the trained models will be saved.</li> </ol> Methods Description .fit_model() Adjust the models for predicting basal area and volume."},{"location":"clutter_forecast/#clutter-models","title":"Clutter Models","text":""},{"location":"clutter_forecast/#basal-area-prediction","title":"<li>Basal area prediction</li>","text":"\\[ \\ln G_2 = \\ln G_1 \\left( \\frac{t_1}{t_2} \\right) + \\alpha_0 \\left( 1 - \\frac{t_1}{t_2} \\right) + \\alpha_1 \\left( 1 - \\frac{t_1}{t_2} \\right) S \\]"},{"location":"clutter_forecast/#volume-prediction","title":"<li>Volume prediction</li>","text":"\\[ \\ln V_2 = \\beta_0 + \\beta_1 \\cdot \\frac{1}{t_2} + \\beta_2 \\cdot S + \\beta_3 \\cdot \\ln G_2 \\]"},{"location":"clutter_forecast/#notation","title":"Notation","text":"<ul> <li>\\( G_1 \\): Initial basal area (at age \\( t_1 \\)) in m\u00b2\u00b7ha\u207b\u00b9  </li> <li>\\( G_2 \\): Final basal area (at age \\( t_2 \\)) in m\u00b2\u00b7ha\u207b\u00b9  </li> <li>\\( t_1 \\): Initial age in months or years  </li> <li>\\( t_2 \\): Final age in months or years  </li> <li>\\( S \\): Site index, dimensionless, \\( f(\\text{site age}, t_i) \\) </li> <li>\\( \\alpha_0, \\alpha_1 \\): Coefficients to be estimated  </li> <li>\\( V_2 \\): Final volume (at age \\( t_2 \\)) in m\u00b3\u00b7ha\u207b\u00b9  </li> <li>\\( \\beta_i \\): Coefficients to be estimated  </li> </ul>"},{"location":"clutter_forecast/#class-parameters_1","title":"Class Parameters","text":""},{"location":"clutter_forecast/#clutter-predictor","title":"Clutter Predictor","text":"<pre><code>ClutterPredictor(coefs_file, age1, site, ba1, iterator=None)\n</code></pre> Parameters Description coefs_file Directory of the <code>json</code> file containing the coefficients and parameters of the fitted models. age1 Name of the column containing the age of the previously sampled plot. ba1 Name of the column containing the basal area of the previously sampled plot. site Name of the column containing the site index of the stand. iterator (Optional) Name of an iterator that will be used for predictions."},{"location":"clutter_forecast/#class-methods_1","title":"Class Methods","text":"Methods Description .predict() Predicts future basal area and volume using the coefficients fitted in <code>ClutterTrainer</code> for a specific age. .get_coefs() Displays the coefficients loaded from the <code>coefs_file</code>. .predict_range() Predicts future basal area and volume using the coefficients fitted in <code>ClutterTrainer</code> for a predefined age range. <p>methods and parameters<pre><code>  ClutterTrainer.get_coefs()#(1)!\n  ClutterTrainer.predict(age2)#(2)!\n  ClutterTrainer.predict_range(age_range=(2, 10),show_plots=False)#(3)!\n</code></pre></p> <ol> <li>Returns the loaded coefficients from <code>coefs_file</code>.  </li> <li>Returns the prediction made for <code>age2</code>.  </li> <li>Returns the prediction made for a specified age range in <code>age_range</code> as a tuple.    If <code>show_plots=True</code>, displays the plots of the performed predictions.  </li> </ol>"},{"location":"clutter_forecast/#example-usage","title":"Example Usage","text":"<p>As an example, we will use an adapted dataset from Arce and Dobner Jr. (2024) for Eucalyptus dunnii. The dataset consists of 81 permanent plots, with ages ranging from 3 to 9 years, measured continuously over time.</p> <p> Download file. </p> <p>First 5 rows of the file:</p> Estrato Parcela I1 I2 G1 G2 IS V2_observ Estrato-2 1220117_P7005 3 4 8.88 11.98 14.42 36.05 Estrato-2 1220117_P7005 4 5 11.98 13.53 14.42 51.90 Estrato-2 1220117_P7005 5 6 13.53 17.24 14.42 81.22 Estrato-2 1220117_P7005 6 7 17.24 22.47 14.42 144.45 Estrato-2 1220117_P7005 7 8 22.47 22.20 14.42 150.15 <p>clutter_forecast_example.py<pre><code>fptools.forecast import ClutterTrainer, ClutterPredictor#(1)!\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import <code>ClutterTrainer</code> and <code>ClutterPredictor</code> class from <code>forecast</code> module.</li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>clutter_forecast_example.py<pre><code>df = pd.read_csv(r'C:\\Your\\Directory\\dados_clutter.xlsx')#(1)!\n\nclutter = ClutterTrainer(dados, \"I1\",\"I2\", \"G1\",\"G2\",'IS',\"V2_observ\")#(2)!\n\nmetrics = clutter.fit_model(save_dir = r\"C:\\Your\\Directory\\to\\save\")#(3)!\n\npredictor = ClutterPredictor(\"C:\\Your\\Directory\\to\\save\\all_coefficients.json\",\n                             7,14.41,17.23)#(4)!\n\nba_vol_predicted = predictor.predict(10)#(5)!\n\ncoef = predictor.get_coefs()#(6)!\n\nba_vol_range_predicted = predictor.predict_range((2,12), show_plots=True)#(7)!\n</code></pre></p> <ol> <li>Load your continuous forest inventory data file in <code>xlsx</code> format.  </li> <li>Create the <code>clutter</code> variable containing the <code>ClutterTrainer</code> class, defining the corresponding columns.  </li> <li>Fit the Clutter model, saving the coefficients and parameters to the folder <code>C:\\Your\\Directory\\to\\save\\the\\metrics</code>, and the training metrics to the variable <code>metrics</code>.  </li> <li>Create a variable containing the predictor. This predictor will use the saved model <code>C:\\Your\\Directory\\to\\save\\all_coefficients.json</code> to apply an inventory with age <code>7</code> years, a site index of <code>14.41</code>, and a basal area of <code>17.23</code>, in order to predict future volume and basal area production.  </li> <li>Make the prediction for this stand at age <code>10</code> and save the results in <code>ba_vol_predicted</code>.  </li> <li>Retrieve the model coefficients and store them in the variable <code>coef</code>.  </li> <li>Make a prediction for this stand from age <code>2</code> to <code>12</code>, generating a plot that shows the evolution of basal area and volume over this period, along with the confidence level.  </li> </ol>"},{"location":"clutter_forecast/#outputs","title":"Outputs","text":""},{"location":"clutter_forecast/#tables","title":"Tables","text":"<p><code>metrics</code>(1)</p> <ol> <li>Metric values from the model fitting for each model used by iterator (when applicable).</li> </ol> Iterator Model MSE RMSE MAE MAPE R\u00b2 Explained Variance Max Error Not used ln_ba2_est 2.70 1.64 1.32 2.35 0.92 0.94 4.41 Not used ln_vol2_est 280.92 16.76 12.34 2.06 0.94 0.94 76.58 <p><code>ba_vol_predicted</code>(1)</p> <ol> <li>Estimated future basal area and volume values for age 10.</li> </ol> BA2 Volume 17.23 159.03 <p><code>coef</code>(1)</p> <ol> <li>Dictionary with coefficients for each model and iterator (when used).</li> </ol> <pre><code>{\n  \"lnb2_model\": {\n    \"b0\": 0.03818795042386813,\n    \"b1\": 3.465183897074305,\n    \"b2\": 0.016174627316697623,\n    \"num_rows\": 402,\n    \"min_age\": 3,\n    \"max_age\": 9,\n    \"mape\": 2.3528810455777904,\n    \"r2\": 0.923524025998693\n  },\n  \"lnv2_model\": {\n    \"b0\": 1.3927682912732822,\n    \"b1\": -4.364287014356091,\n    \"b2\": 0.04215217322729903,\n    \"b3\": 1.1299750378626658,\n    \"num_rows\": 402,\n    \"min_age\": 3,\n    \"max_age\": 9,\n    \"mape\": 2.0563064467361003,\n    \"r2\": 0.9414308873440383\n  }\n}\n</code></pre> <p><code>ba_vol_range_predicted</code>(1)</p> <ol> <li>Data frame containing future basal area and volume estimates for a predefined age range.</li> </ol> Age BA2 Volume BA2_max_error BA2_min_error Volume_max_error Volume_min_error 2.00 2.05 1.88 2.10 2.00 1.91 1.84 2.50 3.72 5.69 3.81 3.63 5.81 5.57 3.00 5.54 11.93 5.67 5.41 12.17 11.68 3.50 7.35 20.24 7.53 7.18 20.65 19.82 4.00 9.10 30.09 9.31 8.88 30.70 29.47 4.50 10.74 40.95 10.99 10.48 41.79 40.11 5.00 12.26 52.41 12.54 11.97 53.49 51.33 5.50 13.66 64.13 13.98 13.34 65.45 62.81 6.00 14.95 75.87 15.30 14.60 77.43 74.31 6.50 16.14 87.48 16.52 15.76 89.28 85.68 7.00 17.23 98.83 17.64 16.82 100.86 96.79 7.50 18.24 109.85 18.67 17.81 112.10 107.59 8.00 19.17 120.49 19.62 18.71 122.97 118.01 8.50 20.02 130.74 20.50 19.55 133.43 128.05 9.00 20.82 140.58 21.31 20.33 143.47 137.69 9.50 21.56 150.00 22.07 21.05 153.09 146.92 10.00 22.25 159.03 22.77 21.72 162.30 155.76 10.50 22.89 167.66 23.42 22.35 171.11 164.21 11.00 23.48 175.91 24.04 22.93 179.53 172.30 11.50 24.04 183.80 24.61 23.48 187.58 180.03 12.00 24.57 191.35 25.15 23.99 195.28 187.41"},{"location":"clutter_forecast/#example-of-output-forecast-chart","title":"Example of Output Forecast Chart","text":""},{"location":"clutter_forecast/#references","title":"References","text":"<p>CLUTTER, J. L.; FORTSON, J. C.; PIENAAR, L. V.; BRISTER, G. H.; BAILEY, R. L. (1983).       Timber management: a quantitative approach. New York: John Wiley &amp; Sons, 333p.</p> <p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"forest_report/","title":"Forest Report","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Generate a forest report based on estimated heights and volumes using the other modules of ForestPyTools. Obtain volume values and tree types per hectare at various specific levels of the forest stand, along with other metrics. Get the report in xlsx (Excel) or json format.</p>"},{"location":"forest_report/#class-parameters","title":"Class Parameters","text":"<pre><code>ForestReport(df, plot_id, plot_size, tree_type, tree_dbh,\n             tree_height,group_levels = None, tree_vol_with_bark = None \n             tree_vol_withou_bark = None, iterator=None)\n</code></pre> Parameters Description df The dataframe containing the processed forest inventory data. plot_id Name of the column that contains the unique identifier for each plot. plot_size Numeric value indicating the plot size in square meters or the name of the column that contains the size of each plot in square meters. tree_type Name of the column that contains the <code>id</code> of the tree types present in the forest inventory. The <code>id</code> must be included in <code>tree_types_df</code>. tree_dbh Name of the column that contains the diameter at breast height (DBH) values. tree_height Name of the column that contains the tree height values. group_levels (Optional) List with the names of grouping levels that the user wants to create. A summary will be generated for each group. Example of groups: Farm, stand, soil type. tree_vol_with_bark (Optional) Name of the column that contains the tree volume values with bark. tree_vol_without_bark (Optional) Name of the column that contains the tree volume values without bark. iterator (Optional) Name of an iterator that will be used to group the data. Example of an iterator: Stratum."},{"location":"forest_report/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>  ForestReport.update_tree_types(df)#(1)!\n  ForestReport.view_tree_types()\n  ForestReport.get_report(dir, format=\"xlsx\")#(2)!\n</code></pre></p> <ol> <li>df = DataFrame containing the tree types present in the forest inventory. If <code>None</code>, the library's default DataFrame is used.</li> <li>dir = Directory where the report will be saved. format = Format in which the report will be saved. Could be <code>xlsx</code>(Excel) or <code>json</code>.</li> </ol> Methods Description .update_tree_types() Updates the <code>tree_types_df</code> -&gt; DataFrame that contains the ids of tree types, names, and description. .view_tree_types() Displays the <code>tree_types_df</code> that the class is currently using. .get_report() Saves the forest report in <code>xlsx</code> or <code>json</code> format in the specified <code>dir</code>."},{"location":"forest_report/#example-of-tree-types-table","title":"Example of tree types table","text":"id name description commercial_volume missing_stems 0 normal Tree without significant distortions or defects 1 0 1 dead Dead tree 0 0 2 bifurcated above DBH Tree bifurcated above diameter at breast height (DBH) 1 0 3 bifurcated below DBH Tree bifurcated below diameter at breast height (DBH) 1 0 4 burned Burned tree 0 0 5 missing Missing tree (planting line failure) 0 1 <p>The column order must be followed.</p> <p>Attention</p> <ul> <li> <p>The <code>commercial_volume</code> column is a binary flag that indicates whether the tree type represented by the <code>id</code> should be included in the commercial volume calculation. A value of <code>1</code> means the tree contributes to commercial volume; <code>0</code> means it is excluded from the calculation.</p> </li> <li> <p>The <code>missing_stems</code> column is also a binary flag, used to identify the absence of trees in the expected planting location. Unlike dead trees, these cases represent gaps in spacing, which may result from mortality followed by tree fall, thinning operations, or planting omissions.</p> </li> </ul>"},{"location":"forest_report/#column-descriptions","title":"Column Descriptions","text":"<ul> <li> <p><code>id</code>: Represents a unique identifier for each tree type in the classification. It is used to distinguish records and can serve as a reference key in other datasets.</p> </li> <li> <p><code>name</code>: Indicates the name of the tree based on its condition or specific characteristics. This name acts as a short label for quick identification.</p> </li> <li> <p><code>description</code>: Provides a detailed explanation of the tree's condition, including information about structure, health status, or defects that may impact its commercial value.</p> </li> <li> <p><code>commercial_volume</code>: Indicates whether the tree's volume is considered commercially usable. A value of <code>1</code> means the tree has commercial volume and will be used; a value of <code>0</code> means it will not be used.</p> </li> <li> <p><code>missing_stems</code>: Used to identify missing trees in the expected planting line. Unlike dead trees, these are gaps in spacing, which may result from fallen dead trees, thinning, or unplanted spots.</p> </li> </ul>"},{"location":"forest_report/#usage-example","title":"Usage Example","text":"<p>To illustrate how the forest report module works, we use inventory data adapted from Arce and Dobner Jr. (2024). The inventory was carried out across 19 different farms, with Eucalyptus dunnii plantations ranging from 8 to 9 years of age. In total, 1,954 trees were measured. The volume was calculated using a form factor of 0.45 and a bark factor of 0.91.</p> <p> Download the file. </p> <p>First 5 rows of the file:</p> ID parcela area_parcela Idade ID_Regiao ID Fazenda ID talhao Esp\u00e9cie Coluna \u00c1rvore Fuste Tipo arvore dap (cm) ht ht_calculada (m) Vol (m\u00b3) Vol SC (m\u00b3) 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 4 26 1 2 23.5 18.1 17.57 0.342933476 0.329216137 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 3 21 1 1 20.6 17.4 17.25 0.258717577 0.248368874 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 1 5 1 1 20.3 17.21 0.250654405 0.240628229 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 2 12 1 1 20.3 17.6 17.21 0.250654405 0.240628229 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 2 15 1 1 20.0 17.0 17.17 0.242735156 0.233025750 <p>The library provides a default example of a tree types DataFrame to be used. However, each forestry engineer or company may have their own methodology and coding for tree types. In this case, we use the tree type classification defined by Arce and Dobner Jr. (2024).</p> <p> Download the file. </p> <p>Below is the DataFrame that we will use.</p> id name description commercial_volume missing_stems 1 Normal Healthy tree, without significant distortions or visible defects. 1 0 2 Dominante Tree that stands out in height and vigor compared to neighboring trees. 1 0 3 Seco Dead tree, without leaves and with no signs of physiological activity. 0 0 4 Quebrado Tree with damaged or broken parts of the trunk or crown. 0 0 5 Rebrotado Tree originated from sprouts after cutting or damage to the main stem. 1 0 6 Falta Absence of a tree in the expected planting line position. 0 1 7 Bifurcado Tree with the main stem divided into two or more main branches. 1 0 8 Inclinado Tree growing significantly tilted in relation to the vertical axis. 1 0 9 Apice Seco Tree with the upper part (apex) dry or dead. 1 0 10 Fuste Curvo Tree with a curved trunk, lacking straight alignment. 1 0 11 Suprimido Tree suppressed by shading or competition from neighboring trees. 1 0 <p>forest_report_example.py<pre><code>from fptools.forest_report import ForestReport#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import the <code>ForestReport</code> class.  </li> <li>Import the <code>pandas</code> library for data manipulation.</li> </ol> <p>forest_report_example.py<pre><code>inventory_data = pd.read_excel(\n                              r'C:\\seu\\caminho\\exemplo_forest_report.xlsx'\n                              )#(1)!\n\ntree_df_types = pd.read_excel(r'C:\\seu\\caminho\\tree_types.xlsx')#(2)!\n\nreport = ForestReport(inventory_data, plot_id=\"ID parcela\",\n                      plot_size='area_parcela',tree_type='Tipo arvore',\n                      group_levels=['ID_Regiao','ID Fazenda','ID talhao'],\n                      tree_height=\"ht_calculada (m)\", tree_dbh=\"dap (cm)\",\n                      tree_vol_with_bark=\"Vol (m\u00b3)\",\n                      tree_vol_without_bark=\"Vol SC (m\u00b3)\")#(3)!\n\nreport.view_tree_types()#(4)!\n\nreport.update_tree_types(tree_df_types)#(5)!\n\nreport.get_report(r'C:\\seu\\caminho\\para\\salvar', format=\"xlsx\")#(6)!\n</code></pre></p> <ol> <li>Load the <code>inventory_data</code> DataFrame from an <code>xlsx</code> file.  </li> <li>Load the <code>tree_types_df</code> DataFrame from an <code>xlsx</code> file.  </li> <li>Create the <code>report</code> variable containing the <code>ForestReport</code> class using the <code>inventory_data</code> DataFrame.    Set the <code>ID parcela</code> column to identify each plot.    Set the <code>area_parcela</code> column to provide the plot size in square meters.    Set the <code>Tipo arvore</code> column to identify the ID of each tree present in <code>tree_types_df</code>.    Set the columns <code>ID_Regiao</code>, <code>ID Fazenda</code>, and <code>ID talhao</code> as subgroup levels for which reports will be generated.    Set the <code>ht_calculada (m)</code> column as the one containing tree heights in meters.    Set the <code>dap (cm)</code> column as the one containing tree diameters at breast height in centimeters.    Set the <code>Vol (m\u00b3)</code> column as the one containing total tree volume with bark.    Set the <code>Vol SC (m\u00b3)</code> column as the one containing total tree volume without bark.  </li> <li>Display the current <code>tree_types_df</code> DataFrame (the default DataFrame that should be customized).  </li> <li>Update the <code>tree_types_df</code> using the <code>tree_df_types</code> DataFrame.  </li> <li>Save the report in <code>xlsx</code> format.</li> </ol> <p>Attention: Unique Identifiers in Groupings</p> <p>When using the <code>group_levels</code> parameter, it is essential that the defined groups contain unique combinations of values across the specified columns. This avoids ambiguity in the summaries generated by grouping.</p> <p>For example, when grouping by <code>ID_Regiao</code> and <code>ID Fazenda</code>, do not use generic identifiers like \"A\", \"B\", or \"C\" if they are reused across different regions. See the examples below:</p>"},{"location":"forest_report/#correct-example","title":"\u2705 Correct Example","text":"ID_Regiao ID Fazenda 14 14-A 14 14-B 15 15-A 15 15-B <p>Each combination of <code>ID_Regiao</code> and <code>ID Fazenda</code> is unique, ensuring consistent groupings with no overlap.</p>"},{"location":"forest_report/#incorrect-example","title":"\u274c Incorrect Example","text":"ID_Regiao ID Fazenda 14 A 14 B 15 A 15 B <p>In this incorrect example, the identifier \"A\" appears in two different regions. If grouping is done only by <code>ID Fazenda</code>, the summaries for \"A\" will include data from both regions, leading to interpretation errors.</p>"},{"location":"forest_report/#recommendation","title":"\ud83d\udca1 Recommendation","text":"<p>Use composite identifiers that include full context, such as <code>\"14-A\"</code>, <code>\"15-B\"</code>, etc., ensuring that each group is unique.</p>"},{"location":"forest_report/#references","title":"References","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>\ud83d\udcc4 License</p> <p>This library is licensed under the Creative Commons BY-NC 4.0.</p> <p>\u2714\ufe0f Personal and educational use allowed \u274c Commercial use is prohibited without the author's explicit permission.</p> <p>Author: Vinicius Richter</p> <p>To begin processing your forest data as easily as possible, first install ForestPyTools.</p>"},{"location":"getting_started/#installation","title":"\u2b07\ufe0f Installation","text":""},{"location":"getting_started/#standard-installation","title":"Standard installation:","text":"<pre><code>pip install git+https://github.com/RichterV/fptools.git\n</code></pre>"},{"location":"getting_started/#install-a-specific-version-eg-v000","title":"Install a specific version (e.g.: v0.0.0):","text":"<pre><code>pip install git+https://github.com/RichterV/fptools.git@v0.0.0\n</code></pre>"},{"location":"hypsometric_relationship/","title":"Hypsometric Relationship","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Estimate the heights of the missing trees based on the heights measured in the field.</p>"},{"location":"hypsometric_relationship/#class-parameters","title":"Class Parameters","text":"<pre><code>HypRel(x, y, df, model, iterator)\n</code></pre> Parameters Description x The name of the column that contains the tree diameters/circumferences. y The name of the column that contains the tree heights. df The DataFrame containing the tree data. model (Optional) A list of models used for estimating tree heights. If none, will use all models avaliable. Available models are: <code>['curtis', 'parabolic', 'stofel', 'henriksen', 'prodan_i', 'prodan_ii', 'smd_fm', 'ann']</code>. iterator (Optional) A column name string. Defines wich column will be used as a iterator. Could be a farm name, plot name, code or any unique identification tag."},{"location":"hypsometric_relationship/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>  HypRel.run()  \n  HypRel.view_metrics()  \n  HypRel.plots(dir = None, show = None)#(1)!\n  HypRel.get_coef()\n  HypRel.predict()\n</code></pre></p> <ol> <li>dir = The directory you want to save your plots!      If <code>dir == None</code>, then the plots will be displayed. show = Display the plots on the screen! It can be <code>True</code> or <code>False</code>.</li> </ol> Methods Description .run() Fit the models .view_metrics() Return a table of metrics of each evaluated model .plots(dir=None, show=True) Return the height and residuals plots .get_coef() Return the coefficients for each model .predict() Return the predict heights and used models in new columns"},{"location":"hypsometric_relationship/#example-usage","title":"Example Usage","text":"<p>Using the data from Scolforo (2005), from a Pinus taeda stand ranging from 15 to 19 years old, with 5 plots of 420 m\u00b2 measured, we can fit models to predict the missing heights.</p> <p> Download example file. </p> <p>First 5 rows of the file:  </p> Parcela Dap (cm) H (m) Idade (anos) p-1 22.28 0.0 15 p-1 23.87 22.2 15 p-1 25.46 0.0 15 p-1 25.78 24.5 15 p-1 26.74 22.2 15 <p>hyp_rel_example.py<pre><code>from fptools.hyp_rel import HypRel#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import <code>HypRel</code> class.</li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>Create a variable for the HypRel Class</p> <p>hyp_rel_example.py<pre><code>df = pd.read_excel(r'C:/your/directory/exemplo_scolforo.xlsx')#(1)!\n\nreg = HypRel('Dap (cm)',\"H (m)\",df)#(2)!\n\nresults = reg.run()#(3)!\n\nmetrics = reg.view_metrics()#(4)!\n\nreg.plots(r'C:/Your/path/to_save')#(5)!\n\ndf_coefficients =  reg.get_coef()#(6)!\n\nfinal_results =  reg.predict()#(7)!\n</code></pre></p> <ol> <li>Load your <code>.xlsx</code> file.  </li> <li>Create the variable <code>reg</code> containing the <code>HypRel</code> class. Since <code>model</code> is not declared, it will use all available models.    If you want to use a specific model, set <code>model=['curtis']</code> for example, and it will use only the Curtis model.    If you want to fit the models for each plot individually, use <code>iterator=\"Parcela\"</code>.    Example: <code>reg = HypRel('Dap (cm)',\"H (m)\",df, iterator=\"Parcela\")</code></li> <li>Run the models and save them to the <code>results</code> variable.  </li> <li>Evaluate the fitted models and save the metrics to the <code>metrics</code> variable.  </li> <li>Generate the plots for the fitted models.  </li> <li>Retrieve the coefficients of each fitted model.  </li> <li>Retrieve the final heights and the models used for the estimation.  </li> </ol> <p>In this case, <code>iterator</code> and <code>model</code> were not declared, so all equations were fitted to the entire dataset. These were the outputs:  </p>"},{"location":"hypsometric_relationship/#outputs","title":"Outputs","text":""},{"location":"hypsometric_relationship/#tables","title":"Tables","text":"<p><code>results</code>(1)</p> <ol> <li>DataFrame containing the estimated heights for each model and the field-measured height in the \"Real Height\" column.</li> </ol> curtis parabolic stofel henriksen prodan_i prodan_ii smd_fm ann Real Height 21.11 22.19 22.33 21.78 22.81 22.77 21.12 22.82 0.00 22.21 22.97 23.07 22.71 23.39 23.35 22.26 23.45 22.20 23.22 23.73 23.79 23.58 23.98 23.95 23.29 24.08 0.00 23.42 23.88 23.93 23.75 24.10 24.08 23.49 24.20 24.50 23.98 24.33 24.35 24.24 24.46 24.44 24.06 24.58 22.20 <p><code>metrics</code>(1)</p> <ol> <li>DataFrame containing the metrics obtained for each model, assigning a <code>score=10</code> to the best model.</li> </ol> Model MAE MAPE MSE RMSE R squared Explained Var Mean Error score henriksen 2.2125 7.6139 6.9901 2.6439 0.4163 0.4163 5.08E-15 10 curtis 2.1993 7.5325 7.0147 2.6485 0.4142 0.4154 0.1182 9 smd_fm 2.2099 7.6004 7.0020 2.6461 0.4153 0.4153 -0.0015 8 stofel 2.2060 7.5649 7.0210 2.6497 0.4137 0.4148 0.1177 7 parabolic 2.2183 7.6358 7.0099 2.6476 0.4146 0.4146 5.47E-16 6 ann 2.2194 7.6453 7.0312 2.6516 0.4128 0.4128 0.0002 5 prodan_ii 2.2008 7.5168 7.0921 2.6631 0.4077 0.4127 0.2434 4 prodan_i 2.2020 7.5241 7.0886 2.6625 0.4080 0.4125 0.2323 3 <p><code>df_coefficients</code>(1)</p> <ol> <li>DataFrame containing the coefficients of each model and indicating which one was selected as the best model.    Since <code>iterator</code> was not declared, the column remains empty.</li> </ol> iterator model equation b0 b1 b2 selected_model curtis ln(h) = b0 + b1\u00b7(1/x) 3.8139 -17.0254 False parabolic h = b0 + b1\u00b7x + b2\u00b7x\u00b2 8.9680 0.6891 -0.0043 False stofel ln(h) = b0 + b1\u00b7ln(x) 1.6300 0.4755 False henriksen h = b0 + b1\u00b7ln(x) -20.1429 13.5058 True prodan_i h = x\u00b2 / (b0 + b1\u00b7x + b2\u00b7x\u00b2) -7.7832 1.0345 0.0131 False prodan_ii h - 1.3 = x\u00b2 / (b0 + b1\u00b7x + b2\u00b7x\u00b2) -7.9302 1.1027 0.0131 False smd_fm y = log(y) ~ x = 1/x + 1/x\u00b2 3.8008 -16.0925 False <p><code>final_results</code>(1)</p> <ol> <li>Initial DataFrame containing two new columns: <code>best_predicted_height</code> with the height estimated by the best model. <code>selected_model</code> indicating which was the best model.</li> </ol> Plot DBH (cm) H (m) Age (years) best_predicted_height selected_model p-1 22.28 0 15 21.77502772 henriksen p-1 23.87 22.2 15 22.2 henriksen p-1 25.46 0 15 23.57696518 henriksen p-1 25.78 24.5 15 24.5 henriksen p-1 26.74 22.2 15 22.2 henriksen <p>If you want each model to be fitted to each individual plot, simply replace the line: <code>reg = HypRel('Dap (cm)',\"H (m)\",df)</code> with: <code>reg = HypRel('Dap (cm)',\"H (m)\",df, iterator=\"Fazenda\")</code></p>"},{"location":"hypsometric_relationship/#plots","title":"Plots","text":"<p>Since the line <code>reg.plots(r'C:/Your/path/to_save')</code> specified a directory for saving the generated plots, two folders will be created in this directory: A folder named <code>heights</code> containing the plots of the fitted curves. A folder named <code>residuals</code> containing the residual plots from the fittings.</p> Example of a plot generated with the fitted curve for the Henriksen model Example of a residual plot generated for the Henriksen model flowchart LR     subgraph run         runText1[Runs all available models]     end     subgraph view_metrics         runText2[Returns a DataFrame with the metrics of the fitted models]     end     subgraph plots         runText3[Generates plots]     end     subgraph coefficients         runText4[Returns a DataFrame with the coefficients of the fitted models]     end     subgraph predict         runText5[Returns the original DataFrame with a new column containing the estimated heights]     end     %% Links to subgraphs:     HypRel-Module --&gt; run     HypRel-Module --&gt; view_metrics     HypRel-Module --&gt; plots     HypRel-Module --&gt; coefficients     HypRel-Module --&gt; predict"},{"location":"hypsometric_relationship/#available-models","title":"Available models","text":""},{"location":"hypsometric_relationship/#curtis","title":"<li>curtis</li>","text":"\\[ \\operatorname{Total height} =e^{(\\beta_0+\u03b21*\\frac{1}{x})} \\]"},{"location":"hypsometric_relationship/#parabolic","title":"<li>parabolic</li>","text":"\\[ \\operatorname{Total height} = \\beta_0 + \\beta_1 * x + \\beta_2 * x^2 \\]"},{"location":"hypsometric_relationship/#stofel","title":"<li>stofel</li>","text":"\\[ \\operatorname{Total height} = e^{(\\beta_0+\\beta_1*\\ln(x))} \\]"},{"location":"hypsometric_relationship/#henriksen","title":"<li>henriksen</li>","text":"\\[ \\operatorname{Total height} = \\beta_0 + \\beta_1 * \\ln(x) \\]"},{"location":"hypsometric_relationship/#prodan_i","title":"<li>prodan_i</li>","text":"\\[ \\operatorname{Total height} = (\\frac{x^2}{\\beta_0+\\beta_1*x+\\beta_2* x^2}) \\]"},{"location":"hypsometric_relationship/#prodan_ii","title":"<li>prodan_ii</li>","text":"\\[ \\operatorname{Total height} =(\\frac{x^2}{\\beta_0+\\beta_1*x+\\beta_2* x^2})+1.3 \\]"},{"location":"hypsometric_relationship/#smd_fm","title":"<li>smd_fm</li>Transformations of YTransformations of X","text":"<p>Adaptation of the \"Forest Mensuration\" julia package by SILVA (2022), used to perform regressions using different types of transformations of diameter at breast height and height in hypsometric relationship processes.</p> <ul> <li> \\( y \\) </li> <li> \\( \\log(y) \\) </li> <li> \\( \\log(y - 1.3) \\) </li> <li> \\( \\log(1 + y) \\) </li> <li> \\( \\frac{1}{y} \\) </li> <li> \\( \\frac{1}{y - 1.3} \\) </li> <li> \\( \\frac{1}{\\sqrt{y}} \\) </li> <li> \\( \\frac{1}{\\sqrt{y - 1.3}} \\) </li> <li> \\( \\frac{x}{\\sqrt{y}} \\) </li> <li> \\( \\frac{x}{\\sqrt{y - 1.3}} \\) </li> <li> \\( \\frac{x^2}{y} \\) </li> <li> \\( \\frac{x^2}{y - 1.3} \\) </li> </ul> <ul> <li> \\( x \\) </li> <li> \\( x^2 \\) </li> <li> \\( \\log(x) \\) </li> <li> \\( \\log(x)^2 \\) </li> <li> \\( \\frac{1}{x} \\) </li> <li> \\( \\frac{1}{x^2} \\) </li> <li> \\( x + x^2 \\) </li> <li> \\( x + \\log(x) \\) </li> <li> \\( x + \\log(x)^2 \\) </li> <li> \\( x + \\frac{1}{x} \\) </li> <li> \\( x + \\frac{1}{x^2} \\) </li> <li> \\( x^2 + \\log(x) \\) </li> <li> \\( x^2 + \\log(x)^2 \\) </li> <li> \\( x^2 + \\frac{1}{x} \\) </li> <li> \\( \\log(x) + \\log(x)^2 \\) </li> <li> \\( \\log(x) + \\frac{1}{x} \\) </li> <li> \\( \\log(x) + \\frac{1}{x^2} \\) </li> <li> \\( \\log(x)^2 + \\frac{1}{x} \\) </li> <li> \\( \\log(x)^2 + \\frac{1}{x^2} \\) </li> <li> \\( \\frac{1}{x} + \\frac{1}{x^2} \\) </li> </ul>"},{"location":"hypsometric_relationship/#ann","title":"<li>ann</li>","text":"<p>Explanation about ANN below.</p>"},{"location":"hypsometric_relationship/#artificial-neural-network","title":"Artificial Neural Network","text":"<p>When selecting the 'ann' model, 4 different structures of artificial neural networks will be tested. Only the result from 1 model will be returned. The model returned will be selected by the ranking function. For the 'ann' model, the module sklearn.neural_network.MLPRegressor is used. --- title: ANN parameters --- classDiagram     class MLPRegressor {       Epochs: 3000       Activation: logistic       Solver Mode: lbfgs       Batch size: dynamic       Larning rate init: 0.1       Learning rate mode: adaptive     }      class Model-0 {       Hidden layer sizes: (4,5)     }     class Model_1 {       Hidden layer sizes: (4,2)     }     class Model_2 {       Hidden layer sizes: (3,2)     }     class Model_3 {       Hidden layer sizes: (4,4)     }      MLPRegressor &lt;|-- Model-0     MLPRegressor &lt;|-- Model_1     MLPRegressor &lt;|-- Model_2     MLPRegressor &lt;|-- Model_3</p>"},{"location":"hypsometric_relationship/#ranking-function","title":"Ranking function","text":"<p>To select the best-performing models and rank them accordingly, the following metrics are obtained:</p> M\u00e9tric name Structure Mean Absolute Error (MAE) \\( MAE = \\frac{1}{n} \\sum_{i=1}^{n} \\|y_i - \\hat{y}_i\\| \\) Mean Absolute Percentage Error (MAPE) \\( MAPE = \\frac{100}{n} \\sum_{i=1}^{n} \\left\\|\\frac{y_i - \\hat{y}_i}{y_i}\\right\\| \\) Mean Squared Error (MSE) \\( MSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 \\) Root Mean Squared Error (RMSE) \\( RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2} \\) R Squared (Coefficient of Determination) \\( R^2 = 1 - \\frac{\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} \\) Explained Variance (EV) \\( EV = 1 - \\frac{Var(y - \\hat{y})}{Var(y)} \\) Mean Error \\( Mean\\ Error = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i) \\) <p>After obtaining the metrics for each tested model, the best model receives a score of 10, while the others receive scores of 9, 8, and so on.</p>"},{"location":"hypsometric_relationship/#references","title":"References","text":"<p>CURTIS, R. O. (1967). Height-Diameter and Height-Diameter-Age Equations For Second-Growth Douglas-Fir. Forest Science, 13(4), 365\u2013375.       https://doi.org/10.1093/forestscience/13.4.365</p> <p>SCOLFORO, J. R. S. (2005). Biometria Florestal: Parte I: Modelos de regress\u00e3o linear e n\u00e3o-linear; Parte II: Modelos para rela\u00e7\u00e3o hipsom\u00e9trica, volume, afilamento e preso de mat\u00e9ria seca. Lavras: UFLA/FAEPE, pp. 224\u2013226.</p> <p>SILVA, M. D. (2022). Forest Mensuration.jl: Uma Introdu\u00e7\u00e3o \u00e0 Aplica\u00e7\u00f5es em Julia. 128 p. Trabalho de Conclus\u00e3o de Curso (Gradua\u00e7\u00e3o em Engenharia Florestal) \u2013 Universidade Federal de Santa Maria, Frederico Westphalen, RS, 2022.</p> <p>JAMES, G.; WITTEN, D.; HASTIE, T.; TIBSHIRANI, R. (2013). An Introduction to Statistical Learning. In Springer Texts in Statistics. Springer New York.       https://doi.org/10.1007/978-1-4614-7138-7</p>"},{"location":"plot_allocation/","title":"Plot allocation","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Allows the allocation of sampling plots with various types of sampling and plot formats. If you prefer a visual interface, consider using the QGIS module.</p>"},{"location":"plot_allocation/#class-parameters","title":"Class Parameters","text":"<pre><code>PlotAllocation(shp_dir, epsg)\n</code></pre> Parameters Description shp_dir Directory of the shapefile defining the boundary of the area to be sampled. epsg The EPSG code of the shapefile defining the boundary of the area to be sampled."},{"location":"plot_allocation/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>PlotAllocation.create_plots(distribution, plot_format, plot_area, sample_number,\n                            by_hectare, min_border_distance, rectangle_size,\n                            x_y_angle, save_buffer, show_plot, save_dir)\n</code></pre></p> Parameter Description distribution Type of distribution or allocation that the plots should be subjected to. plot_format Format of the plot that will be installed. plot_area Area of the plot that will be installed. Not used when plot_format = 'rectangle' sample_number Could be the number of plots, the percentage of the total area that will be sampled or a column in the attribute table containing the number of plots per polygon. If value &lt; 1 it will be understood as a percentage. If value &gt;= 1 it will be understood that you are setting the quantity of plots to allocate. by_hectare If True, will use sample_number as plots per hectare. If sample_number &lt; 1, it will use the percentage only. min_border_distance Minimum distance in meters that the plots must be from the edge of the shapefile boundaries. rectangle_size Used when plot_format = 'rectangle'. Tuple containing the sizes of X and Y of the rectangle (x,y). x_y_angle Used when distribution = 'systematic custom'. Sets the distance in X and Y of each line in the grid of the systematic distribution and also the rotation angle in degrees (x,y,angle). save_buffer If true, saves the buffer considering the plot size around the point. show_plot If true, displays a figure of the allocation performed. save_dir Directory where the shapefiles will be saved. If None, no shapefile will be saved. <p>Available arguments</p> Type of distributionPlot formatEPSG <ul> <li><code>random</code> : Allocate the plots in a random distribution</li> <li><code>best sampling</code> : (recommended) Allocate the plots in the best possible distribution for the area considering the established parameters. </li> <li><code>systematic</code> : Allocate the plots in a grid distribution, does not allow the definition of <code>sample_number</code> and alocate all possible plots.</li> <li><code>systematic custom</code> : Allocate the plots in a grid distribution with the <code>x</code> and <code>y</code> distances from the grid lines and <code>grid rotation angle</code> defined by the user.</li> </ul> <ul> <li><code>round</code> : Consider that plots will have a rounded shape.</li> <li><code>squared</code> : Consider that plots will have a squared shape. </li> <li><code>rectangle</code> : Allows user to insert the X and Y sizes of the desired rectangle shape. </li> </ul> <ul> <li>In order to achieve the best precision in calculation, you must select the UTM zone that your area is in. Find your utm zone.</li> </ul>"},{"location":"plot_allocation/#example-usage","title":"Example Usage","text":"<p>Consider the data from 3 fictitious forest stands, located in a forest near the Federal University of Santa Maria, Frederico Westphalen Campus, Brazil. Download example shapefile. </p> <p>Attribute table information:  </p> id talhao area_ha n_par 1 A 4.049 3 2 B 15.521 5 3 C 39.964 14"},{"location":"plot_allocation/#random-distribution","title":"Random distribution","text":"<p>plot_allocation_example_1.py<pre><code>from fptools.inventory_plots import PlotAllocation#(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"random\", sample_number=\"n_par\",\n                   plot_area=400, min_border_distance=2, \n                   save_dir=\"C:/Users/Desktop\",\n                   show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Import <code>PlotAllocation</code> class.  </li> <li>Create the <code>plots</code> variable with <code>PlotAllocation</code> class. Defines the boundary area shapefile path and the epsg.</li> <li>Create the plots with <code>random</code> distribuition, using \"n_par\" column on the atributte table to define the number of plots, <code>plot area = 400 m\u00b2</code>, a minimum border distance of 2 meters and save the shapefile in <code>C:\\Users\\Desktop</code>.</li> </ol>      As <code>show_plot=True</code>, a preview figure showing the plot allocation will be generated.         Distribution: Random;     Plot area: 400m\u00b2;     Number of plots: column \"n_par\";     Edge distance: 2 meters;"},{"location":"plot_allocation/#systematic-custom-distribution","title":"Systematic custom distribution","text":"<p>plot_allocation_example_2.py<pre><code>from fptools.inventory_plots import PlotAllocation#(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"systematic custom\", x_y_angle=(100,50,45),\n                    plot_area=400, min_border_distance=2, save_dir=\"C:\\Users\\Desktop\",\n                    show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Import <code>PlotAllocation</code> class.  </li> <li>Create the <code>plots</code> variable with <code>PlotAllocation</code> class. Defines the boundary area shapefile path and the epsg.</li> <li>Create the plots with <code>systematic custom</code> distribuition, <code>plot area = 400 m\u00b2</code>, with <code>x distance = 100 meters</code>, <code>y distance = 50 meters</code> and 45\u00b0 of grid rotation, with a minimum border distance of 2 meters and save the shapefile in <code>C:\\Users\\Desktop</code>.</li> </ol>      As <code>show_plot=True</code>, a preview figure showing the plot allocation will be generated.         Distribution: Customized systematic;     Plot area: 400m\u00b2;     Distance in x: 100;     Distance in y: 50;     Rotation: 45\u00b0;     Edge distance: 2 meters;"},{"location":"plot_allocation/#rectangle-plot-format","title":"Rectangle plot format","text":"<p>plot_allocation_example_3.py<pre><code>from fptools.inventory_plots import PlotAllocation #(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"best sampling\", rectangle_size=(20,30),\n                    sample_number = 2, by_hectare = True,\n                    min_border_distance=2, save_dir=\"C:\\Users\\Desktop\",\n                    show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Import <code>PlotAllocation</code> class.  </li> <li>Create the <code>plots</code> variable with <code>PlotAllocation</code> class. Defines the boundary area shapefile path and the epsg.</li> <li>Create the plots with <code>best sampling</code> distribuition, a <code>rectangle width (x) = 20 meters</code> and <code>height (y) = 30 meters</code>, a sampling of 2 plots per hectare, with a minimum border distance of 2 meters and save the shapefile in <code>C:\\Users\\Desktop</code>.</li> </ol>      As <code>show_plot=True</code>, a preview figure showing the plot allocation will be generated.         Distribution: Best sampling;     Plot area: 400m\u00b2;     Number of plots: 2/hectare;     Edge distance: 2 meters;"},{"location":"plot_allocation_qgis/","title":"Plot Allocation with QGIS","text":"<p>With the FPT Plot Allocation Plugin, you will be able to allocate inventory plots using various sampling methods and plot shapes, all through a user-friendly and intuitive graphical interface.</p>"},{"location":"plot_allocation_qgis/#plugin-instalation","title":"Plugin instalation","text":"<p>Within QGIS, go to \"Plugins\"  \"Manage and Install Plugins\" and search for \"FPT Plot Allocation\".</p>"},{"location":"plot_allocation_qgis/#installation-via-zip-file","title":"Installation via zip file","text":"<p>If you prefer, click here to download the ZIP file containing the plugin files. For more information about installation, see the QGIS plugins installation guide.</p>      During the plugin installation, the code will attempt to install version 1.5.2 of the external package scikit-learn.     If an error occurs, consider installing it manually in the \"OSGeo4W Shell\" by running the command:     <code>pip install scikit-learn==1.5.2</code>        Copy command         Copied to clipboard!"},{"location":"plot_allocation_qgis/#plugin-interface","title":"Plugin Interface","text":"This is the plugin interface. Below, you will learn how to configure and allocate your plots."},{"location":"plot_allocation_qgis/#plugin-basics","title":"Plugin Basics","text":"Parameters Description Type of distribution Type of distribution of the plots. Plot format Format of the plot you want to install. Boundary layer The shapefile with the polygon of the area. Use a column to define plots number If selected, allows the user to choose a column to define the number of plots per polygon. Plot area Area in square meters that each plot will have. Sample numbers or sample percentage Could be the number of plots or the percentage of the total area that will be sampled. If <code>value &lt; 1</code> it will be understood as a percentage. If <code>value &gt;= 1</code> it will be understood that you are setting the quantity of plots to allocate. By hectare If selected, applies the value of <code>Sample numbers or sample percentage</code> per hectare. The value must be greater than 1. Minimum border distance (meters) (Optional) Defines the minimum distance in meters that each plot will have from the border. EPSG The EPSG of your area. Create buffer for plots (Optional) If checked, will create a buffer showing the area of the plots. Output (Optional) Select a folder to save your plots shapefile. <p>Available arguments</p> Type of distributionPlot formatEPSG <ul> <li><code>random</code> : Allocate the plots in a random distribution</li> <li><code>best sampling</code> : (recommended) Allocate the plots in the best possible distribution for the area considering the established parameters. </li> <li><code>systematic</code> : Allocate the plots in a grid distribution, does not allow the definition of <code>sample number or sample percentage</code> and alocate all possible plots.</li> <li><code>systematic custom</code> : Allocate the plots in a grid distribution with the <code>x</code> and <code>y</code> distances from the grid lines and <code>grid rotation angle</code> defined by the user.</li> </ul> <ul> <li><code>round</code> : Consider that plots will have a rounded shape.</li> <li><code>squared</code> : Consider that plots will have a squared shape. </li> <li><code>rectangle</code> : Allows user to insert the X and Y sizes of the desired rectangle shape. </li> </ul> <ul> <li>In order to achieve the best precision in calculation, you must select the UTM zone that your area is in. Find your utm zone.</li> </ul>"},{"location":"plot_allocation_qgis/#usage-example","title":"Usage Example","text":"<p>Consider the data from 3 fictitious forest stands, located in a forest near the Federal University of Santa Maria, Frederico Westphalen Campus, Brazil. Download example shapefile. </p>      View of the shapefile boundaries    <p>Attribute table information:</p> id talhao area_ha n_par 1 A 4.049 3 2 B 15.521 5 3 C 39.964 14      Example of plot allocation using the \"best sampling\" distribution, square plots of 400m\u00b2, 1 meter border distance, and using the \"n_par\" column from the attribute table to define the number of plots"},{"location":"sampling_stats/","title":"Sampling Stats","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>This module allows calculating parameters for simple and stratified sampling based on the volumes of the sampling units.</p>"},{"location":"sampling_stats/#class-parameters","title":"Class Parameters","text":"<pre><code>SamplingStats(volume_df)\n</code></pre> Parameters Description volume_df The dataframe containing volume data for each sampling unit."},{"location":"sampling_stats/#class-methods","title":"Class Methods","text":"<p>methods e parameters<pre><code>  SamplingStats.simple(total_area, plot_id, plot_area,\n                       volume, error_lim=10, conf=95)#(1)!\n  SamplingStats.stratified(total_area, stratum_id, stratum_area,\n                           plot_id, plot_area, volume, error_lim=10, conf=95)#(2)!\n  SamplingStats.stratified_anova()\n</code></pre></p> <ol> <li> <p>total_area = Name of the column containing the total area value in square meters of the assessed forest stand. plot_id = Name of the column containing the unique identifier of the plot/sample unit. plot_area = Name of the column containing the area in square meters of the plot/sample unit. volume = Name of the column containing the volume values in cubic meters for each plot/sample unit. error_lim = (Optional) Numeric value or name of the column containing the acceptable error limit as a percentage. conf = (Optional) Numeric value or name of the column representing the confidence level (e.g., 95%) to be used in statistical calculations.</p> </li> <li> <p>total_area = Name of the column containing the total area value in square meters of the assessed forest stand. stratum_id = Name of the column containing the unique identifier of the stratum. plot_id = Name of the column containing the unique identifier of the plot/sample unit. plot_area = Name of the column containing the area in square meters of the plot/sample unit. volume = Name of the column containing the volume values in cubic meters for each plot/sample unit. error_lim = (Optional) Numeric value or name of the column containing the acceptable error limit as a percentage. conf = (Optional) Numeric value or name of the column representing the confidence level (e.g., 95%) to be used in statistical calculations.</p> </li> </ol> Parameters Description .simple() Returns a DataFrame containing statistical parameters and sample sufficiency for simple random sampling. .stratified() Returns a DataFrame containing statistical parameters and sample sufficiency for stratified sampling. .stratified_anova() Returns a DataFrame containing analysis of variance (ANOVA) for the stratification performed using the <code>.stratified()</code> method."},{"location":"sampling_stats/#simple-sampling","title":"Simple Sampling","text":""},{"location":"sampling_stats/#usage-example","title":"Usage Example","text":"<p>Consider the adaptation of the example used by Sanquetta et al. (2014) to illustrate the calculation of statistics for the simple random sampling process.</p> Fazenda Parcela area_total (m\u00b2) area_parcela (m\u00b2) Volume (m\u00b3) limite_erro(%) nivel_confianca(%) Fazenda 1 1 400000 600 20.85 10 95 Fazenda 1 2 400000 600 19.47 10 95 Fazenda 1 3 400000 600 24.13 10 95 Fazenda 1 4 400000 600 24.34 10 95 Fazenda 1 5 400000 600 25.13 10 95 Fazenda 1 6 400000 600 22.37 10 95 Fazenda 1 7 400000 600 22.51 10 95 Fazenda 1 8 400000 600 19.78 10 95 Fazenda 1 9 400000 600 25.05 10 95 Fazenda 1 10 400000 600 28.84 10 95 Fazenda 1 11 400000 600 23.70 10 95 Fazenda 1 12 400000 600 24.78 10 95 Fazenda 1 13 400000 600 22.58 10 95 Fazenda 1 14 400000 600 23.70 10 95 Fazenda 1 15 400000 600 36.16 10 95 Fazenda 1 16 400000 600 17.83 10 95 <p> Download example file. </p> <p>sampling_stats_simple_example.py<pre><code>from fptools.sampling_stats import SamplingStats#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import the <code>SamplingStats</code> class.  </li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>sampling_stats_simple_example.py<pre><code>df = pd.read_excel(r'sua_pasta/volume_parcelas_simples_pt.xlsx')#(1)!\n\nss = SamplingStats(df)#(2)!\n\nss_results = ss.simple(total_area='area_total (m\u00b2)', plot_id='Parcela',\n                       plot_area ='area_parcela (m\u00b2)',volume = 'Volume (m\u00b3)',\n                       error_lim='limite_erro(%)', conf='nivel_confianca(%)')#(3)!\n\nss_results.to_excel('simple_sampling_stats.xlsx', index=False)#(4)!\n</code></pre></p> <ol> <li>Load an <code>.xlsx</code> file containing the data.  </li> <li>Create the variable <code>ss</code> containing the <code>SamplingStats</code> class and passing the DataFrame <code>df</code>.  </li> <li>Specify the column names for each parameter of the <code>.simple()</code> function and save the results in the variable <code>ss_result</code>.  </li> <li>Save the results to a <code>simple_sampling_stats.xls</code> file for later viewing.</li> </ol> A message will appear in the code executor output indicating the success of the calculations. <p>The following information will be generated by the <code>simple()</code> function:</p> metric value population finite real_n_par 16 ideal_n_par 15 mean (m\u00b3/plot) 23.83 variance (m\u00b3/plot) 17.82 st_deviation (m\u00b3/plot) 4.22 coeff_variation (%) 17.72 variance_of_the_mean (m\u00b3/plot) 1.09 st_error_of_the_mean (m\u00b3/plot) 1.04 abs_sampl_error (m\u00b3/plot) 2.24 rel_sampl_error (%) 9.39 mean_confidence_interval (m\u00b3) (21.59, 26.06) confidence_interval_total population (m\u00b3) (14400.52, 17383.7) total (m\u00b3/ha) 397.3 total_population (m\u00b3) 15892.11"},{"location":"sampling_stats/#stratified-sampling","title":"Stratified Sampling","text":""},{"location":"sampling_stats/#usage-example_1","title":"Usage Example","text":"<p>sampling_stats_stratified_example.py<pre><code>from fptools.sampling_stats import SamplingStats#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import the <code>SamplingStats</code> class.  </li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>sampling_stats_stratified_example.py<pre><code>df_stratified = pd.read_excel(r'your_folder/volume_parcelas_estratificado_pt.xlsx')#(1)!\n\nss = SamplingStats(df_stratified)#(2)!\n\nss_results = ss.simple.stratified(total_area='area_total (m\u00b2)',\n                           stratum_id='Estrato',\n                           stratum_area='\u00c1rea do estrato (m\u00b2)',\n                           plot_id='Parcela',\n                           plot_area = 'area_parcela (m\u00b2)',\n                           volume=\"Volume (m\u00b3)\",\n                           error_lim='limite_erro(%)',\n                           conf='nivel_confianca(%)')#(3)!\n\nss_results.to_excel('stratified_sampling_stats.xlsx', index=False)#(4)!\nanova = ss.stratified_anova()#(5)!\nanova.to_excel(\"anova.xlsx\", index=False)#(6)!\n</code></pre></p> <ol> <li>Load the <code>.xlsx</code> file containing the data.  </li> <li>Create the variable <code>ss</code> containing the <code>SamplingStats</code> class and passing the DataFrame <code>df_stratified</code>.  </li> <li>Specify the column names for each parameter of the <code>.stratified()</code> function and save the results in the variable <code>ss_result</code>.  </li> <li>Save the results to a <code>stratified_sampling_stats.xlsx</code> file for later viewing.  </li> <li>Save the variance analysis values in the variable <code>anova</code>.  </li> <li>Save the variance analysis to a file named <code>anova.xlsx</code>.</li> </ol> <p>For this example, we will also use the values obtained in Sanquetta et al. (2014). Download example file. </p> <p>The following information will be generated by the <code>stratified()</code> function. In this case, statistical summaries are generated for both the total and the individual strata.</p> metrics total Estrato 1 Estrato 2 population finite finite finite real_n_par 24 12 12 ideal_n_par 8 5.2 2.8 mean (m\u00b3/plot) 107.25 89.08 125.42 variance (m\u00b3/plot) 137.91 71.54 261.17 st_deviation (m\u00b3/plot) 11.15 8.46 16.16 coeff_variation (%) 10.4 9.49 12.89 variance_of_the_mean (m\u00b3/plot) 5.05 5.85 21.02 st_error_of_the_mean (m\u00b3/plot) 2.25 2.42 4.58 abs_sampl_error (m\u00b3) 5.5 5.92 11.22 rel_sampl_error (%) 5.13 6.64 8.94 mean_confidence_interval (m\u00b3) (101.75, 112.75) (83.16, 95.0) (114.2, 136.63) confidence_interval_total population (m\u00b3) (101752.9, 112747.1) (54056.81, 61751.53) (39969.52, 47822.15) total (m\u00b3/ha) 107.25 89.08 125.42 total_population (m\u00b3) 107250 57904.17 43895.83 <p>Analysis of variance (ANOVA) generated:</p> Source of Variation SS df MS F F_critical H\u2080 Between Strata 8,633.527 1.000 8,633.527 51.898 4.301 Rejected Within Strata 3,659.833 22.000 166.356 Total 12,293.360 23.000"},{"location":"sampling_stats/#equations-used","title":"Equations Used","text":""},{"location":"sampling_stats/#simple","title":"<li>Simple</li>","text":""},{"location":"sampling_stats/#sample-intensity","title":"Sample Intensity","text":""},{"location":"sampling_stats/#finite-populations","title":"Finite Populations","text":"\\[ \\text{Ideal number of plots}: \\operatorname{n} = \\frac{N t^2 S_x^2}{N E^2 + t^2 S_x^2} \\]"},{"location":"sampling_stats/#infinite-populations","title":"Infinite Populations","text":"\\[ \\text{Ideal number of plots}: \\operatorname{n} = \\frac{t^2 S_x^2}{E^2} \\]"},{"location":"sampling_stats/#statistics","title":"Statistics","text":"\\[ \\text{Arithmetic Mean}: \\quad \\bar{x} = \\frac{\\sum_{i=1}^{n} X_i}{n} \\] \\[ \\text{Variance}: \\quad s_x^2 = \\frac{\\sum_{i=1}^{n} (X_i - \\bar{x})^2}{n - 1} \\] \\[ \\text{Standard Deviation}: \\quad s_x = \\sqrt{ \\frac{\\sum_{i=1}^{n} (X_i - \\bar{x})^2}{n - 1} } \\] \\[ \\text{Variance of the Mean}: \\quad s_{\\bar{x}}^2 = \\frac{s_x^2}{n} \\cdot \\left( \\frac{N - n}{N} \\right) \\] \\[ \\text{Standard Error}: \\quad s_{\\bar{x}} = \\pm \\frac{s_x}{\\sqrt{n}} \\cdot \\sqrt{1 - f} \\] \\[ \\text{Coefficient of Variation}: \\quad \\operatorname{cv}(\\%) = \\frac{s_x}{\\bar{x}} \\cdot 100 \\] \\[ \\text{Absolute Sampling Error}: \\quad E_a = \\pm t \\cdot s_{\\bar{x}} \\] \\[ \\text{Relative Sampling Error}: \\quad E_r = \\pm \\frac{t \\cdot s_{\\bar{x}}}{\\bar{x}} \\cdot 100 \\] \\[ \\text{Confidence Interval for the Mean}: \\quad IC \\left[ \\bar{x} - (t \\cdot s_{\\bar{x}}) \\leq \\bar{X} \\leq \\bar{x} + (t \\cdot s_{\\bar{x}}) \\right] = P \\] \\[ \\text{Population Total}: \\quad \\hat{X} = N \\cdot \\bar{x} \\] \\[ \\text{Confidence Interval for the Total}: \\quad IC \\left[ \\hat{X} - N(t \\cdot s_{\\bar{x}}) \\leq X \\leq \\hat{X} + N(t \\cdot s_{\\bar{x}}) \\right] = P \\]"},{"location":"sampling_stats/#stratified","title":"<li>Stratified</li>","text":""},{"location":"sampling_stats/#sample-intensity_1","title":"Sample Intensity","text":""},{"location":"sampling_stats/#finite-populations_1","title":"Finite Populations","text":"\\[ \\text{Ideal number of plots}: \\operatorname{n}= \\frac{t^2 \\sum_{h=1}^{L} W_h s_h^2}{E^2 + {t^2} \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N}} \\]"},{"location":"sampling_stats/#infinite-populations_1","title":"Infinite Populations","text":"\\[ \\text{Ideal number of plots}: \\operatorname{n} = \\frac{t^2 \\sum_{h=1}^{L} W_h s_h^2}{E^2} \\]"},{"location":"sampling_stats/#statistics_1","title":"Statistics","text":"\\[ \\text{Stratum Mean}: \\quad \\bar{x}_h = \\frac{\\sum_{i=1}^{n_h} x_{ih}}{n_h} \\] \\[ \\text{Stratified Mean}: \\quad \\bar{x}_{st} = \\frac{\\sum_{h=1}^{L} \\left( N_h \\cdot \\bar{x}_h \\right)}{N} = \\sum_{h=1}^{L} \\left( W_h \\cdot \\bar{x}_h \\right) \\] \\[ \\text{Stratum Variance}: \\quad s_h^2 = \\frac{\\sum_{i=1}^{n_h} (x_{ih} - \\bar{x}_h)^2}{n_h - 1} \\] \\[ \\text{Stratified Variance}: \\quad s_{st}^2 = \\sum_{h=1}^{L} \\left( W_h s_h^2 \\right) \\] \\[ \\text{Variance of the Stratified Mean}: \\quad s_{\\bar{x}(st)}^2 = \\sum_{h=1}^{L} W_h^2 \\cdot \\frac{s_h^2}{n_h} - \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N} \\] \\[ \\text{Stratified Standard Error}: \\quad s_{\\bar{x}(st)} = \\sqrt{ \\sum_{h=1}^{L} W_h^2 \\cdot \\frac{s_h^2}{n_h} - \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N} } \\] \\[ \\text{Absolute Sampling Error}: \\quad E_a = \\pm t \\cdot s_{\\bar{x}(st)} \\] \\[ \\text{Relative Sampling Error}: \\quad E_r = \\pm \\frac{t \\cdot s_{\\bar{x}(st)}}{\\bar{x}_{(st)}} \\cdot 100 \\] \\[ \\text{Confidence Interval for the Stratified Mean}: \\quad IC \\left[ \\bar{x}_{(st)} - (t \\cdot s_{\\bar{x}(st)}) \\leq \\bar{X} \\leq \\bar{x}_{(st)} + (t \\cdot s_{\\bar{x}(st)}) \\right] = P \\] \\[ \\text{Stratum Total}: \\quad \\hat{X}_h = N_h \\cdot \\bar{x}_h \\] \\[ \\text{Population Total}: \\quad \\hat{X} = \\sum_{h=1}^{L} \\hat{X}_h = N \\cdot \\bar{x}_{st} \\] \\[ \\text{Confidence Interval for the Total}: \\quad IC\\left[ \\hat{X} - N(t \\cdot s_{\\bar{x}(st)}) \\leq X \\leq \\hat{X} + N(t \\cdot s_{\\bar{x}(st)}) \\right] = P \\]"},{"location":"sampling_stats/#analysis-of-variance","title":"Analysis of Variance","text":"\\[ \\text{Sum of Squares Between Strata}: \\operatorname{SS}_b = \\sum_{h=1}^{L} n_h \\left( \\bar{x}_h - \\bar{x} \\right)^2 \\] \\[ \\text{Sum of Squares Within Strata}: \\operatorname{SS}_w = \\sum_{h=1}^{L} \\sum_{i=1}^{n_h} \\left( x_{ih} - \\bar{x}_h \\right)^2 \\] \\[ \\text{Total Sum of Squares}: \\operatorname{SS}_t = \\sum_{h=1}^{L} \\sum_{i=1}^{n_h} \\left( x_{ih} - \\bar{x} \\right)^2 \\] \\[ \\text{Mean Square Between Strata}: \\operatorname{MS}_b = \\frac{\\operatorname{SS}_b}{\\operatorname{df}_b} \\] \\[ \\text{Mean Square Within Strata}: \\operatorname{MS}_w = \\frac{\\operatorname{SS}_w}{\\operatorname{df}_w} \\] \\[ \\text{Calculated F-Value}: \\operatorname{F} = \\frac{\\operatorname{MS}_b}{\\operatorname{MS}_w} \\]"},{"location":"sampling_stats/#notation","title":"Notation","text":"<ul> <li>\\( N \\): Total number of units in the population or potential number  </li> <li>\\( n \\): Number of sampled or measured units  </li> <li>\\( n_h \\): Number of sampled or measured units in stratum \\( h \\) </li> <li>\\( t \\): Value from the Student's t-distribution  </li> <li>\\( s_x^2 \\): Variance  </li> <li>\\( s_h^2 \\): Variance of stratum \\( h \\) </li> <li>\\( s_{\\bar{x}(st)} \\): Standard error of the stratified mean  </li> <li>\\( W_h \\): Proportion of stratum \\( h \\) in the population  </li> <li>\\( E \\): Tolerated error limit (%)  </li> <li>\\( \\bar{x} \\): Sample mean  </li> <li>\\( \\bar{x}_h \\): Sample mean of stratum \\( h \\) </li> <li>\\( x_{ih} \\): Volume of the \\( i \\)-th plot within stratum \\( h \\)</li> </ul>"},{"location":"sampling_stats/#references","title":"References","text":"<p>SANQUETTA, C. R.; CORTE, A. P. D.; RODRIGUES, A. L.; WATZLAWICK, L. F. (2014). Invent\u00e1rios florestais: planejamento e execu\u00e7\u00e3o. Curitiba: Multi-Graphic, 406 p.</p>"},{"location":"stratifier/","title":"Stratifier","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>With this module, you can receive assistance in the stratification process of your forest plantations. Use forest inventory data to automatically stratify the plantations by selecting the forest variables you consider most relevant and either setting a predefined number of strata or allowing the module to determine the optimal number of strata.</p>"},{"location":"stratifier/#forest-stratification-with-python","title":"Forest Stratification with Python","text":"<p>The forest stratification process requires knowledge of several factors:</p> <ul> <li>Geographic location  </li> <li>Tree species  </li> <li>Soil type  </li> <li>Stand age  </li> <li>Product purpose  </li> <li>Management history  </li> </ul> <p>In this context, the Python module developed for stratification emerges as a support tool for forest planning, offering a data-driven initial perspective.</p>"},{"location":"stratifier/#main-functions","title":"Main Functions","text":"<p>The module includes functions such as:</p> <ul> <li><code>stratify_kmeans</code> </li> <li><code>stratify_hierarchical</code></li> </ul> <p>These functions use multivariate clustering algorithms (<code>k-means</code> and hierarchical, respectively) to identify patterns in continuous variables such as:</p> <ul> <li>Mean diameter  </li> <li>Mean height  </li> <li>Volume per hectare  </li> <li>Age  </li> <li>Site index  </li> </ul> <p>The algorithms group sample units into homogeneous strata, which can be used for:</p> <ul> <li>Forest inventory  </li> <li>Sample allocation  </li> <li>Management optimization  </li> </ul> <p>Important</p> <p>The results do not replace expert technical interpretation, but provide an objective basis for exploratory analysis, helping to support decision-making in forest projects.</p>"},{"location":"stratifier/#class-parameters","title":"Class Parameters","text":""},{"location":"stratifier/#stratifier_1","title":"Stratifier","text":"<pre><code>Stratifier(df, y, *train_columns, iterator=None)\n</code></pre> Parameters Description df The dataframe containing the forest inventory data. *groups_columns Columns that will be used for stratification. Numeric only. iterator (Optional) The stratification will be performed for each <code>iterator</code>."},{"location":"stratifier/#class-methods","title":"Class Methods","text":"<p>methods and parameters<pre><code>Stratifier.stratify_kmeans(k=None, k_method=None, max_k=100,\n                          show_plots=True, save_plots_dir=None)#(1)!\n\nStratifier.stratify_hierarchical(k=None, k_method=None, max_k=10,\n                                show_plots=True, save_plots_dir=None)#(2)!\n</code></pre></p> <ol> <li>k = (Optional) Desired number of strata. k_method = (Optional) If k is not specified, which method will be used to define the number of k. Options: elbow, silhouette, davies_bouldin, calinski_harabasz. <code>Default = \"elbow\"</code>.  max_k = (Optional) Maximum number of strata to be created. show_plots = If <code>true</code>, displays the radar chart with the generated strata. save_plot_dir = (Optional) Directory to save the plots of the generated strata.</li> <li>k = (Optional) Desired number of strata. k_method = (Optional) If k is not specified, which method will be used to define the number of k. Options: elbow, silhouette, davies_bouldin, calinski_harabasz. <code>Default = \"elbow\"</code>.  max_k = (Optional) Maximum number of strata to be created. show_plots = If <code>true</code>, displays the radar chart with the generated strata. save_plot_dir = (Optional) Directory to save the plots of the generated strata.</li> </ol> Methods Description .stratify_kmeans() Performs stratification using the <code>K-Means</code> algorithm. .stratify_hierarchical() Performs stratification using the <code>Agglomerative Clustering</code> algorithm. <p>Important</p> <p>When the variable <code>k</code> is not defined, the algorithm will attempt to automatically determine the optimal number of strata using the <code>elbow</code> method by default.</p> <p>To choose a different method for automatic <code>k</code> selection, simply provide the <code>method</code> parameter with the desired method name. The available methods are:</p> <ul> <li><code>elbow</code>: Based on inertia analysis for different <code>k</code> values. Uses the second derivative to identify the inflection point.</li> <li><code>silhouette</code>: Uses the silhouette coefficient to evaluate group separation. Higher values indicate better clustering.</li> <li><code>davies_bouldin</code>: Assesses group compactness and separation. The lower the index, the better the clustering.</li> <li><code>calinski_harabasz</code>: Uses the ratio between inter-cluster dispersion and intra-cluster dispersion. The higher the index, the better the clustering.</li> </ul> <p>Each method adapts better to different data characteristics. Choosing the appropriate one can significantly improve the quality of the generated strata.</p> <p>Likewise, users can limit the maximum number of strata through the <code>max_k</code> variable, which sets the highest <code>k</code> value to be considered during the automatic evaluation process.</p>"},{"location":"stratifier/#example-usage","title":"Example Usage","text":"<p>As an example, we will use an adapted dataset from Arce and Dobner Jr. (2024) for Eucalyptus dunnii. The dataset consists of 81 plots of 300\u202fm\u00b2, all with an age of 7 years.</p> <p> Download the file. </p> <p>stratifier_example.py<pre><code>from fptools.stratifier import Stratifier#(1)!\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import the <code>Stratifier</code> class.  </li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>stratifier_example.py<pre><code>df = pd.read_excel(r'C:\\Your\\path\\dados_stratifier.xlsx')#(1)!\n\ncolumns_to_check = [\n    'Idade', 'N_ha', 'd', 'h', 'Hdom',\n    'G_m2_ha', 'V_m3_ha',\n]#(2)!\n\nst = Stratifier(df, *columns_to_check)#(3)!\n\nstratified_df = st.stratify_kmeans(save_plots_dir=r\"Your\\path\\to\\save\\plots\")#(4)!\n</code></pre></p> <ol> <li>Load your <code>xlsx</code> file containing the inventory data.  </li> <li>Create a list called <code>columns_to_check</code> containing the columns to be used for stratification.  </li> <li>Create the variable <code>st</code> using the <code>df</code> dataframe, passing the <code>columns_to_check</code> as stratification parameters.  </li> <li>Perform stratification using the \"KMeans\" algorithm, allowing the algorithm to determine the number of strata. Save the results in the <code>stratified_df</code> variable. Save the generated radar chart in the specified directory.</li> </ol>"},{"location":"stratifier/#outputs","title":"Outputs","text":""},{"location":"stratifier/#tables","title":"Tables","text":"<p><code>stratified_df</code> (1)</p> <ol> <li>Initial DataFrame with an additional column called <code>Cluster</code>, which contains the cluster number assigned to each data row, ranging from 0 to <code>n</code>.</li> </ol> Chave_Parcela Idade N_ha d h Hdom G_m2_ha V_m3_ha S Cluster 14401109002_P1 7 866.67 16.63 16.09 16.50 19.43 112.77 15.44 0 14401109003_P2 7 866.67 16.55 15.02 16.47 19.91 110.36 15.17 0 14401110009_P3 7 600.00 16.96 14.07 15.32 13.92 64.83 14.71 0 1440817_P3 7 1066.67 16.45 14.53 16.49 24.24 129.46 14.61 0 1440818_P6 7 833.33 17.27 14.62 16.00 20.79 112.73 12.64 0"},{"location":"stratifier/#charts","title":"Charts","text":"Example of a radar chart generated by the `stratify_kmeans` method. The chart shows the normalized mean of each variable for each cluster."},{"location":"stratifier/#references","title":"References","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Management and planning of planted forests: with emphasis on the Pinus and Eucalyptus genera. Curitiba, PR: Ed. dos Autores, 419p.</p> <p>KARCZMAREK, Pawel; KIERSZTYN, Adam; PEDRYCZ, Witold; AL, Ebru. K-Means-based isolation forest. Knowledge-Based Systems, Amsterdam, v. 195, p. 105659, May 11, 2020. Available at:      https://doi.org/10.1016/j.knosys.2020.105659. Accessed on: May 22, 2025.</p> <p>DETRINIDAD, E.; L\u00d3PEZ-RUIZ, V\u00edctor-Ra\u00fal. The Interplay of Happiness and Sustainability: A Multidimensional Scaling and K-Means Cluster Approach. Sustainability, v. 16, n. 22, p. 10068\u201310068, November 19, 2024.</p> <p>M\u00c4RZINGER, T.; KOT\u00cdK, J.; PFEIFER, C. Application of Hierarchical Agglomerative Clustering (HAC) for Systemic Classification of Pop-Up Housing (PUH) Environments. Applied Sciences, v. 11, n. 23, p. 11122, November 24, 2021.</p>"},{"location":"tree_volume_planning/","title":"Tree Volume Planning","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Use forest inventory data to plan the trees to be sampled for volume measurement, ensuring sufficient sampling of the plantation.</p>"},{"location":"tree_volume_planning/#class-parameters","title":"Class Parameters","text":"<pre><code>TreeVolumePlanning(df, tree_dbh, tree_height)\n</code></pre> Parameters Description df The DataFrame containing the tree data. tree_dbh The name of the column containing the diameter at breast height (DBH) values of the trees (centimeters). tree_height The name of the column that contains the total heights of the trees (meters)."},{"location":"tree_volume_planning/#class-functions","title":"Class Functions","text":"functions and parameters<pre><code>  TreeVolumePlanning.resume(n_classes=10, dbh_classes=None, height_classes=None,\n                        only_height_classes=False, only_dbh_classes=False)#(1)!\n\n  TreeVolumePlanning.p_resume(n_classes=10, dbh_classes=None, height_classes=None,\n                          only_height_classes=False, only_dbh_classes=False)#(2)!\n\n  TreeVolumePlanning.get_values(n_measured_trees=10, n_classes=10, dbh_classes=None, height_classes=None,\n                            only_height_classes=False, only_dbh_classes=False)#(3)!\n</code></pre> <ol> <li> <p>n_classes = Number of classes to which the values of height and diameter at breast height will be subjected.                                        dbh_classes = (Optional) Number of DBH classes to which the values of diameter at breast height will be subjected.  If <code>None</code>, uses <code>n_classes</code> value.   height_classes = (Optional) Number of height classes to which the values of height will be subjected.  If <code>None</code>, uses <code>n_classes</code> value.   only_height_classes = (Optional) If <code>True</code>, only height classes will be used for the summary. only_dbh_classes = (Optional) only DBH classes will be used for the summary.</p> </li> <li> <p>n_classes = Number of classes to which the values of height and diameter at breast height will be subjected.                                        dbh_classes = (Optional) Number of DBH classes to which the values of diameter at breast height will be subjected. If <code>None</code>, uses <code>n_classes</code> value.    height_classes = (Optional) Number of height classes to which the values of height will be subjected. If <code>None</code>, uses <code>n_classes</code> value.    only_height_classes = (Optional) If <code>True</code>, only height classes will be used for the summary. only_dbh_classes = (Optional) only DBH classes will be used for the summary.</p> </li> <li> <p>n_measured_trees = Number of trees that will be selected for volume measurement. The default is 10.  n_classes = Number of classes to which the values of height and diameter at breast height will be subjected.                                        dbh_classes = (Optional) Number of DBH classes to which the values of diameter at breast height will be subjected. If <code>None</code>, uses <code>n_classes</code> value.   height_classes = (Optional) Number of height classes to which the values of height will be subjected.  If <code>None</code>, uses <code>n_classes</code> value.   only_height_classes = (Optional) If <code>True</code>, only height classes will be used for the summary. only_dbh_classes = (Optional) only DBH classes will be used for the summary.</p> </li> </ol> Methods Description .resume() Returns a summary of how many trees from the provided dataframe are in each class. .p_resume() Returns a summary of the percentage of trees from the provided dataframe in each class. .get_values() Returns a dataframe indicating how many trees should be sampled for volume measurement in each class, based on the percentage representation of each class in the total inventory."},{"location":"tree_volume_planning/#example-usage","title":"Example Usage","text":"<p>Considering the data resulting from the hypsometric relationship established in the previous module, we will carry out the tree volume planning.</p> <p> Download example file. </p> <p>First 5 rows of the file:</p> Parcela Dap (cm) H (m) Idade (anos) best_predicted_height selected_model p-1 22.28 0 15 21.91910582 y = y ~ x = 1/x^2 p-1 23.87 22.2 15 22.2 Real Height p-1 25.46 0 15 23.30513332 y = y ~ x = 1/x^2 p-1 25.78 24.5 15 24.5 Real Height p-1 26.74 22.2 15 22.2 Real Height <p>taper_functions_example.py<pre><code>from fptools.tree_volume_planning import TreeVolumePlanning#(1)!\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import <code>TreeVolumePlanning</code> class.</li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>Create a variable for the Volumetrics Class taper_functions_example.py<pre><code>df = pd.read_excel(r'C:\\Seu\\diretorio\\final_results.xlsx')#(1)!\n\ncub = TreeVolumePlanning(df ,'Dap (cm)','best_predicted_height')#(2)!\n\nresume = cub.resumen(n_classes=6)#(3)!\n\npercentual_resume = cub.p_resume(n_classes=6)#(4)!\n\nto_measure = cub.get_values(n_measured_trees=50, n_classes=6)#(5)!\n</code></pre></p> <ol> <li>Load your <code>.xlsx</code> file.</li> <li>Create the variable <code>cub</code> containing the <code>TreeVolumePlanning</code> class, using the column <code>Dap (cm)</code> for DBH values and the column <code>best_predicted_height</code> for height values.</li> <li>Return a summary of how many trees from the provided dataframe are in each class (6 classes) and store it in the variable <code>resume</code>.</li> <li>Return a summary of the percentage of trees from the provided dataframe in each class (6 classes) and store it in the variable <code>percentual_resume</code>.</li> <li>Return a dataframe indicating how many trees should be sampled for volume measurement in each class, distributing the 50 trees (<code>n_measured_trees</code>) based on the percentage representation of each class in the total inventory, and store it in the variable <code>to_measure</code>.</li> </ol>"},{"location":"tree_volume_planning/#outputs","title":"Outputs","text":""},{"location":"tree_volume_planning/#tables","title":"Tables","text":"<p><code>resume</code>(1)</p> <ol> <li>DataFrame showing how many trees are in each of the 6 generated height and DBH classes.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 9 2 0 3 2 0 (27.108, 31.937] 3 13 4 4 1 0 (31.937, 36.765] 0 14 8 13 2 0 (36.765, 41.593] 0 5 9 21 1 0 (41.593, 46.422] 0 2 2 6 3 1 (46.422, 51.25] 0 0 3 0 2 2 <p><code>percentual_resume</code>(1)</p> <ol> <li>DataFrame showing the percentage of trees in each of the 6 generated height and DBH classes relative to the total number of trees.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 6.67 1.48 0.00 2.22 1.48 0.00 (27.108, 31.937] 2.22 9.63 2.96 2.96 0.74 0.00 (31.937, 36.765] 0.00 10.37 5.93 9.63 1.48 0.00 (36.765, 41.593] 0.00 3.70 6.67 15.56 0.74 0.00 (41.593, 46.422] 0.00 1.48 1.48 4.44 2.22 0.74 (46.422, 51.25] 0.00 0.00 2.22 0.00 1.48 1.48 <p><code>to_measure</code>(1)</p> <ol> <li>DataFrame showing how many trees (out of the 50 specified in <code>n_measured_trees</code>) should be measured in each of the 6 height and DBH classes.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 3 1 0 1 1 0 (27.108, 31.937] 1 5 2 1 0 0 (31.937, 36.765] 0 5 3 5 1 0 (36.765, 41.593] 0 2 3 8 0 0 (41.593, 46.422] 0 1 1 2 1 0 (46.422, 51.25] 0 0 1 0 1 1 <p>Thus, the user obtains how many trees should be sampled for volume measurement in each DBH and height class.</p> <p>About class intervals</p> <p>The intervals use the following notation: - <code>(</code> means the value is not included - <code>]</code> means the value is included</p> <p>For example, the interval <code>(22.251, 27.108]</code> includes values greater than 22.251 and less than or equal to 27.108.</p> <p>It is not mandatory to create both height and DBH classes simultaneously \u2014 it is possible to create only height classes or only DBH classes, as shown in the example below:</p> <p>taper_functions_example.py<pre><code>to_measure = cub.get_values(n_measured_trees=50, dbh_classes=6,\n                            only_dbh_classes=True)#(1)!\n</code></pre></p> <ol> <li>Defines that 50 trees will be measured, divided into 6 DBH-only classes.</li> </ol> DBH classes n_trees (22.25, 27.108] 6 (31.937, 36.765] 14 (46.422, 51.25] 3 (36.765, 41.593] 13 (27.108, 31.937] 9 (41.593, 46.422] 5 <p>It is also possible to create a different number of classes for height and DBH, as shown in the example below:</p> <p>taper_functions_example.py<pre><code>to_measure = cub.get_values(n_measured_trees=50, dbh_classes=6,\n                            height_classes=2)#(1)!\n</code></pre></p> <ol> <li>Defines that 50 trees will be measured, divided into 6 DBH classes and 2 height classes.</li> </ol> DBH classes H(21.904, 29.71] H(29.71, 37.5] (22.251, 27.108] 4 2 (27.108, 31.937] 7 2 (31.937, 36.765] 8 6 (36.765, 41.593] 5 8 (41.593, 46.422] 2 4 (46.422, 51.25] 1 1"},{"location":"utils/","title":"Utils","text":"<p>Warning</p> <p>This library is under development; none of the provided solutions are available for download.</p> <p>This module contains auxiliary functions that may be useful to users during the processing and analysis of forest data.</p>"},{"location":"utils/#available-functions","title":"Available Functions","text":"<pre><code>from fptools.utils import stats_summary, get_metrics, plot_x_y\n</code></pre>"},{"location":"utils/#stats_summary","title":"<code>stats_summary</code>","text":"<p>Generates a statistical summary for the specified numeric columns of a DataFrame.</p> <p>Parameters: - <code>df</code>: Pandas DataFrame with the input data. - <code>*args</code>: Names of the numeric columns to be summarized. - <code>ignore_zeros</code> (bool): If <code>True</code>, zero values are ignored in the calculations. - <code>language</code> (str): Sets the output column language. Accepts <code>\"en\"</code> or <code>\"pt-br\"</code>.  </p> <p>Output: - DataFrame with statistics: mean, minimum, maximum, standard deviation, coefficient of variation (CV), quartiles (Q1, Q2, Q3), and interquartile range (IQR).</p>"},{"location":"utils/#get_metrics","title":"<code>get_metrics</code>","text":"<p>Calculates evaluation metrics for predictive models.</p> <p>Parameters: - <code>real_y</code>: List or array with the actual values. - <code>predicted_y</code>: List or array with the predicted values.  </p> <p>Calculated metrics: - MAE: Mean Absolute Error. - MAPE: Mean Absolute Percentage Error. - MSE: Mean Squared Error. - RMSE: Root Mean Squared Error. - R\u00b2: Coefficient of determination. - Explained variance. - Mean error (model bias).  </p> <p>Output: - Tuple with the metric values in the following order: <code>(mae, mape, mse, rmse, r_squared, explained_variance, mean_error)</code>.  </p>"},{"location":"utils/#plot_x_y","title":"<code>plot_x_y</code>","text":"<p>Generates a scatter plot for one variable <code>x</code> and one or more variables <code>y</code>.</p> <p>Parameters: - <code>x</code>: List or array with the X-axis values. - <code>*ys</code>: One or more lists or arrays with the Y-axis values.  </p> <p>Behavior: - Each <code>y</code> series is represented with a unique combination of marker and color. - Axes start from zero, grid is shown in the background, and each <code>y</code> series has a legend.  </p> <p>Output: - Displays the plot on screen.  </p>"},{"location":"volumetrics/","title":"Volumetrics","text":"<p>Warning</p> <p>This library is under development, none of the presented solutions are available for download.</p> <p>Process forest inventory data. Adjust volumetric equations and taper functions for later use.</p>"},{"location":"volumetrics/#class-parameters","title":"Class Parameters","text":"<pre><code>Volumetrics(df, tree_identifier, tree_height, tree_dbh,\n            segment_height, segment_diameter, tree_bark)\n</code></pre> Parameters Description df The dataframe containing the cubage data. tree_identifier The name of the column that contains the unique identifiers of the trees. tree_height The name of the column that contains the total heights of the trees (meters). tree_dbh The name of the column containing the diameter at breast height (DBH) values of the trees (centimeters). segment_height (Optional) The name of the column containing the heights of the cubed segments of the trees (meters). Required for <code>fit_taper_functions()</code> method. segment_diameter (Optional) The name of the column containing the diameters of the cubed segments of the trees (centimeters). Required for <code>fit_taper_functions()</code> method. tree_bark (Optional) The name of the column containing the bark thickness values of the trees (centimeters). If  <code>tree_bark == None</code>  return only volumes with bark on 'get_volumes()' method."},{"location":"volumetrics/#class-functions","title":"Class Functions","text":"<p>functions and parameters<pre><code>  Volumetrics.get_volumes(iterator=None)#(1)!\n\n  Volumetrics.fit_taper_functions(models, iterator, save_dir = None)#(2)!\n\n  Volumetrics.fit_volumetric_functions(models, iterator, vol_column,\n                                       save_dir = None)#(3)!\n\n  Volumetrics.get_individual_diameter(hi, tree_height, tree_dbh)#(4)!\n\n  Volumetrics.get_individual_taper_volume(tree_height, tree_dbh, stump=0.1)#(5)!\n\n  Volumetrics.get_individual_volume(tree_height, tree_dbh)#(6)!\n</code></pre></p> <ol> <li>iterator = (Optional) A column name string. Defines wich column will be used as a iterator. Could be a farm name, plot name, code or any unique identification tag.</li> <li>models = (Optional) List of models to be fitted! If <code>models == None</code> uses all available models.                                      iterator = (Optional) A column name string. Defines wich column will be used as a iterator. Could be a farm name, plot name, code or any unique identification tag. save_dir = (Optional) A directory to save the fitted function parameters and ann model.</li> <li>models = (Optional) List of models to be fitted! If <code>models == None</code> uses all available models.                                      iterator = (Optional) A column name string. Defines wich column will be used as a iterator. Could be a farm name, plot name, code or any unique identification tag.    vol_column = (Optional) A column name to the volume values. If <code>vol_column == None</code>, it uses de volumes obtained by the <code>get_volumes()</code> method to fit the volumetric functions. save_dir = (Optional) A directory to save the fitted function parameters and ann model.</li> <li>hi = Fraction of height from which you want to obtain the diameter (meters).                                      tree_height =  Total height of the tree (meters). tree_dbh = Diameter at breast height (DBH) value of the tree (centimeters).</li> <li>tree_height = Total height of the tree (meters).                                      tree_dbh = Diameter at breast height (DBH) of the tree (centimeters). stump = Stump height (meters). By default, uses <code>stump = 0.1</code>.  </li> <li>tree_height = Total height of the tree (meters).                                      tree_dbh = Diameter at breast height (DBH) of the tree (centimeters).  </li> </ol> Methods Description .get_volumes() Returns the volume of each cubed segment and the total volume of each tree separated by <code>tree_identifier</code>. If <code>tree_bark == None</code>, it returns only the volume with bark; otherwise, it returns the volume with and without bark. .fit_taper_functions() Fits the available taper function models. Saves a <code>.json</code> file with the coefficients for each fitted model and a <code>.pkl</code> file for the fitted ANN's. .get_individual_diameter() Returns a pandas dataframe with diameter at a given <code>hi</code> height of the tree for each fitted taper model. .get_individual_taper_volume() Returns a pandas DataFrame with the estimated volume for the provided height and diameter at breast height for each fitted taper function. It uses the integration of taper functions to obtain the result. .fit_volumetric_functions() Fits the available volumetric models. Saves a .json file with the coefficients for each fitted model and a .pkl file for the fitted ANN models. .get_individual_volume() Returns a pandas DataFrame with the estimated volume for the provided height and diameter at breast height for each fitted volumetric function."},{"location":"volumetrics/#example-usage","title":"Example Usage","text":"<p>Consider a volume dataset composed of 50 Eucalyptus trees, in which diameters were measured at heights of 0.1 meter, 0.6 meter, 1.30 meters, and, from that point onward, at 2-meter intervals along the stem.</p> <p> Download example file. </p> <p>First 5 rows of the file:  </p> Fazenda arvore_n dap (cm) altura_total (m) se\u00e7\u00e3o (m) diametro_c_casca (cm) diametro_s_casca (cm) casca (cm) Fazenda 1 1 24.8 28.0 0.1 30.05 26.51 1.74 Fazenda 1 1 24.8 28.0 0.6 26.55 23.15 1.96 Fazenda 1 1 24.8 28.0 1.3 24.75 21.93 1.94 Fazenda 1 1 24.8 28.0 2.0 23.85 21.48 1.90 Fazenda 1 1 24.8 28.0 4.0 21.40 19.30 1.11 <p>taper_functions_example.py<pre><code>from fptools.Volumetrics import Volumetrics#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Import <code>Volumetrics</code> class.</li> <li>Import <code>pandas</code> for data manipulation.</li> </ol> <p>taper_functions_example.py<pre><code>dados = pd.read_excel(r'C:\\seu\\diret\u00f3rio\\exemplo_volumetrics.xlsx')#(1)!\n\nvol = Volumetrics(df=dados, tree_identifier='arvore_n',\n                  tree_height='altura_total (m)',\n                  tree_dbh ='dap (cm)',\n                  segment_height='se\u00e7\u00e3o (m)',\n                  segment_diameter= 'diametro_c_casca (cm)',\n                  tree_bark='casca (cm)')#(2)!\n\ncalculated_volumes_df = vol.get_volumes(iterator=\"Fazenda\")#(3)!\ncalculated_volumes_df.to_excel(\"exemplo_volumetrics_with_vol.xlsx\",\n                               index=False)#(4)!\n\nmetrics_taper = vol.fit_taper_functions(save_dir=\"seu/diret\u00f3rio/para/salvar\",iterator=\"Fazenda\")#(5)!\n\nindividual_diameter = vol.get_individual_diameter(10, 31, 30)#(6)!\n\ntaper_volume = vol.get_individual_taper_volume(35, 32, stump=0.15)#(7)!\n\nmetrics_vol = vol.fit_volumetric_functions(save_dir=output_path, iterator=\"Fazenda\")#(8)!\n\nindividual_volume = vol.get_individual_volume(tree_height=21.8, tree_dbh=19)#(9)!\n</code></pre></p> <ol> <li>Load your <code>.xlsx</code> file.  </li> <li>Create the variable <code>vol</code> containing the <code>Volumetrics</code> class.  </li> <li>Calculate the volumes for each tree and segment, grouped by <code>iterator</code>, and save the results in the variable <code>calculated_volumes_df</code>. The original DataFrame will be returned with the following additional columns: <code>segment_vol_with_bark</code>, <code>segment_vol_without_bark</code>, <code>tree_vol_with_bark</code>, <code>tree_vol_without_bark</code>, <code>bark_factor</code>, and <code>mean_bark_factor</code>.  </li> <li>Save the DataFrame with the calculated volumes as <code>exemplo_volumetrics_with_vol.xlsx</code>.  </li> <li>Fit taper functions and artificial neural networks for each <code>iterator</code>, saving the performance metrics in the variable <code>metrics_taper</code>. This will create a <code>.json</code> file with the model coefficients and <code>.pkl</code> files for the trained ANN models, storing all generated files in <code>save_dir</code>.  </li> <li>Get the diameter at 10 meters for a tree with a total height of 31 meters and a diameter at breast height (DBH) of 30 centimeters using the fitted models, saving it in the variable <code>individual_diameter</code>.  </li> <li>Get the volumes calculated by integrating the taper functions for a tree with a height of 35 meters and DBH of 32 centimeters, considering a stump height of 0.15 meters, and save it in the variable <code>taper_volume</code>.  </li> <li>Fit all volumetric functions for each <code>iterator</code> and save the results in <code>save_dir</code>, storing the metrics in the variable <code>metrics_vol</code>. Since no <code>vol_column</code> was provided, it will use the volume obtained through the <code>get_volumes</code> method to fit the models.  </li> <li>Calculate the volume of a tree with a height of 21.8 meters and a DBH of 19 centimeters using all volumetric functions and save it in the variable <code>individual_volume</code>.  </li> </ol>"},{"location":"volumetrics/#output","title":"Output","text":""},{"location":"volumetrics/#tables","title":"Tables","text":"<p><code>calculated_volumes_df</code>(1)</p> <ol> <li>Initial DataFrame with the following additional columns: <code>segment_vol_with_bark</code>, <code>segment_vol_without_bark</code>, <code>tree_vol_with_bark</code>, <code>tree_vol_without_bark</code>, <code>bark_factor</code>, <code>mean_bark_factor</code> </li> </ol> Fazenda arvore_n dap (cm) altura_total (m) se\u00e7\u00e3o (m) diametro_c_casca (cm) diametro_s_casca (cm) casca (cm) segment_vol_with_bark segment_vol_without_bark tree_vol_with_bark tree_vol_without_bark bark_factor mean_bark_factor Fazenda 1 1 24.84076433 28.0 0.1 30.05 26.51 1.74 0.007092165 0.005544635 0.559879936 0.387477996 0.692073373 0.682430303 Fazenda 1 1 24.84076433 28.0 0.6 26.55 23.15 1.96 0.031450877 0.023341421 0.559879936 0.387477996 0.692073373 0.682430303 Fazenda 1 1 24.84076433 28.0 1.3 24.75 21.93 1.94 0.036171179 0.026055822 0.559879936 0.387477996 0.692073373 0.682430303 Fazenda 1 1 24.84076433 28.0 2.0 23.85 21.48 1.90 0.032463883 0.02310445 0.559879936 0.387477996 0.692073373 0.682430303 Fazenda 1 1 24.84076433 28.0 4.0 21.40 19.30 1.11 0.080407591 0.065402308 0.559879936 0.387477996 0.692073373 0.682430303 Fazenda 1 1 24.84076433 28.0 6.0 20.50 19.17 1.81 0.068942643 0.047175553 0.559879936 0.387477996 0.692073373 0.682430303 <p>About the generated columns</p> <ul> <li><code>segment_vol_with_bark</code>: Stem segment with bark volume, calculated between two consecutive measurement sections.  </li> <li><code>segment_vol_without_bark</code>: Stem segment without bark volume, calculated between two consecutive measurement sections.  </li> <li><code>tree_vol_with_bark</code>: Total tree with bark volume, obtained by summing all segment volumes with bark.  </li> <li><code>tree_vol_without_bark</code>: Total tree without bark volume, obtained by summing all segment volumes without bark.  </li> <li><code>bark_factor</code>: Bark factor of the segment, calculated as the ratio between the volume with bark and the volume without bark for that segment.  </li> <li><code>mean_bark_factor</code>: Average bark factor of the tree, calculated as the mean of the bark factors from all segments.  </li> </ul> <p><code>metrics_taper</code>(1)</p> <ol> <li>DataFrame with evaluation metrics generated for each <code>iterator</code> and taper model and artificial neural network, including the score assigned to each model based on its performance.  </li> </ol> iterator model MAE MAPE MSE RMSE R squared Explained Var Mean Error score Fazenda 1 kozak 0.580666 5.718699 0.572843 0.756864 0.994621 0.994621 -0.000167 10 Fazenda 1 bi 0.635942 5.972947 0.643045 0.801901 0.993962 0.994016 -0.075560 9 Fazenda 1 ann 0.576319 5.651187 0.560707 0.748804 0.994735 0.994739 0.020658 8 Fazenda 1 schoepfer 0.769151 7.532993 1.033545 1.016634 0.990295 0.990356 -0.080168 7 Fazenda 1 johnson 1.078775 10.108434 1.978243 1.406500 0.981425 0.981571 -0.124507 6 Fazenda 1 matte 1.424262 14.718423 3.337336 1.826838 0.968664 0.969344 0.269282 5 Fazenda 2 ann 1.342497 7.238220 3.318417 1.821652 0.988023 0.988023 0.001891 10 Fazenda 2 kozak 1.350729 7.357823 3.468079 1.862278 0.987483 0.987483 -0.002186 9 Fazenda 2 bi 1.374535 7.880664 3.483492 1.866412 0.987427 0.987435 -0.045863 8 Fazenda 2 schoepfer 1.678529 8.785657 4.895865 2.212660 0.982329 0.982373 0.110280 7 Fazenda 2 matte 2.180025 13.928099 7.414827 2.723018 0.973238 0.974475 0.585444 6 Fazenda 2 johnson 2.216439 12.099970 9.165003 3.027376 0.966921 0.966956 0.097858 5 <p><code>individual_diameter</code>(1)</p> <ol> <li>DataFrame with the individual diameters estimated by the taper functions and artificial neural networks for each <code>iterator</code> and taper model, for a tree with a height of 31 meters, a DBH of 30 centimeters, at a height of 10 meters.  </li> </ol> iterator model Predicted_diameter (cm) Fazenda 1 schoepfer 22.75296935 Fazenda 1 bi 22.35954058 Fazenda 1 kozak 22.45146956 Fazenda 1 johnson 23.41945889 Fazenda 1 matte 22.83651908 Fazenda 1 ann 23.33443805 Fazenda 2 schoepfer 21.48912862 Fazenda 2 bi 23.08526645 Fazenda 2 kozak 22.40805692 Fazenda 2 johnson 22.46401882 Fazenda 2 matte 21.43830806 Fazenda 2 ann 23.71472482 <p><code>taper_volume</code>(1)</p> <ol> <li>DataFrame with the volumes estimated by integrating the taper functions and artificial neural networks for each <code>iterator</code> and taper model, for a tree with a height of 35 meters and a DBH of 32 centimeters.  </li> </ol> iterator model Predicted_volume (m\u00b3) Fazenda 1 schoepfer 1.166056704 Fazenda 1 bi 1.143061281 Fazenda 1 kozak 1.165284829 Fazenda 1 johnson 1.201758409 Fazenda 1 matte 1.150231088 Fazenda 1 ann 1.326654958 Fazenda 2 schoepfer 1.055148596 Fazenda 2 bi 1.179288353 Fazenda 2 kozak 1.147756782 Fazenda 2 johnson 1.108690858 Fazenda 2 matte 1.066598472 Fazenda 2 ann 1.178903371 <p><code>metrics_vol</code>(1)</p> <ol> <li>DataFrame with evaluation metrics generated for each <code>iterator</code>, volumetric model, and artificial neural network, including the score assigned to each model based on its performance.  </li> </ol> iterator model MAE MAPE MSE RMSE R squared Explained Var Mean Error score Fazenda 1 honner 0.028987 6.510184 0.001409 0.037535 0.998022 0.998143 -0.009291 10 Fazenda 1 ann 0.020789 5.362507 0.000713 0.026703 0.998999 0.998999 -0.000569 9 Fazenda 1 takata 0.027501 5.250705 0.001291 0.035934 0.998187 0.998214 -0.004318 8 Fazenda 1 spurr_log 0.026612 4.438766 0.001235 0.035137 0.998267 0.998277 -0.002731 7 Fazenda 1 schumacher_hall 0.027584 4.649301 0.001203 0.034683 0.998311 0.998321 -0.002636 6 Fazenda 1 meyer 0.025136 6.229777 0.001112 0.033346 0.998439 0.998439 0.000000 5 Fazenda 1 stoate 0.026301 6.530368 0.001158 0.034029 0.998374 0.998374 0.000000 4 Fazenda 1 spurr 0.026008 9.348743 0.001177 0.034306 0.998348 0.998348 0.000000 3 Fazenda 1 naslund 0.024859 11.898225 0.001020 0.031930 0.998569 0.998571 0.001263 2 Fazenda 1 ogaya 0.410646 151.1923 0.213968 0.462567 0.699650 0.719168 -0.117918 1 Fazenda 2 naslund 0.153069 6.603060 0.048230 0.219612 0.974528 0.974529 -0.001349 10 Fazenda 2 schumacher_hall 0.160824 9.781453 0.048410 0.220023 0.974433 0.974447 -0.005183 9 Fazenda 2 spurr_log 0.160540 9.932109 0.048446 0.220105 0.974414 0.974428 -0.005270 8 Fazenda 2 takata 0.159037 6.922203 0.049057 0.221488 0.974091 0.974091 -0.000386 7 Fazenda 2 ann 0.150892 5.508166 0.043498 0.208562 0.977027 0.977053 0.007015 6 Fazenda 2 meyer 0.155147 8.411204 0.047824 0.218687 0.974742 0.974742 0.000000 5 Fazenda 2 stoate 0.161432 14.918844 0.048986 0.221328 0.974129 0.974129 0.000000 4 Fazenda 2 spurr 0.181962 28.583026 0.055897 0.236425 0.970479 0.970479 0.000000 3 Fazenda 2 honner 0.189541 6.829942 0.062964 0.250927 0.966746 0.967397 0.035110 2 Fazenda 2 ogaya 0.430466 40.223791 0.284181 0.533086 0.849913 0.850523 0.034001 1 <p><code>individual_volume</code>(1)</p> <ol> <li>DataFrame with the volumes estimated by the volumetric functions and artificial neural networks for each <code>iterator</code>, for a tree with a height of 21.8 meters and a DBH of 19 centimeters.  </li> </ol> iterator model Predicted_volume (m\u00b3) Fazenda 1 spurr 0.241827831 Fazenda 1 schumacher_hall 0.248607044 Fazenda 1 honner 0.262977386 Fazenda 1 ogaya 0.860375777 Fazenda 1 naslund 0.245824632 Fazenda 1 takata 0.255820523 Fazenda 1 spurr_log 0.251481659 Fazenda 1 meyer 0.228396501 Fazenda 1 stoate 0.241410100 Fazenda 1 ann 0.271805848 Fazenda 2 spurr 0.421606899 Fazenda 2 schumacher_hall 0.332105882 Fazenda 2 honner 0.232727813 Fazenda 2 ogaya 0.939382897 Fazenda 2 naslund 0.324612548 Fazenda 2 takata 0.287273333 Fazenda 2 spurr_log 0.336234242 Fazenda 2 meyer 0.200621992 Fazenda 2 stoate 0.242861095 Fazenda 2 ann 0.284503571"},{"location":"volumetrics/#json-files","title":"<code>.json</code> Files","text":"<p>For each taper and volumetric function, <code>.json</code> files are generated containing the estimated coefficients of each model. An individual <code>.json</code> file is created for each iterator, named according to its respective identifier.</p> <ul> <li>taper_functions_coefficients_Fazenda 1.json</li> <li>taper_functions_coefficients_Fazenda 2.json</li> <li>volumetrics_functions_coefficients_Fazenda 1.json</li> <li>volumetrics_functions_coefficients_Fazenda 2.json</li> </ul>"},{"location":"volumetrics/#pkl-files","title":"<code>.pkl</code> Files","text":"<p>Similarly, for each artificial neural network trained for tapering or volume prediction, a <code>.pkl</code> file is generated containing the trained model, named according to the respective iterator.</p> <ul> <li>taper_model_ann_Fazenda 1.pkl  </li> <li>taper_model_ann_Fazenda 2.pkl  </li> <li>volumetric_ann_Fazenda 1.pkl  </li> <li>volumetric_ann_Fazenda 2.pkl  </li> </ul> <p>Although this type of file cannot be viewed directly, it stores the neural network parameters and internal configurations, which will be used later in the generation of assortments.</p>"},{"location":"volumetrics/#available-taper-models","title":"Available taper models","text":""},{"location":"volumetrics/#schoepfer","title":"<li>schoepfer</li>","text":"\\[ \\operatorname{d_i} =dbh\\left( b_0 + b_1 \\left( \\frac{h_i}{H} \\right) + b_2 \\left( \\frac{h_i}{H} \\right)^2 + b_3 \\left( \\frac{h_i}{H} \\right)^3 + b_4 \\left( \\frac{h_i}{H} \\right)^4 + b_5 \\left( \\frac{h_i}{H} \\right)^5 \\right) \\]"},{"location":"volumetrics/#bi","title":"<li>bi</li>","text":"\\[ \\operatorname{d_i}=dbh\\left[ \\left( \\frac{log\\;sin \\left( \\frac{\\pi}{2} \\frac{h_i}{H} \\right)} {log\\;sin \\left( \\frac{\\pi}{2} \\frac{1.3}{H} \\right)} \\right) ^{\\beta_0+\\beta_1sin\\left(\\frac{\\pi}{2}\\frac{h_i}{H}\\right)+\\beta_2sin\\left(\\frac{3\\pi}{2}\\frac{h_i}{H}\\right)+\\beta_3sin\\left(\\frac{\\pi}{2}\\frac{h_i}{H}\\right)/\\frac{h_i}{H}+\\beta_4dbh+\\beta_5\\frac{h_i}{H}\\sqrt{dbh}+\\beta_6\\frac{h_i}{H}\\sqrt{H}} \\right] \\]"},{"location":"volumetrics/#kozak","title":"<li>kozak</li>","text":"\\[ \\operatorname{d_i} =b_0 \\cdot (dbh^{b_1}) \\cdot (h^{b_2}) \\cdot \\left(\\frac{1 - \\left(\\frac{h_i}{h}\\right)^{1/4}}{1 - \\left(p^{1/3}\\right)}\\right)^{b_3 \\cdot \\left(\\frac{h_i}{h}\\right)^4 + b_4 \\cdot \\left(\\frac{1}{e^{dbh/h}}\\right) + b_5 \\cdot \\left(\\frac{1 - \\left(\\frac{h_i}{h}\\right)^{1/4}}{1 - \\left(p^{1/3}\\right)}\\right)^{0.1} + b_6 \\cdot \\left(\\frac{1}{dbh}\\right) + b_7 \\cdot \\left(h^{1 - \\left(\\frac{h_i}{h}\\right)^{1/3}}\\right) + b_8 \\cdot \\left(\\frac{1 - \\left(\\frac{h_i}{h}\\right)^{1/4}}{1 - \\left(p^{1/3}\\right)}\\right)} \\]"},{"location":"volumetrics/#johnson","title":"<li>johnson</li>","text":"\\[ \\operatorname{d_i} = dbh \\cdot \\left( b_0 \\cdot \\log\\left( \\frac{b_1 + \\frac{(H - h_i)}{(H - 1.3)}}{b_2} \\right) \\right) \\]"},{"location":"volumetrics/#matte","title":"<li>matte</li>","text":"\\[ \\operatorname{d_i} = dbh \\cdot \\left( b_0 \\cdot \\left( \\frac{H - h_i}{H - 1.30} \\right)^2 + b_1 \\cdot \\left( \\frac{H - h_i}{H - 1.30} \\right)^3 + b_2 \\cdot \\left( \\frac{H - h_i}{H - 1.30} \\right)^4 \\right) \\]"},{"location":"volumetrics/#ann","title":"<li>ann</li>","text":""},{"location":"volumetrics/#notation","title":"Notation","text":"<ul> <li>\\( \u03b2_n \\): Fitted parameters</li> <li>\\( d_i \\): Diameter (cm)</li> <li>\\( \\text{dbh} \\): Diameter at breast height (cm)</li> <li>\\( H \\): Total height (m)</li> <li>\\( h_i \\): Segment height (m)</li> </ul>"},{"location":"volumetrics/#artificial-neural-network","title":"Artificial Neural Network","text":"<p>When selecting the 'ann' model, 6 different structures of artificial neural networks will be tested. Only the result from 1 model will be returned. The model returned will be selected by the ranking function. For the 'ann' model, the module sklearn.neural_network.MLPRegressor is used. --- title: ANN Parameters --- classDiagram     direction LR      class MLPRegressor {       Epochs: 3000       Activation: logistic       Solver Mode: lbfgs       Batch size: dynamic       Learning rate init: 0.1       Learning rate mode: adaptive     }      class Model-0 {       Hidden layer sizes: (15, 25, 20, 30, 10)     }     class Model-1 {       Hidden layer sizes: (35, 10, 25, 35, 15)      }     class Model-2 {       Hidden layer sizes: (25, 15, 30, 20)      }     class Model-3 {       Hidden layer sizes: (15, 35, 45)     }     class Model-4 {       Hidden layer sizes: (35, 10, 25, 35, 15)     }     class Model-5 {        Hidden layer sizes: (35, 10, 25, 35, 15, 20, 15, 30)     }       MLPRegressor &lt;|-- Model-0     MLPRegressor &lt;|-- Model-1     MLPRegressor &lt;|-- Model-2     MLPRegressor &lt;|-- Model-3     MLPRegressor &lt;|-- Model-4     MLPRegressor &lt;|-- Model-5</p>"},{"location":"volumetrics/#available-volumetric-models","title":"Available volumetric models","text":""},{"location":"volumetrics/#spurr","title":"<li>spurr</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot (\\text{dbh}^2) \\cdot H \\]"},{"location":"volumetrics/#schumacher_hall","title":"<li>schumacher_hall</li>","text":"\\[ \\operatorname{V} = b_0 \\cdot (\\text{dbh}^{b_1}) \\cdot (H^{b_2}) \\]"},{"location":"volumetrics/#honner","title":"<li>honner</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dbh}^2}{b_1 \\cdot \\left(\\frac{1}{H}\\right)} \\]"},{"location":"volumetrics/#ogaya","title":"<li>ogaya</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dbh}^2}{b_1 \\cdot H} \\]"},{"location":"volumetrics/#stoate","title":"<li>stoate</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot \\text{dbh}^2 + b_2 \\cdot \\text{dbh}^2 \\cdot H + b_3 \\cdot H \\]"},{"location":"volumetrics/#naslund","title":"<li>naslund</li>","text":"\\[ \\operatorname{V} = b_1 \\cdot \\text{dbh}^2 + b_2 \\cdot \\text{dbh}^2 \\cdot H + b_3 \\cdot \\text{dbh} \\cdot H^2 + b_4 \\cdot H^2 \\]"},{"location":"volumetrics/#takata","title":"<li>takata</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dbh}^2 \\cdot H}{b_0 + b_1 \\cdot \\text{dbh}} \\]"},{"location":"volumetrics/#spurr_log","title":"<li>spurr_log</li>","text":"\\[ \\operatorname{V} = \\exp(b_0 + b_1 \\cdot \\log(\\text{dbh}^2 \\cdot H)) \\]"},{"location":"volumetrics/#meyer","title":"<li>meyer</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot \\text{dbh}^2 + b_2 \\cdot \\text{dbh} + b_3 \\cdot \\text{dbh} \\cdot H + b_4 \\cdot \\text{dbh}^2 \\cdot H \\]"},{"location":"volumetrics/#ann_1","title":"<li>ann</li>","text":"<p>Use the same ann models used for taper function.</p>"},{"location":"volumetrics/#notation_1","title":"Notation","text":"<ul> <li>\\( b_n \\): Fitted parameters</li> <li>\\( V \\): Estimated volume (m\u00b3)</li> <li>\\( \\text{dbh} \\): Diameter at breast height (cm)</li> <li>\\( H \\): Total height (m)</li> </ul>"},{"location":"volumetrics/#ranking-function","title":"Ranking function","text":"<p>To select the best-performing models and rank them accordingly, the following metrics are obtained:</p> M\u00e9tric name Structure Mean Absolute Error (MAE) \\( MAE = \\frac{1}{n} \\sum_{i=1}^{n} \\|y_i - \\hat{y}_i\\| \\) Mean Absolute Percentage Error (MAPE) \\( MAPE = \\frac{100}{n} \\sum_{i=1}^{n} \\left\\|\\frac{y_i - \\hat{y}_i}{y_i}\\right\\| \\) Mean Squared Error (MSE) \\( MSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 \\) Root Mean Squared Error (RMSE) \\( RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2} \\) R Squared (Coefficient of Determination) \\( R^2 = 1 - \\frac{\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} \\) Explained Variance (EV) \\( EV = 1 - \\frac{Var(y - \\hat{y})}{Var(y)} \\) Mean Error \\( Mean\\ Error = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i) \\)"},{"location":"volumetrics/#notation_2","title":"Notation","text":"<ul> <li>\\( y_i \\): Observed value for the i-th observation  </li> <li>\\( \\hat{y}_i \\): Estimated (predicted) value for the i-th observation  </li> <li>\\( n \\): Total number of observations  </li> <li>\\( \\bar{y} \\): Mean of the observed values</li> </ul> <p>After obtaining the metrics for each tested model, the best model receives a score of 10, while the others receive scores of 9, 8, and so on.</p>"},{"location":"volumetrics/#references","title":"References","text":"<p>BI, H. (2000). Trigonometric variable-form taper equations for Australian eucalypts. Forest Science, 46(3), 397\u2013409.</p> <p>JOHNSON, T. (1911). Taxatariska unders\u00f6kringar om skogstr\u00e4dens form. Skgsvardsf\u00f6reningens tiedskrifle. H\u00e4fte, Berlim, 9(10), 285\u2013329.</p> <p>KOZAK, A. (2004). My last words on taper equations. The Forestry Chronicle, 80(4), 507\u2013515.</p> <p>MATTE, L. (1949). The taper of coniferous species with special reference to Loblolly Pine. Forestry Chronicle, Mattawa, 25(1), 21\u201331.</p> <p>MEYER, H. A. (1940). A mathematical expression for height curves. Journal of Forestry, 38, 415\u2013420.      https://doi.org/10.1093/jof/38.5.415</p> <p>N\u00c4SLUND, M. (1936). Skogsf\u00f6rs\u00f6ksanstaltens gallringsf\u00f6rs\u00f6k i tallskog. Meddelanden fr\u00e5n Statens Skogsf\u00f6rs\u00f6ksanstalt, Swedish Institute of Experimental Forestry, 29: 169.</p> <p>SCH\u00d6EPFER, W. (1966). Automatisierung des Massen-, Sorten- und Wertberechnung stehender Waldbest\u00e4nde. Schriftenreihe Bad. Wurtt-Forstl.</p> <p>SCHUMACHER, F. X.; HALL, F. S. (1933). Logarithmic expression of timber tree volume. Journal of Agricultural Research, Washington, 47(9), 719\u2013734.</p> <p>SCOLFORO, J. R. S. (2005). Biometria Florestal: Parte I: Modelos de regress\u00e3o linear e n\u00e3o-linear; Parte II: Modelos para rela\u00e7\u00e3o hipsom\u00e9trica, volume, afilamento e preso de mat\u00e9ria seca. Lavras: UFLA/FAEPE, pp. 224\u2013226.</p> <p>SPURR, S. R. (1952). Forest inventory. New York: Ronald Press, 476 p.</p> <p>STOATE, I. N. (1945). The use of a volume equation in pine stands. Australian Forestry, Canberra, 9, 48\u201352.</p>"},{"location":"pt-BR/","title":"ForestPyTools","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>\ud83d\udcc4 Licen\u00e7a</p> <p>Esta biblioteca est\u00e1 licenciada sob a Creative Commons BY-NC 4.0.</p> <p>\u2714\ufe0f Uso pessoal e educacional permitido \u274c Uso comercial \u00e9 proibido sem autoriza\u00e7\u00e3o expressa do autor.</p> <p>Autor: Vinicius Richter</p> <p></p>"},{"location":"pt-BR/#forestpytools_1","title":"\ud83c\udf32 ForestPyToolsFuncionalidades do FP Tools","text":"<p>ForestPyTools \u00e9 uma biblioteca Python desenvolvida para facilitar o gerenciamento da mensura\u00e7\u00e3o de florestas plantadas. Com foco em aplica\u00e7\u00f5es pr\u00e1ticas, a biblioteca oferece ferramentas simples, acess\u00edveis e integr\u00e1veis a fluxos de trabalho cient\u00edficos e operacionais na \u00e1rea florestal.</p> <p>Processe o manejo florestal de ponta a ponta, da forma mais simples poss\u00edvel.</p> <p>Com esta biblioteca, voc\u00ea poder\u00e1 planejar invent\u00e1rios florestais e volumetria, al\u00e9m de processar todos os dados provenientes da sua planta\u00e7\u00e3o florestal. O FP Tools re\u00fane diversas metodologias de processamento florestal em uma \u00fanica biblioteca, proporcionando facilidade na sele\u00e7\u00e3o de modelos e an\u00e1lise do desempenho florestal.</p> <p>Esta biblioteca foi criada como parte de um projeto de mestrado do estudante Vinicius Richter, com o objetivo de facilitar o processamento de informa\u00e7\u00f5es de invent\u00e1rio florestal e estreitar a conex\u00e3o entre profissionais de TI e engenheiros florestais.</p> <p></p>"},{"location":"pt-BR/#primeiros-passos","title":"Primeiros Passos","text":"<p>Aprenda a dar os primeiros passos no uso da biblioteca, desde a instala\u00e7\u00e3o at\u00e9 o aproveitamento do processamento florestal de forma \u00e1gil.</p>"},{"location":"pt-BR/#planejamento-de-inventario-florestal-alocacao-de-parcelas-no-qgis","title":"Planejamento de Invent\u00e1rio Florestal (aloca\u00e7\u00e3o de parcelas no QGIS)","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 planejar invent\u00e1rios florestais alocando parcelas com nosso plugin para QGIS.</p>"},{"location":"pt-BR/#planejamento-de-inventario-florestal","title":"Planejamento de Invent\u00e1rio Florestal","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 planejar invent\u00e1rios florestais alocando parcelas.</p>"},{"location":"pt-BR/#relacao-hipsometrica","title":"Rela\u00e7\u00e3o Hipsom\u00e9trica","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 realizar a rela\u00e7\u00e3o hipsom\u00e9trica de um invent\u00e1rio florestal utilizando diversas equa\u00e7\u00f5es, bem como fazer uso de redes neurais artificiais.</p>"},{"location":"pt-BR/#planejamento-de-cubagem","title":"Planejamento de Cubagem","text":"<p>Neste m\u00f3dulo, voc\u00ea ser\u00e1 capaz de planejar medi\u00e7\u00f5es de volume de \u00e1rvores como parte de invent\u00e1rios florestais, selecionando ferramentas para estimar o volume de \u00e1rvores e povoamentos.</p>"},{"location":"pt-BR/#volumetria","title":"Volumetria","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 processar dados de volume das \u00e1rvores e ajustar fun\u00e7\u00f5es volum\u00e9tricas e de afilamento.</p>"},{"location":"pt-BR/#estatistica-amostral","title":"Estat\u00edstica Amostral","text":"<p>Este m\u00f3dulo permite calcular par\u00e2metros de amostragem simples e estratificada com base nos volumes das unidades amostrais.</p>"},{"location":"pt-BR/#sortimentos","title":"Sortimentos","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 gerar relat\u00f3rios sobre o volume total e os sortimentos produzidos pela floresta.</p>"},{"location":"pt-BR/#relatorio-florestal","title":"Relat\u00f3rio Florestal","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 gerar um relat\u00f3rio florestal em diferentes n\u00edveis, com base no processamento pr\u00e9vio realizado.</p>"},{"location":"pt-BR/#previsao-clutter","title":"Previs\u00e3o Clutter","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 estimar a produ\u00e7\u00e3o futura da floresta utilizando o modelo de Clutter.</p>"},{"location":"pt-BR/#previsao-ann","title":"Previs\u00e3o ANN","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 estimar a produ\u00e7\u00e3o futura da floresta utilizando redes neurais artificiais.</p>"},{"location":"pt-BR/#estratificador","title":"Estratificador","text":"<p>Neste m\u00f3dulo, voc\u00ea poder\u00e1 usar dados de invent\u00e1rios para encontrar a estratifica\u00e7\u00e3o ideal para seu plantio.</p>"},{"location":"pt-BR/#utils","title":"Utils","text":"<p>M\u00f3dulo extra com fun\u00e7\u00f5es complementares.</p>"},{"location":"pt-BR/about_the_author/","title":"Sobre o autor","text":"Richter V. Bacharel em Engenharia Florestal e atualmente cursando Mestrado em Engenharia Florestal com especializa\u00e7\u00e3o em crescimento e produ\u00e7\u00e3o florestal na Universidade Federal de Santa Maria. Atua nas \u00e1reas de intelig\u00eancia artificial, vis\u00e3o computacional, programa\u00e7\u00e3o em Python, invent\u00e1rio florestal, sensoriamento remoto e manejo florestal.  <p>    Ver portf\u00f3lio </p>"},{"location":"pt-BR/ann_forecast/","title":"Prognose com RNA","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Utilize bancos de dados de invent\u00e1rio florestal cont\u00ednuo para prever o crescimento e a produ\u00e7\u00e3o florestal. Utilize redes neurais artificiais para maior flexibilidade. Com este m\u00f3dulo, voc\u00ea poder\u00e1 estimar volume, n\u00famero de fustes, \u00e1rea basal, entre outras vari\u00e1veis de interesse.</p>"},{"location":"pt-BR/ann_forecast/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":""},{"location":"pt-BR/ann_forecast/#anntrainer","title":"AnnTrainer","text":"<pre><code>AnnTrainer(df, y, *train_columns, iterator=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados processados do invent\u00e1rio florestal cont\u00ednuo. y A vari\u00e1vel alvo para treinamento da RNA (Y), a vari\u00e1vel na qual a RNA ser\u00e1 treinada para prever. *train_columns (<code>*args</code>) Nomes das colunas que ser\u00e3o usadas para treinar a rede neural artificial para que ela possa prever os valores de Y. Devem ser num\u00e9ricas. iterator (Opcional) Nome da coluna que cont\u00e9m o <code>iterator</code>. Uma rede neural artificial ser\u00e1 ajustada para cada <code>iterator</code>."},{"location":"pt-BR/ann_forecast/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>fun\u00e7\u00f5es e par\u00e2metros<pre><code>  AnnTrainer.fit_model(save_dir=None)#(1)!\n</code></pre></p> <ol> <li>save_dir = Diret\u00f3rio onde o arquivo <code>.pkl</code> da RNA ser\u00e1 salvo.</li> </ol> M\u00e9todos Descri\u00e7\u00e3o .fit_model() Ajusta o modelo usando <code>*train_columns</code> para prever a vari\u00e1vel Y."},{"location":"pt-BR/ann_forecast/#estruturas-da-rna","title":"Estruturas da RNA","text":"<p>Ser\u00e3o testadas 6 diferentes estruturas de redes neurais artificiais. Apenas o resultado de 1 modelo ser\u00e1 retornado. O modelo retornado ser\u00e1 selecionado pela fun\u00e7\u00e3o de ranqueamento. Para o modelo 'ann', o m\u00f3dulo sklearn.neural_network.MLPRegressor \u00e9 utilizado.  --- title: Par\u00e2metros da RNA --- classDiagram     direction LR      class MLPRegressor {       \u00c9pocas: 3000       Ativa\u00e7\u00e3o: log\u00edstico       Modo Solver: lbfgs       Tamanho do lote: din\u00e2mico       Taxa de aprendizado inicial: 0.1       Modo de taxa de aprendizado: adaptativo     }      class Modelo-0 {       Tamanhos da camada oculta: (15, 25, 20, 30, 10)     }     class Modelo-1 {       Tamanhos da camada oculta: (35, 10, 25, 35, 15)     }     class Modelo-2 {       Tamanhos da camada oculta: (25, 15, 30, 20)     }     class Modelo-3 {       Tamanhos da camada oculta: (15, 35, 45)     }     class Modelo-4 {       Tamanhos da camada oculta: (35, 10, 25, 35, 15)     }     class Modelo-5 {        Tamanhos da camada oculta: (35, 10, 25, 35, 15, 20, 15, 30)     }      MLPRegressor &lt;|-- Modelo-0     MLPRegressor &lt;|-- Modelo-1     MLPRegressor &lt;|-- Modelo-2     MLPRegressor &lt;|-- Modelo-3     MLPRegressor &lt;|-- Modelo-4     MLPRegressor &lt;|-- Modelo-5</p>"},{"location":"pt-BR/ann_forecast/#annpredictor","title":"AnnPredictor","text":"<pre><code>AnnPredictor(pkl_file)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o pkl_file Diret\u00f3rio do arquivo <code>.pkl</code> que ser\u00e1 utilizado para previs\u00e3o."},{"location":"pt-BR/ann_forecast/#metodos-da-classe_1","title":"M\u00e9todos da Classe","text":"<p>fun\u00e7\u00f5es e par\u00e2metros<pre><code>  AnnPredictor.predict(df, *args)#(1)!\n</code></pre></p> <ol> <li>Retorna a previs\u00e3o de <code>Y</code> para as colunas <code>*args</code>. As colunas <code>*args</code> devem ser as mesmas utilizadas em <code>*train_columns</code> para o treinamento.  </li> </ol>"},{"location":"pt-BR/ann_forecast/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>A grande vantagem do uso de redes neurais artificiais na estimativa de vari\u00e1veis florestais est\u00e1 na possibilidade de incluir um grande n\u00famero de vari\u00e1veis na previs\u00e3o. No entanto, atualmente, as redes neurais deste m\u00f3dulo operam preferencialmente com vari\u00e1veis cont\u00ednuas. Por isso, ao se desejar utilizar vari\u00e1veis categ\u00f3ricas, recomenda-se aplicar algum tipo de transforma\u00e7\u00e3o, como o one-hot encoding, para convert\u00ea-las em formato num\u00e9rico antes de inseri-las na rede.</p> <p>Como exemplo, iremos usar uma adapta\u00e7\u00e3o dos dados obtidos por Arce e Dobner Jr. (2024) para Eucalyptus dunnii. A base de dados \u00e9 composta por 81 parcelas permanentes, com idades variando entre 3 e 9 anos, medidas de forma cont\u00ednua ao longo do tempo.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Chave_Parcela Area_m2 Idade N_ha d m\u00e9dio h m\u00e9dio H dom G_m2_ha V_m3_ha S 14401109002_P1 300 3 933 7,47 6,8 7,4 4,2 6,0 15,4 14401109002_P1 300 4 933 10,3 10,1 10,8 8,0 24,5 15,4 14401109002_P1 300 5 933 14,0 12,8 13,7 14,9 67,1 15,4 14401109002_P1 300 6 933 14,1 14,5 15,4 15,1 77,2 15,4 14401109002_P1 300 7 867 16,6 16,1 16,5 19,4 112,8 15,4 <p>Nesse caso, iremos utilizar as colunas \"Idade\", \"N_ha\", \"d m\u00e9dio\", \"h m\u00e9dio\", \"H dom\", \"G_m2_ha\" e \"S\" para prever o valor de \"V_m3_ha\".</p> <p>exemplo_previsao_rna.py<pre><code>from fptools.forecast import AnnTrainer, AnnPredictor#(1)!\n\nimport pandas as pd#(2)!\n\nfrom sklearn.model_selection import train_test_split#(3)!\n</code></pre></p> <ol> <li>Importa a classe <code>AnnTrainer</code> e <code>AnnPredictor</code> do m\u00f3dulo <code>forecast</code>.</li> <li>Importa <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> <li>Importa <code>train_test_split</code> para dividir dados em treino e valida\u00e7\u00e3o.</li> </ol> <p>exemplo_previsao_rna.py<pre><code>path = r\"Seu/diret\u00f3rio/para/dados_ann.xlsx\"#(1)!\ndados = pd.read_excel(path)#(2)!\n\ndados_treino, dados_validacao = train_test_split(dados,\n                                                test_size=0.2,\n                                                random_state=42)#(3)!\n\ntrain_columns = [\"Idade\",\n                 \"N_ha\",\n                 \"d m\u00e9dio\",\n                 \"h m\u00e9dio\",\n                 \"H dom\",\n                 \"G_m2_ha\",\n                 \"S\"]#(4)!\n\nann = AnnTrainer(dados_treino, \"V_m3_ha\", *train_columns)#(5)!        \n\nmetrics = ann.fit_model(r\"Seu/diretorio/para/salvar\")#(6)!  \n</code></pre></p> <ol> <li>Define o diret\u00f3rio onde est\u00e3o os dados em formato <code>xlsx</code> salvando na vari\u00e1vel <code>path</code>.</li> <li>Carrega os dados e salva na vari\u00e1vel <code>dados</code>.</li> <li>Salva 80% dos dados como dados de treino na vari\u00e1vel <code>dados_treino</code> e 20% dos dados como valida\u00e7\u00e3o na vari\u00e1vel <code>dados_validacao</code>, mantendo uma seed de aleatoriedade igual a 42.</li> <li>Cria uma vari\u00e1vel chamada <code>train_columns</code> contendo a lista de nomes de colunas que ser\u00e3o usadas para treino.</li> <li>Instancia a classe <code>AnnTrainer</code> salvando na vari\u00e1vel <code>ann</code>, passando os dados de treino, a coluna <code>V_m3_ha</code> como vari\u00e1vel a ser predita e a lista de colunas de trei</li> <li>Ajusta o modelo de rna, salvando as m\u00e9tricas na vari\u00e1vel <code>metircs</code> e o arquivo <code>.pkl</code> gerado no diretorio definido.</li> </ol> <p>Ap\u00f3s isso, o modelo ajustado estara pronto para uso. Podemos testar a performance do nosso modelo utilizando ele para prever os dados de valida\u00e7\u00e3o salvos em <code>dados_validacao</code>.</p> <p>exemplo_previsao_rna.py<pre><code>from fptools.utils import get_metrics #(1)!\n\npredictor = AnnPredictor(\n                        r\"Seu/diretorio/para/salvar/V_m3_ha_ann_predictor.pkl\"\n                        )#(2)!\n\ndados_validacao['V_m3_ha_predicted'] = predictor.predict(\n                                                         dados_validacao,\n                                                        *train_columns\n                                                        )#(3)!\n\nmae, mape, mse, rmse, r_squared, exp_var, m_error = get_metrics(\n                                                                dados_validacao['V_m3_ha'],\n                                                                dados_validacao['V_m3_ha_predicted']\n                                                                )#(4)!\nmetrics_val = pd.DataFrame({\n    'MAE': [mae],\n    'MAPE': [mape],\n    'MSE': [mse],\n    'RMSE': [rmse],\n    'R squared': [r_squared],\n    'Explained Var': [exp_var],\n    'Mean Error': [m_error]\n})#(5)!\n</code></pre></p> <ol> <li>Importa a fun\u00e7\u00e3o <code>get_metrics</code> do m\u00f3dulo <code>utils</code> para posterior c\u00e1lculo de m\u00e9tricas.</li> <li>Instancia a classe <code>AnnPredictor</code>, salvando na vari\u00e1vel <code>predictor</code> e passando o arquivo <code>.pkl</code> gerado no ajuste da rna.</li> <li>Cria a coluna <code>V_m3_ha_predicted</code> no DataFrame <code>dados_validacao</code>, contendo a predi\u00e7\u00e3o feita pela ann treinada para as colunas usadas no treinamento do dataframe <code>dados_validacao</code>.</li> <li>Usa a fun\u00e7\u00e3o <code>get_metrics</code> para obter as m\u00e9tricas entre os valores reais <code>V_m3_ha</code> e os valores preditos <code>V_m3_ha_predicted</code> do DataFrame <code>dados_validacao</code>. As m\u00e9tricas retornadas s\u00e3o:  MAE (Mean Absolute Error), MAPE (Mean Absolute Percentage Error), MSE (Mean Squared Error), RMSE (Root Mean Squared Error), R\u00b2 (Coeficiente de Determina\u00e7\u00e3o), EXP_VAR (Explained Variance Score) e ME (Mean Error).   </li> <li>Cria um DataFrame com as m\u00e9tricas de valida\u00e7\u00e3o.</li> </ol>"},{"location":"pt-BR/ann_forecast/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/ann_forecast/#tabelas","title":"Tabelas","text":"<p><code>metrics</code>(1)</p> <ol> <li>Tabela com as m\u00e9tricas de performance da RNA no treinamento.</li> </ol> Iterator Model MSE RMSE MAE MAPE R\u00b2 Explained Variance Max Error Not used V_m3_ha_ann_predictor 32,29 5,68 3,05 4,23 0,99 0,99 0,14 <p><code>metrics_val</code>(1)</p> <ol> <li>Tabela com as m\u00e9tricas de performance da RNA na valida\u00e7\u00e3o.</li> </ol> MAE MAPE MSE RMSE R\u00b2 Explained Variance Mean Error 2,99 3,28 26,13 5,11 0,99 0,99 0,12"},{"location":"pt-BR/ann_forecast/#arquivos","title":"Arquivos","text":"<p><code>V_m3_ha_ann_predictor.pkl</code>(1)</p> <ol> <li>Arquivo <code>.pkl</code> contendo os par\u00e2metros da RNA treinada.</li> </ol> <p> Fazer download do arquivo. </p>"},{"location":"pt-BR/ann_forecast/#referencias","title":"Refer\u00eancias","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"pt-BR/assortments/","title":"Sortimentos","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Obtenha os produtos gerados pelo invent\u00e1rio florestal com base em uma tabela de produtos. Use fun\u00e7\u00f5es de afilamente e redes neurais artificiais para estimar o volume comercial e n\u00e3o comercial gerado pela floresta. Estime volumes usando equa\u00e7\u00f5es volum\u00e9tricas ajustadas.</p>"},{"location":"pt-BR/assortments/#parametros-de-classe","title":"Par\u00e2metros de classe","text":"<pre><code>Assortments(df, assortments_priority=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados dos sortimentos. assortments_priority (Opcional) O nome da coluna que define a prioridade dos sortimentos. Se <code>None</code>, usa a ordem padr\u00e3o do dataframe."},{"location":"pt-BR/assortments/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p><pre><code>Assortments.get_assortments(model, model_path, trees_df, tree_dbh, tree_height,\n                            stump=0.1, initial_height=None)#(1)!\n\nAssortments.get_taper_volumes(model, model_path, trees_df, tree_dbh,\n                              tree_height, bark_factor=None, stump=0.1)#(2)!\n\nAssortments.get_volumes(model, model_path, trees_df, tree_dbh,\n                        tree_height, bark_factor=None)#(3)!\n</code></pre></p> <ol> <li> <p>model = O nome da fun\u00e7\u00e3o de afilamento ou 'ann' a ser usada para calcular os sortimentos. model_path = Caminho para o arquivo <code>.json</code> contendo os coeficientes dos modelos ajustados ou o arquivo <code>.pkl</code> contendo a rede neural artificial ajustada. trees_df = DataFrame do Pandas contendo o invent\u00e1rio para o qual os sortimentos devem ser calculados. tree_dbh = Nome da coluna contendo os valores do di\u00e2metro \u00e0 altura do peito (DAP) em cent\u00edmetros. tree_height = Nome da coluna contendo os valores da altura total das \u00e1rvores em metros. stump = (Opcional) Altura do toco (metros) a ser considerada no c\u00e1lculo do sortimento. Se <code>stump==None</code>, o padr\u00e3o \u00e9 <code>0.1</code>. initial_height = (Opcional) Altura (metros) a partir da qual os produtos come\u00e7am a ser gerados. \u00datil para casos em que a base da \u00e1rvore foi danificada por inc\u00eandio ou utilizada para extra\u00e7\u00e3o de resina.</p> </li> <li> <p>model = O nome da fun\u00e7\u00e3o de afilamento ou 'ann' a ser usada para calcular o volume. model_path = Caminho para o arquivo <code>.json</code> contendo os coeficientes dos modelos ajustados ou o arquivo <code>.pkl</code> contendo a rede neural artificial ajustada. trees_df = DataFrame do Pandas contendo o invent\u00e1rio para o qual os volumes devem ser calculados. tree_dbh = Nome da coluna contendo os valores do di\u00e2metro \u00e0 altura do peito (DAP) em cent\u00edmetros. tree_height = Nome da coluna contendo os valores da altura total das \u00e1rvores em metros. bark_factor = (Opcional) Valor do fator de casca a ser utilizado para calcular volumes sem casca. stump = (Opcional) Altura do toco (metros) a ser considerada no c\u00e1lculo dos volumes. Se <code>stump==None</code>, o padr\u00e3o \u00e9 <code>0.1</code>.  </p> </li> <li> <p>model = O nome da fun\u00e7\u00e3o volum\u00e9trica ou 'ann' volum\u00e9trica a ser usada para calcular o volume. model_path = Caminho para o arquivo <code>.json</code> contendo os coeficientes dos modelos ajustados ou o arquivo <code>.pkl</code> contendo a rede neural artificial ajustada. trees_df = DataFrame do Pandas contendo o invent\u00e1rio para o qual os volumes devem ser calculados. tree_dbh = Nome da coluna contendo os valores do di\u00e2metro \u00e0 altura do peito (DAP) em cent\u00edmetros. tree_height = Nome da coluna contendo os valores da altura total das \u00e1rvores em metros. bark_factor = (Opcional) Valor do fator de casca a ser utilizado para calcular volumes sem casca.  </p> </li> </ol> M\u00e9todos Descri\u00e7\u00e3o .get_assortments() Retorna o DataFrame <code>trees_df</code> com colunas adicionais indicando a quantidade de produtos gerados para cada sortimento, bem como o volume gerado para cada sortimento em cada \u00e1rvore. Calcula tamb\u00e9m o volume comercial, o volume total da \u00e1rvore e o volume desperdi\u00e7ado. .get_taper_volumes() Retorna o <code>trees_df</code> com os volumes calculados com base na integra\u00e7\u00e3o das fun\u00e7\u00f5es de afilamento. Calcula o volume total com casca e sem casca. .get_volumes() Retorna o <code>trees_df</code> com os volumes calculados com base nas fun\u00e7\u00f5es volum\u00e9tricas ajustadas. Calcula o volume total com casca e sem casca."},{"location":"pt-BR/assortments/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considere uma base de dados de invent\u00e1rio composta por 50 \u00e1rvores do g\u00eanero Eucalyptus, nas quais os di\u00e2metros a altura do peito (DAP) e altura total foram mensurados.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Fazenda \u00c1rvore DAP (cm) HT (m) Fazenda 1 1 24,8 28,0 Fazenda 1 2 21,2 27,1 Fazenda 1 3 26,8 37,8 Fazenda 1 4 37,6 43,0 Fazenda 1 5 35,7 42,8 <p>Para o funcionamento desse m\u00f3dulo, \u00e9 necess\u00e1rio especificar um DataFrame contendo a descri\u00e7\u00e3o dos produtos que se deseja extrair de cada \u00e1rvore. Essa tabela deve incluir, para cada produto, as seguintes informa\u00e7\u00f5es: nome do produto, comprimento m\u00ednimo e m\u00e1ximo, di\u00e2metro m\u00ednimo, perda associada ao corte (gerada pela serra do equipamento) e, opcionalmente, uma coluna definindo a prioridade de extra\u00e7\u00e3o de cada produto.</p>"},{"location":"pt-BR/assortments/#exemplo-de-tabela-de-sortimentos","title":"Exemplo de tabela de sortimentos","text":"<p> Fazer download do arquivo. </p> Product Length min (m) Length max (m) D min (cm) Loss (cm) Priority Prod. 1 4,5 5 15 0,5 1 Prod. 2 2 2 8 0,5 2 Prod. 3 1 1 3 0,5 3 <p>A ordem das colunas deve ser seguida.</p> <p>taper_functions_example.py<pre><code>from fptools.assortments import Assortments#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>Assortments</code>.</li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>Para esse exemplo, vamos utilizar as equa\u00e7\u00f5es ajustadas para o iterator \"Fazenda 1\". Desse modo, vamos filtrar os dados para calcular produtos somente para as \u00e1rvores da \"Fazenda 1\". Utilizaremos os arquivos gerados pelo m\u00f3dulo Volumetrics</p> <p> Baixar o arquivo taper_functions_coefficients_Fazenda 1.json. </p> <p> Baixar o arquivo volumetrics_functions_coefficients_Fazenda 1.json. </p> <p>taper_functions_example.py<pre><code>assortments_df = pd.read_excel(r'C:\\Seu\\diretorio\\sortimentos.xlsx')#(1)!\n\ninventory_df = pd.read_excel(r'C:\\Seu\\diretorio\\dados_inventario.xlsx')#(2)!\n\ninventory_df = inventory_df[inventory_df['Fazenda'] == \"Fazenda 1\"]#(3)!\n\nProd = Assortments(assortments_df)#(4)!\n\nassortments = Prod.get_assortments('kozak',\n                                   r\"D:\\Your\\path\\for\\taper_functions_coefficients_Fazenda 1.json\",\n                                   inventory_df, \"DAP\", \"HT\")#(5)!\n\ntaper_volumes = Prod.get_taper_volumes('bi',\n                                       r\"D:\\diretorio\\para\\taper_functions_coefficients_Fazenda 1.json\",\n                                       inventario, \"DAP\", \"HT\", .9)#(6)!  \n\nvolumes = Prod.get_volumes('meyer', \n                           r\"D:\\diretorio\\para\\volumetrics_functions_coefficients_Fazenda 1.json\",\n                           inventario, \"DAP\", \"HT\", .85)#(7)!\n</code></pre></p> <ol> <li>Carrega o DataFrame <code>assortments_df</code> a partir de um arquivo <code>xlsx</code>.</li> <li>Carrega o DataFrame <code>inventory_df</code> a partir de um arquivo <code>xlsx</code>.</li> <li>Filtra os dados para obter apenas dados onda a coluna <code>Fazenda</code> \u00e9 igual a <code>Fazenda 1</code>.</li> <li>Cria a vari\u00e1vel <code>Prod</code> contendo a classe <code>Assortments</code> e utilizando o DataFrame <code>assortments_df</code> como produtos.</li> <li>Calcula os sortimentos para cada \u00e1rvore no <code>inventory_df</code> usando o modelo <code>kozak</code>, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores, salvando na vari\u00e1vel <code>assortments</code>.</li> <li>Calcula volumes com integra\u00e7\u00e3o da fun\u00e7\u00e3o <code>bi</code> para cada \u00e1rvore no <code>inventory_df</code> usando o modelo <code>bi</code>, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores. Tamb\u00e9m utiliza um fator de casca de <code>90%</code>.</li> <li>Calcula volumes com fun\u00e7\u00e3o volum\u00e9trica para cada \u00e1rvore no <code>inventory_df</code> usando o modelo <code>meyer</code>, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores. Tamb\u00e9m utiliza um fator de casca de <code>85%</code>.</li> </ol>"},{"location":"pt-BR/assortments/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/assortments/#tabelas","title":"Tabelas","text":"<p><code>assortments</code>(1)</p> <ol> <li>DataFrame inicial com as seguintes colunas adicionadas:     Para cada produto definido na tabela assortments_df, ser\u00e3o criadas duas colunas: uma informando a quantidade de produtos extra\u00eddos por \u00e1rvore e outra indicando o volume total gerado (em metros c\u00fabicos) para aquele produto.     Al\u00e9m disso, o DataFrame contar\u00e1 com as colunas <code>commercial_volume</code>, <code>tree_volume</code> e <code>wasted_volume</code>, que representam, respectivamente, o volume comercial aproveitado, o volume total da \u00e1rvore e o volume de madeira desperdi\u00e7ado.</li> </ol> Fazenda \u00c1rvore DAP HT Prod. 1_quantity Prod. 1_volume Prod. 2_quantity Prod. 2_volume Prod. 3_quantity Prod. 3_volume comercial_volume tree_volume wasted_volume Fazenda 1 1 24,84076433 28 2 0,36529298 5 0,160465831 6 0,022446226 0,548205036 0,548793726 0,00058869 Fazenda 1 2 21,17834395 27,1 1 0,15662905 7 0,205798888 5 0,016228224 0,378656162 0,379971069 0,001314907 Fazenda 1 3 26,81528662 37,8 4 0,738422477 5 0,129884459 5 0,016047425 0,884354362 0,88558894 0,001234578 Fazenda 1 4 37,57961783 43 6 1,899253966 3 0,090801352 5 0,021413892 2,01146921 2,01247906 0,00100985 Fazenda 1 5 35,66878981 42,8 6 1,705021305 3 0,07966354 5 0,018106349 1,802791194 1,803503982 0,000712789 <p><code>taper_volumes</code>(1)</p> <ol> <li>DataFrame inicial com as seguintes colunas adicionadas: <code>Tree_volume</code>: Volume total da \u00e1rvore calculado pela integra\u00e7\u00e3o da fun\u00e7\u00e3o de afilamento informada.     <code>Tree_volume_without_bark</code>: <code>Tree_volume</code> multiplicado pelo fator de c\u00e1sca informado.</li> </ol> Fazenda \u00c1rvore DAP HT Tree_volume Tree_volume_without_bark Fazenda 1 1 24,84076433 28 0,545157869 0,490642083 Fazenda 1 2 21,17834395 27,1 0,38299769 0,344697921 Fazenda 1 3 26,81528662 37,8 0,870697291 0,783627562 Fazenda 1 4 37,57961783 43 2,005436616 1,804892954 Fazenda 1 5 35,66878981 42,8 1,790646854 1,611582169 <p><code>volumes</code>(1)</p> <ol> <li>DataFrame inicial com as seguintes colunas adicionadas: <code>Tree_volume</code>: Volume total da \u00e1rvore calculado pela equa\u00e7\u00e3o volum\u00e9trica informada.     <code>Tree_volume_without_bark</code>: <code>Tree_volume</code> multiplicado pelo fator de c\u00e1sca informado.</li> </ol> Fazenda \u00c1rvore DAP HT Tree_volume Tree_volume_without_bark Fazenda 1 1 24,84076433 28 0,550907023 0,468270969 Fazenda 1 2 21,17834395 27,1 0,380017894 0,32301521 Fazenda 1 3 26,81528662 37,8 0,902103615 0,766788073 Fazenda 1 4 37,57961783 43 2,036722755 1,731214342 Fazenda 1 5 35,66878981 42,8 1,825198637 1,551418842 <p>Caso o usu\u00e1rio deseje utilizar um dos modelos de rede neural treinados para cada fun\u00e7\u00e3o, basta substituir o nome do modelo por <code>ann</code> e especificar o diret\u00f3rio do arquivo <code>.pkl</code> contendo os par\u00e2metros da rede neural ajustada.</p> <p> Baixar o arquivo taper_model_ann_Fazenda 1.pkl. </p> <p> Baixar o arquivo volumetric_ann_Fazenda 1.pkl. </p> <p>taper_functions_example.py<pre><code>assortments = Prod.get_assortments('ann',\n                                   r\"D:\\Your\\path\\for\\taper_model_ann_Fazenda 1.pkl\",\n                                   inventory_df, \"DAP\", \"HT\")#(1)!\n\ntaper_volumes = Prod.get_taper_volumes('ann',\n                                       r\"D:\\diretorio\\para\\taper_model_ann_Fazenda 1.pkl\",\n                                       inventario, \"DAP\", \"HT\", .9)#(2)!  \n\nvolumes = Prod.get_volumes('ann', \n                           r\"D:\\Your\\path\\for\\volumetric_ann_Fazenda 1.pkl\",\n                           inventario, \"DAP\", \"HT\", .85)#(3)!\n</code></pre></p> <ol> <li>Calcula os sortimentos para cada \u00e1rvore no <code>inventory_df</code> usando o redes neurais artificiais, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores, salvando na vari\u00e1vel <code>assortments</code>.</li> <li>Calcula volumes com integra\u00e7\u00e3o da rede neural artificial para cada \u00e1rvore no <code>inventory_df</code>, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores. Tamb\u00e9m utiliza um fator de casca de <code>90%</code>.</li> <li>Calcula volumes com rede neural artificial volum\u00e9trica para cada \u00e1rvore no <code>inventory_df</code>, a coluna <code>DAP</code> para valores de DAP e a coluna <code>HT</code> para valores de altura das \u00e1rvores. Tamb\u00e9m utiliza um fator de casca de <code>85%</code>.</li> </ol>"},{"location":"pt-BR/bug_report/","title":"Reportar falhas","text":"<p>Se voc\u00ea encontrou algum problema ou deseja sugerir uma melhoria, sinta-se \u00e0 vontade para acessar o formul\u00e1rio de relat\u00f3rio de bugs. Seu feedback nos ajuda a melhorar a ferramenta.</p>"},{"location":"pt-BR/clutter_forecast/","title":"Modelo de Clutter","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Use bancos de dados de invent\u00e1rio florestal cont\u00ednuo para prever o crescimento e a produ\u00e7\u00e3o da floresta. Utilize o m\u00e9todo tradicional do modelo de Clutter. Com este m\u00f3dulo, voc\u00ea poder\u00e1 estimar o volume e a \u00e1rea basal.</p>"},{"location":"pt-BR/clutter_forecast/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":""},{"location":"pt-BR/clutter_forecast/#cluttertrainer","title":"ClutterTrainer","text":"<pre><code>ClutterTrainer(df, age1, age2, ba1, ba2, site, vol, iterator=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados processados do invent\u00e1rio florestal cont\u00ednuo. age1 Nome da coluna contendo a idade da parcela amostrada anteriormente. age2 Nome da coluna contendo a idade da parcela amostrada posteriormente. ba1 Nome da coluna contendo a \u00e1rea basal da parcela amostrada anteriormente. ba2 Nome da coluna contendo a \u00e1rea basal da parcela amostrada posteriormente. site Nome da coluna contendo o \u00edndice de s\u00edtio do povoamento. vol Nome da coluna contendo o volume da parcela amostrada posteriormente. iterator (Opcional) Nome de um iterador que ser\u00e1 usado para agrupar os dados. Exemplo de um iterador: Material gen\u00e9tico, Estrato."},{"location":"pt-BR/clutter_forecast/#exemplo-de-entrada-para-o-modelo-de-clutter","title":"Exemplo de entrada para o modelo de Clutter","text":"Iterador Parcela age1 age2 ba1 ba2 site vol GM 1 1 2.5 3.5 7.57 8.42 7.83 44.04 GM 1 1 3.5 4.5 8.42 14 8.73 51.42 GM 1 2 2.1 3.1 4.94 5.51 6.98 38.06 GM 1 2 3.1 4.33 5.51 6.45 7.45 39.26 GM 2 1 2 3 7.3 8.25 11.37 74.63 GM 2 1 3 4 8.25 9.13 11.69 68.27 GM 2 1 4 5 9.13 12.79 12.83 72.76 GM 2 1 5 6 12.79 15.63 14 73.87"},{"location":"pt-BR/clutter_forecast/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>functions and parameters<pre><code>  ClutterTrainer.fit_model(save_dir=None)#(1)!\n</code></pre></p> <ol> <li>save_dir = Diret\u00f3rio onde os coeficientes e par\u00e2metros dos modelos treinados ser\u00e3o salvos.</li> </ol> M\u00e9todos Descri\u00e7\u00e3o .fit_model() Ajusta os modelos para prever a \u00e1rea basal e o volume."},{"location":"pt-BR/clutter_forecast/#modelos-de-clutter","title":"Modelos de Clutter","text":""},{"location":"pt-BR/clutter_forecast/#predicao-da-area-basal","title":"<li>Predi\u00e7\u00e3o da \u00e1rea basal</li>","text":"\\[ \\ln G_2 = \\ln G_1 \\left( \\frac{t_1}{t_2} \\right) + \\alpha_0 \\left( 1 - \\frac{t_1}{t_2} \\right) + \\alpha_1 \\left( 1 - \\frac{t_1}{t_2} \\right) S \\]"},{"location":"pt-BR/clutter_forecast/#predicao-do-volume","title":"<li>Predi\u00e7\u00e3o do volume</li>","text":"\\[ \\ln V_2 = \\beta_0 + \\beta_1 \\cdot \\frac{1}{t_2} + \\beta_2 \\cdot S + \\beta_3 \\cdot \\ln G_2 \\]"},{"location":"pt-BR/clutter_forecast/#notacao","title":"Nota\u00e7\u00e3o","text":"<ul> <li>\\( G_1 \\): \u00c1rea basal inicial (na idade \\( t_1 \\)) em m\u00b2\u00b7ha\u207b\u00b9  </li> <li>\\( G_2 \\): \u00c1rea basal final (na idade \\( t_2 \\)) em m\u00b2\u00b7ha\u207b\u00b9  </li> <li>\\( t_1 \\): Idade inicial em meses ou anos  </li> <li>\\( t_2 \\): Idade final em meses ou anos  </li> <li>\\( S \\): \u00cdndice de s\u00edtio, adimensional, \\( f(\\text{idade \u00edndice}, t_i) \\) </li> <li>\\( \\alpha_0, \\alpha_1 \\): Coeficientes a serem ajustados  </li> <li>\\( V_2 \\): Volume final (na idade \\( t_2 \\)) em m\u00b3\u00b7ha\u207b\u00b9  </li> <li>\\( \\beta_i \\): Coeficientes a serem ajustados  </li> </ul>"},{"location":"pt-BR/clutter_forecast/#parametros-da-classe_1","title":"Par\u00e2metros da Classe","text":""},{"location":"pt-BR/clutter_forecast/#clutterpredictor","title":"ClutterPredictor","text":"<pre><code>ClutterPredictor(coefs_file, age1, site, ba1, iterator=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o coefs_file Diret\u00f3rio do arquivo <code>json</code> contendo os coeficientes e par\u00e2metros dos modelos ajustados. age1 Nome da coluna contendo a idade da parcela amostrada anteriormente. ba1 Nome da coluna contendo a \u00e1rea basal da parcela amostrada anteriormente. site Nome da coluna contendo o \u00edndice de s\u00edtio do povoamento. iterator (Opcional) Nome de um iterador que ser\u00e1 usado para previs\u00f5es."},{"location":"pt-BR/clutter_forecast/#metodos-da-classe_1","title":"M\u00e9todos da Classe","text":"M\u00e9todos Descri\u00e7\u00e3o .predict() Faz a predi\u00e7\u00e3o de \u00e1rea basal e volume futuros usando os coeficientes ajustados em <code>ClutterTrainer</code> para uma idade espec\u00edfica. .get_coefs() Mostra quais foram os coeficientes carregados em <code>coefs_file</code>. .predict_range() Faz a predi\u00e7\u00e3o de \u00e1rea basal e volume futuros usando os coeficientes ajustados em <code>ClutterTrainer</code> para um intervalo de idades pr\u00e9 definido. <p>fun\u00e7\u00f5es e par\u00e2metros<pre><code>  ClutterTrainer.get_coefs()#(1)!\n\n  ClutterTrainer.predict(age2)#(2)!\n\n  ClutterTrainer.predict_range(age_range=(2, 10),show_plots=False)#(3)!\n</code></pre></p> <ol> <li>Retorna os coeficientes carregados do <code>coefs_file</code>.  </li> <li>Retorna a previs\u00e3o feita para <code>age2</code>.  </li> <li>Retorna a previs\u00e3o feita para um intervalo de idades especificado em <code>age_range</code> como uma tupla.    Se <code>show_plots=True</code>, exibe os gr\u00e1ficos das previs\u00f5es realizadas.  </li> </ol>"},{"location":"pt-BR/clutter_forecast/#example-usage","title":"Example Usage","text":"<p>Como exemplo, iremos usar uma adapta\u00e7\u00e3o dos dados obtidos por Arce e Dobner Jr. (2024) para Eucalyptus dunnii. A base de dados \u00e9 composta por 81 parcelas permanentes, com idades variando entre 3 e 9 anos, medidas de forma cont\u00ednua ao longo do tempo.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Estrato Parcela I1 I2 G1 G2 IS V2_observ Estrato-2 1220117_P7005 3 4 8,88 11,98 14,42 36,05 Estrato-2 1220117_P7005 4 5 11,98 13,53 14,42 51,90 Estrato-2 1220117_P7005 5 6 13,53 17,24 14,42 81,22 Estrato-2 1220117_P7005 6 7 17,24 22,47 14,42 144,45 Estrato-2 1220117_P7005 7 8 22,47 22,20 14,42 150,15 <p>clutter_forecast_example.py<pre><code>fptools.forecast import ClutterTrainer, ClutterPredictor#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa as classes <code>ClutterTrainer</code> e <code>ClutterPredictor</code> do m\u00f3dulo <code>forecast</code>.</li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>clutter_forecast_example.py<pre><code>df = pd.read_csv(r'C:\\Seu\\Diretorio\\dados_clutter.xlsx')#(1)!\n\nclutter = ClutterTrainer(dados, \"I1\",\"I2\", \"G1\",\"G2\",'IS',\"V2_observ\")#(2)!\n\nmetrics = clutter.fit_model(save_dir = r\"C:\\Seu\\Diretorio\\para\\salvar\")#(3)!\n\npredictor = ClutterPredictor(\"C:\\Seu\\Diretorio\\para\\salvar\\all_coefficients.json\",\n                             7,14.41,17.23)#(4)!\n\nba_vol_predicted = predictor.predict(10)#(5)!\n\ncoef = predictor.get_coefs()#(6)!\n\nba_vol_range_predicted = predictor.predict_range((2,12), show_plots=True)#(7)!\n</code></pre></p> <ol> <li>Carrega seu arquivo com dados de invent\u00e1rio cont\u00ednuo em formato <code>xlsx</code>.  </li> <li>Cria a vari\u00e1vel <code>clutter</code> contendo a classe <code>ClutterTrainer</code>, definindo as respectivas colunas.  </li> <li>Ajusta o modelo de Clutter, salvando os coeficientes e par\u00e2metros na pasta <code>C:\\Seu\\Diretorio\\para\\salvar\\as\\metricas</code> e as m\u00e9tricas do treinamento na vari\u00e1vel <code>metrics</code>.  </li> <li>Cria uma vari\u00e1vel contendo o preditor. Esse preditor usar\u00e1 o modelo salvo <code>C:\\Seu\\Diretorio\\para\\salvar\\all_coefficients.json</code> para aplicar um invent\u00e1rio com idade de <code>7</code> anos, um \u00edndice de s\u00edtio de <code>14,41</code> e uma \u00e1rea basal de <code>17,23</code>, a fim de prever a produ\u00e7\u00e3o futura de volume e \u00e1rea basal.  </li> <li>Faz a previs\u00e3o para esse plantio quando atingir <code>10</code> anos e salva os resultados em <code>ba_vol_predicted</code>.  </li> <li>Obt\u00e9m os coeficientes do modelo e os salva na vari\u00e1vel <code>coef</code>.  </li> <li>Faz a previs\u00e3o para esse plantio de <code>2</code> a <code>12</code> anos, gerando um gr\u00e1fico que mostra a evolu\u00e7\u00e3o da \u00e1rea basal e do volume ao longo desse per\u00edodo, juntamente com o n\u00edvel de confian\u00e7a.  </li> </ol>"},{"location":"pt-BR/clutter_forecast/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/clutter_forecast/#tabelas","title":"Tabelas","text":"<p><code>metrics</code>(1)</p> <ol> <li>Valores das m\u00e9tricas dos ajustes para cada um dos modelos utilizados por iterator (quando utilizado).</li> </ol> Iterator Model mse rmse mae mape r2 explained_variance max_error Not used ln_ba2_est 2,70 1,64 1,32 2,35 0,92 0,94 4,41 Not used ln_vol2_est 280,92 16,76 12,34 2,06 0,94 0,94 76,58 <p><code>ba_vol_predicted</code>(1)</p> <ol> <li>Valor de \u00e1rea basal e volume futuros estimados para idade de 10 anos.</li> </ol> BA2 Volume 17,23 159,03 <p><code>coef</code>(1)</p> <ol> <li>Dicion\u00e1rio com coeficientes para cada modelo e iterator (quanto utilizado).</li> </ol> <pre><code>```json\n{\n  \"lnb2_model\": {\n    \"b0\": 0.03818795042386813,\n    \"b1\": 3.465183897074305,\n    \"b2\": 0.016174627316697623,\n    \"num_rows\": 402,\n    \"min_age\": 3,\n    \"max_age\": 9,\n    \"mape\": 2.3528810455777904,\n    \"r2\": 0.923524025998693\n  },\n  \"lnv2_model\": {\n    \"b0\": 1.3927682912732822,\n    \"b1\": -4.364287014356091,\n    \"b2\": 0.04215217322729903,\n    \"b3\": 1.1299750378626658,\n    \"num_rows\": 402,\n    \"min_age\": 3,\n    \"max_age\": 9,\n    \"mape\": 2.0563064467361003,\n    \"r2\": 0.9414308873440383\n  }\n}\n</code></pre> <p><code>ba_vol_range_predicted</code>(1)</p> <ol> <li>Data frame contendo \u00e1rea basal e volumes futuros para um intervalo de idade pr\u00e9 definido.</li> </ol> Age BA2 Volume BA2_max_error BA2_min_error Volume_max_error Volume_min_error 2,00 2,05 1,88 2,10 2,00 1,91 1,84 2,50 3,72 5,69 3,81 3,63 5,81 5,57 3,00 5,54 11,93 5,67 5,41 12,17 11,68 3,50 7,35 20,24 7,53 7,18 20,65 19,82 4,00 9,10 30,09 9,31 8,88 30,70 29,47 4,50 10,74 40,95 10,99 10,48 41,79 40,11 5,00 12,26 52,41 12,54 11,97 53,49 51,33 5,50 13,66 64,13 13,98 13,34 65,45 62,81 6,00 14,95 75,87 15,30 14,60 77,43 74,31 6,50 16,14 87,48 16,52 15,76 89,28 85,68 7,00 17,23 98,83 17,64 16,82 100,86 96,79 7,50 18,24 109,85 18,67 17,81 112,10 107,59 8,00 19,17 120,49 19,62 18,71 122,97 118,01 8,50 20,02 130,74 20,50 19,55 133,43 128,05 9,00 20,82 140,58 21,31 20,33 143,47 137,69 9,50 21,56 150,00 22,07 21,05 153,09 146,92 10,00 22,25 159,03 22,77 21,72 162,30 155,76 10,50 22,89 167,66 23,42 22,35 171,11 164,21 11,00 23,48 175,91 24,04 22,93 179,53 172,30 11,50 24,04 183,80 24,61 23,48 187,58 180,03 12,00 24,57 191,35 25,15 23,99 195,28 187,41"},{"location":"pt-BR/clutter_forecast/#exemplo-de-grafico-de-saida-da-previsao","title":"Exemplo de Gr\u00e1fico de Sa\u00edda da Previs\u00e3o","text":""},{"location":"pt-BR/clutter_forecast/#referencias","title":"Refer\u00eancias","text":"<p>CLUTTER, J. L.; FORTSON, J. C.; PIENAAR, L. V.; BRISTER, G. H.; BAILEY, R. L. (1983).       Timber management: a quantitative approach. New York: John Wiley &amp; Sons, 333p.</p> <p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"pt-BR/forest_report/","title":"Relat\u00f3rio Florestal","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Gere um relat\u00f3rio florestal com base nas alturas e volumes estimados usando os outros m\u00f3dulos do ForestPyTools. Obtenha valores de volume e tipos de \u00e1rvores por hectare em v\u00e1rios n\u00edveis espec\u00edficos do povoamento florestal, juntamente com outras m\u00e9tricas. Obtenha o relat\u00f3rio nos formatos xlsx (Excel) ou json.</p>"},{"location":"pt-BR/forest_report/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>ForestReport(df, plot_id, plot_size, tree_type, tree_dbh,\n             tree_height, group_levels=None, tree_vol_with_bark=None,\n             tree_vol_without_bark=None, iterator=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados processados do invent\u00e1rio florestal. plot_id Nome da coluna que cont\u00e9m o identificador \u00fanico para cada parcela. plot_size Valor num\u00e9rico indicando o tamanho da parcela em metros quadrados ou o nome da coluna que cont\u00e9m o tamanho de cada parcela em metros quadrados. tree_type Nome da coluna que cont\u00e9m o <code>id</code> dos tipos de \u00e1rvores presentes no invent\u00e1rio florestal. O <code>id</code> deve estar inclu\u00eddo em <code>tree_types_df</code>. tree_dbh Nome da coluna que cont\u00e9m os valores do di\u00e2metro \u00e0 altura do peito (DAP). tree_height Nome da coluna que cont\u00e9m os valores de altura das \u00e1rvores. group_levels (Opcional) Lista com os nomes dos n\u00edveis de agrupamento que o usu\u00e1rio deseja criar. Os grupos devem conter valores \u00fanicos. Um resumo ser\u00e1 gerado para cada grupo. Exemplo de grupos: Fazenda, talh\u00e3o, tipo de solo. tree_vol_with_bark (Opcional) Nome da coluna que cont\u00e9m os valores do volume das \u00e1rvores com casca. tree_vol_without_bark (Opcional) Nome da coluna que cont\u00e9m os valores do volume das \u00e1rvores sem casca."},{"location":"pt-BR/forest_report/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>methods and parameters<pre><code>  ForestReport.update_tree_types(df)#(1)!\n\n  ForestReport.view_tree_types()\n\n  ForestReport.get_report(dir, format=\"xlsx\")#(2)!\n</code></pre></p> <ol> <li>df = DataFrame contendo os tipos de \u00e1rvores presentes no invent\u00e1rio florestal. Se <code>None</code>, o DataFrame padr\u00e3o da biblioteca ser\u00e1 utilizado.</li> <li>dir = Diret\u00f3rio onde o relat\u00f3rio ser\u00e1 salvo. format = Formato em que o relat\u00f3rio ser\u00e1 salvo. Pode ser <code>xlsx</code> (Excel) ou <code>json</code>.  </li> </ol> M\u00e9todos Descri\u00e7\u00e3o .update_tree_types() Atualiza o <code>tree_types_df</code> -&gt; DataFrame que cont\u00e9m os IDs dos tipos de \u00e1rvores, nomes e descri\u00e7\u00e3o. .view_tree_types() Exibe o <code>tree_types_df</code> que a classe est\u00e1 utilizando no momento. .get_report() Salva o relat\u00f3rio florestal no formato <code>xlsx</code> ou <code>json</code> no diret\u00f3rio especificado."},{"location":"pt-BR/forest_report/#exemplo-de-tabela-de-tipos-de-arvores","title":"Exemplo de tabela de tipos de \u00e1rvores","text":"id name description commercial_volume missing_stems 0 normal \u00c1rvore sem distor\u00e7\u00f5es ou defeitos significativos 1 0 1 morta \u00c1rvore morta 0 0 2 bifurcada acima do DAP \u00c1rvore bifurcada acima do DAP 1 0 3 bifurcada abaixo do DAP \u00c1rvore bifurcada abaixo do DAP 1 0 4 queimada \u00c1rvore queimada 0 0 5 Faltante Falha na lniha de plantio 0 1 <p>*A ordem das colunas deve ser seguida.</p> <p>Aten\u00e7\u00e3o</p> <ul> <li> <p>A coluna <code>commercial_volume</code> \u00e9 uma flag bin\u00e1ria que indica se o tipo de \u00e1rvore representado pelo <code>id</code> deve ser considerado no c\u00e1lculo de volume comercial. Um valor igual a <code>1</code> significa que a \u00e1rvore contribui para o volume \u00fatil; <code>0</code> indica exclus\u00e3o desse c\u00e1lculo.</p> </li> <li> <p>A coluna <code>missing_stems</code> tamb\u00e9m \u00e9 uma flag bin\u00e1ria, utilizada para identificar aus\u00eancia de \u00e1rvores no local previsto de plantio. Diferentemente de \u00e1rvores mortas, esses casos representam falhas no espa\u00e7amento, como resultado de mortalidade seguida de queda, desbaste ou aus\u00eancia de plantio.</p> </li> </ul>"},{"location":"pt-BR/forest_report/#descricao-das-colunas","title":"Descri\u00e7\u00e3o das Colunas","text":"<ul> <li> <p><code>id</code>: Representa um identificador \u00fanico para cada tipo de \u00e1rvore na classifica\u00e7\u00e3o. Ele \u00e9 usado para diferenciar os registros e pode servir como chave de refer\u00eancia em outros conjuntos de dados.</p> </li> <li> <p><code>name</code>: Indica o nome da \u00e1rvore com base em sua condi\u00e7\u00e3o ou caracter\u00edsticas espec\u00edficas. Esse nome funciona como uma descri\u00e7\u00e3o curta para f\u00e1cil identifica\u00e7\u00e3o.</p> </li> <li> <p><code>description</code>: Fornece uma explica\u00e7\u00e3o detalhada sobre a condi\u00e7\u00e3o da \u00e1rvore, incluindo informa\u00e7\u00f5es sobre sua estrutura, estado de sa\u00fade ou poss\u00edveis defeitos que podem afetar sua qualidade comercial.</p> </li> <li> <p><code>commercial_volume</code>: Define se o volume dessa \u00e1rvore ser\u00e1 considerado comercialmente utiliz\u00e1vel. Um valor de <code>1</code> indica que a \u00e1rvore possui volume comercial e ser\u00e1 utilizada, enquanto <code>0</code> significa que seu volume n\u00e3o ser\u00e1 aproveitado.</p> </li> <li> <p><code>missing_stems</code>: Utilizada para identificar aus\u00eancia de \u00e1rvores no local previsto de plantio. Diferentemente de \u00e1rvores mortas, esses casos representam falhas no espa\u00e7amento, como resultado de mortalidade seguida de queda, desbaste ou aus\u00eancia de plantio.</p> </li> </ul>"},{"location":"pt-BR/forest_report/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Para exemplificar como funciona o m\u00f3dulo de relat\u00f3rio florestal iremos utilizar os dados de invent\u00e1rio adaptados de Arce e Dobner Jr.(2024). O invent\u00e1rio foi realizado em 19 diferentes fazendas, com plantios da esp\u00e9cies Eucalyptus dunnii variando entre 8 e 9 anos de idade. No total, 1954 \u00e1rvore foram mensuradas. O volume foi calculado usando um fator de forma de 0,45 e um fator de casca de 0,91. </p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> ID parcela area_parcela Idade ID_Regiao ID Fazenda ID talhao Esp\u00e9cie Coluna \u00c1rvore Fuste Tipo arvore dap (cm) ht ht_calculada (m) Vol (m\u00b3) Vol SC (m\u00b3) 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 4 26 1 2 23,5 18,1 17,57 0,342933476 0,329216137 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 3 21 1 1 20,6 17,4 17,25 0,258717577 0,248368874 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 1 5 1 1 20,3 17,21 0,250654405 0,240628229 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 2 12 1 1 20,3 17,6 17,21 0,250654405 0,240628229 14-401-109002-1 300 8 14 14-401 14-401-109002 Eucalyptus dunnii 2 15 1 1 20 17 17,17 0,242735156 0,23302575 <p>A biblioteca traz por padr\u00e3o um exemplo de DataFrame de tipos de \u00e1rvore a ser utilizado. Por\u00e9m, cada engenheiro florestal ou empresa possui sua propria metodologia e c\u00f3digos para cada tipo de \u00e1rvore. Nesse caso, usamos a codifica\u00e7\u00e3o de tipos de \u00e1rvores definidos por Arce e Dobner Jr.(2024).</p> <p> Fazer download do arquivo. </p> <p>Abaixo podemos visualizar o DataFrame que iremos utilizar.</p> id name description commercial_volume missing_stems 1 Normal \u00c1rvore saud\u00e1vel, sem distor\u00e7\u00f5es significativas ou defeitos vis\u00edveis. 1 0 2 Dominante \u00c1rvore que se destaca em altura e vigor em rela\u00e7\u00e3o \u00e0s vizinhas. 1 0 3 Seco \u00c1rvore morta, sem folhas e sinais de atividade fisiol\u00f3gica. 0 0 4 Quebrado \u00c1rvore com parte do tronco ou copa danificada ou rompida. 0 0 5 Rebrotado \u00c1rvore originada de brota\u00e7\u00f5es ap\u00f3s corte ou dano ao caule principal. 1 0 6 Falta Aus\u00eancia de \u00e1rvore no local previsto da linha de plantio. 0 1 7 Bifurcado \u00c1rvore com divis\u00e3o do tronco principal em dois ou mais ramos principais. 1 0 8 Inclinado \u00c1rvore com crescimento significativamente inclinado em rela\u00e7\u00e3o \u00e0 vertical. 1 0 9 Apice Seco \u00c1rvore com a parte superior (\u00e1pice) seca ou morta. 1 0 10 Fuste Curvo \u00c1rvore com o tronco curvado, sem alinhamento retil\u00edneo. 1 0 11 Suprimido \u00c1rvore suprimida pelo sombreamento ou competi\u00e7\u00e3o com \u00e1rvores vizinhas. 1 0 <p>forest_report_example.py<pre><code>from fptools.forest_report import ForestReport#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>ForestReport</code>.</li> <li>Importa a bilbioteca <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>forest_report_example.py<pre><code>inventory_data = pd.read_excel(\n                              r'C:\\seu\\caminho\\exemplo_forest_report.xlsx'\n                              )#(1)!\n\ntree_df_types = pd.read_excel(r'C:\\seu\\caminho\\tree_types.xlsx')#(2)!\n\nreport = ForestReport(inventory_data, plot_id=\"ID parcela\",\n                      plot_size='area_parcela',tree_type='Tipo arvore',\n                      group_levels=['ID_Regiao','ID Fazenda','ID talhao'],\n                      tree_height=\"ht_calculada (m)\", tree_dbh=\"dap (cm)\",\n                      tree_vol_with_bark=\"Vol (m\u00b3)\",\n                      tree_vol_without_bark=\"Vol SC (m\u00b3)\")#(3)!\n\nreport.view_tree_types()#(4)!\n\nreport.update_tree_types(tree_df_types)#(5)!\n\nreport.get_report(r'C:\\seu\\caminho\\para\\salvar', format=\"xlsx\")#(6)!\n</code></pre></p> <ol> <li>Carrega o DataFrame <code>inventory_data</code> a partir de um arquivo <code>xlsx</code>.</li> <li>Carrega o DataFrame <code>tree_types_df</code> a partir de um arquivo <code>xlsx</code>.</li> <li>Cria a vari\u00e1vel <code>report</code> contendo a classe <code>ForestReport</code> e utilizando o dataframe <code>inventory_data</code>.    Define a coluna <code>ID parcela</code> como respons\u00e1vel por identificar cada parcela.    Define a coluna <code>area_parcela</code> como respons\u00e1vel por fornecer o tamanho da parcela em metros quadrados.    Define a coluna <code>Tipo arvore</code> como respons\u00e1vel por identificar o ID de cada \u00e1rvore presente em <code>tree_types_df</code>.    Define as colunas <code>ID_Regiao</code>, <code>ID Fazenda</code> e <code>ID talhao</code> como subgrupos para os quais os relat\u00f3rios s\u00e3o gerados.    Define a coluna <code>ht_calculada (m)</code> como a coluna contendo as alturas das \u00e1rvores em metros.    Define a coluna <code>dap (cm)</code> como a coluna contendo os di\u00e2metros das \u00e1rvores \u00e0 altura do peito em cent\u00edmetros.    Define a coluna <code>Vol (m\u00b3)</code> como a coluna contendo o volume total das \u00e1rvores com casca.    Define a coluna <code>Vol SC (m\u00b3)</code> como a coluna contendo o volume total das \u00e1rvores sem casca.  </li> <li>Exibe o DataFrame <code>tree_types_df</code> em uso (O DataFrame padr\u00e3o que deve ser modificado).  </li> <li>Atualiza o DataFrame <code>tree_types_df</code> utilizando o dataframe <code>tree_df_types</code>.  </li> <li>Salva o relat\u00f3rio no formato <code>xlsx</code>.  </li> </ol> <p>Aten\u00e7\u00e3o: Identificadores \u00fanicos nos agrupamentos</p> <p>Ao utilizar o par\u00e2metro <code>group_levels</code>, \u00e9 essencial que os grupos definidos contenham combina\u00e7\u00f5es \u00fanicas de valores entre as colunas. Isso evita ambiguidade nos resumos gerados por agrupamento.</p> <p>Por exemplo, ao agrupar por <code>ID_Regiao</code> e <code>ID Fazenda</code>, n\u00e3o use identificadores gen\u00e9ricos como \"A\", \"B\" ou \"C\" se esses forem reutilizados em diferentes regi\u00f5es. Veja os exemplos abaixo:</p>"},{"location":"pt-BR/forest_report/#exemplo-correto","title":"\u2705 Exemplo correto","text":"ID_Regiao ID Fazenda 14 14-A 14 14-B 15 15-A 15 15-B <p>Cada combina\u00e7\u00e3o entre <code>ID_Regiao</code> e <code>ID Fazenda</code> \u00e9 \u00fanica, garantindo agrupamentos consistentes e sem sobreposi\u00e7\u00e3o.</p>"},{"location":"pt-BR/forest_report/#exemplo-incorreto","title":"\u274c Exemplo incorreto","text":"ID_Regiao ID Fazenda 14 A 14 B 15 A 15 B <p>Neste exemplo incorreto, o identificador \"A\" aparece em duas regi\u00f5es diferentes. Se o agrupamento for feito apenas por <code>ID Fazenda</code>, os resumos de \"A\" incluir\u00e3o dados de ambas as regi\u00f5es, resultando em erros de interpreta\u00e7\u00e3o.</p>"},{"location":"pt-BR/forest_report/#recomendacao","title":"\ud83d\udca1 Recomenda\u00e7\u00e3o","text":"<p>Use identificadores compostos que incluam o contexto completo, como <code>\"14-A\"</code>, <code>\"15-B\"</code> etc., garantindo que cada grupo seja un\u00edvoco.</p>"},{"location":"pt-BR/forest_report/#referencias","title":"Refer\u00eancias","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p>"},{"location":"pt-BR/getting_started/","title":"Primeiros Passos","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.  </p> <p>\ud83d\udcc4 Licen\u00e7a</p> <p>Esta biblioteca est\u00e1 licenciada sob a Creative Commons BY-NC 4.0.</p> <p>\u2714\ufe0f Uso pessoal e educacional permitido \u274c Uso comercial \u00e9 proibido sem autoriza\u00e7\u00e3o expressa do autor.</p> <p>Autor: Vinicius Richter </p> <p>Para come\u00e7ar a processar seus dados florestais da maneira mais f\u00e1cil poss\u00edvel, primeiro instale ForestPyTools.</p>"},{"location":"pt-BR/getting_started/#instalacao","title":"\u2b07\ufe0f Instala\u00e7\u00e3o","text":""},{"location":"pt-BR/getting_started/#instalacao-padrao","title":"Instala\u00e7\u00e3o padr\u00e3o:","text":"<pre><code>pip install git+https://github.com/RichterV/fptools.git\n</code></pre>"},{"location":"pt-BR/getting_started/#instalacao-de-uma-versao-especifica-exv000","title":"Instala\u00e7\u00e3o de uma vers\u00e3o espec\u00edfica (ex:<code>v0.0.0</code>):","text":"<pre><code>pip install git+https://github.com/RichterV/fptools.git@v0.0.0\n</code></pre>"},{"location":"pt-BR/hypsometric_relationship/","title":"Rela\u00e7\u00e3o Hipsom\u00e9trica","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.  </p> <p>Estime as alturas das \u00e1rvores ausentes com base nas alturas medidas em campo.</p>"},{"location":"pt-BR/hypsometric_relationship/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>HypRel(x, y, df, model, iterator)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o x Nome da coluna que cont\u00e9m os di\u00e2metros/circunfer\u00eancias das \u00e1rvores. y Nome da coluna que cont\u00e9m as alturas das \u00e1rvores. df O DataFrame contendo os dados das \u00e1rvores. model (Opcional) Uma lista de modelos usados para estimar as alturas das \u00e1rvores. Se <code>None</code>, usar\u00e1 todos os modelos dispon\u00edveis. Os modelos dispon\u00edveis s\u00e3o: <code>['curtis', 'parabolic', 'stofel', 'henriksen', 'prodan_i', 'prodan_ii', 'smd_fm', 'ann']</code>. iterator (Opcional) Nome de uma coluna usada como iterador. Pode ser o nome da fazenda, nome da parcela, c\u00f3digo ou qualquer identificador \u00fanico."},{"location":"pt-BR/hypsometric_relationship/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>functions and parameters<pre><code>  HypRel.run()  \n  HypRel.view_metrics()  \n  HypRel.plots(dir = None, show = None)#(1)!\n\n  HypRel.get_coef()\n  HypRel.predict()\n</code></pre></p> <ol> <li>dir = O diret\u00f3rio onde deseja salvar seus gr\u00e1ficos!    Se <code>dir == None</code>, os gr\u00e1ficos ser\u00e3o exibidos na tela. show = Exibe os gr\u00e1ficos na tela! Pode ser <code>True</code> ou <code>False</code>.</li> </ol> M\u00e9todos Descri\u00e7\u00e3o .run() Ajusta os modelos. .view_metrics() Retorna uma tabela com as m\u00e9tricas de cada modelo avaliado. .plots(dir=None, show=True) Retorna os gr\u00e1ficos de altura e res\u00edduos. .get_coef() Retorna os coeficientes de cada modelo. .predict() Retorna as alturas previstas e os modelos utilizados em novas colunas."},{"location":"pt-BR/hypsometric_relationship/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Utilizando os dados de Scolforo (2005), de um povoamento de Pinus taeda variando de 15 a 19 anos, com 5 parcelas de 420m\u00b2 medidas, podemos ajustar modelos para prever as alturas faltantes.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Parcela Dap (cm) H (m) Idade (anos) p-1 22.28 0.0 15 p-1 23.87 22.2 15 p-1 25.46 0.0 15 p-1 25.78 24.5 15 p-1 26.74 22.2 15 <p>hyp_rel_example.py<pre><code>from fptools.hyp_rel import HypRel#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>HypRel</code>.</li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>hyp_rel_example.py<pre><code>df = pd.read_excel(r'C:/seu/diret\u00f3rio/exemplo_scolforo.xlsx')#(1)!\n\nreg = HypRel('Dap (cm)',\"H (m)\",df)#(2)!\n\nresults = reg.run()#(3)!\n\nmetrics = reg.view_metrics()#(4)!\n\nreg.plots(r'C:/Your/path/to_save')#(5)!\n\ndf_coefficients =  reg.get_coef()#(6)!\n\nfinal_results =  reg.predict()#(7)!\n</code></pre></p> <ol> <li>Carrega seu arquivo <code>.xlsx</code>.  </li> <li>Cria a vari\u00e1vel <code>reg</code> contendo a classe <code>HypRel</code>. Como <code>model</code> n\u00e3o foi declarado, usar\u00e1 todos os modelos dispon\u00edveis.    Caso queira usar um modelo espec\u00edfico defina <code>model=['curtis']</code> por exemplo, dessa forma usar\u00e1 somente o modelo de curtis.    Caso queira ajustar os modelos para cada uma das parcelas utilize <code>iterator=\"Parcela\"</code>.    Ex: <code>reg = HypRel('Dap (cm)',\"H (m)\",df, iterator=\"Parcela\")</code></li> <li>Executa os modelos e salva na vari\u00e1vel <code>results</code>.  </li> <li>Avalia os modelos ajustados e salva as m\u00e9tricas na vari\u00e1vel <code>metrics</code>.  </li> <li>Gera os gr\u00e1ficos para os modelos ajustados.  </li> <li>Obt\u00e9m os coeficientes de cada modelo ajustado.  </li> <li>Obt\u00e9m as alturas finais e os modelos utilizados para a estimativa.  </li> </ol> <p>Nesse caso, <code>iterator</code> e <code>model</code> n\u00e3o foram declarados, logo todas as equa\u00e7\u00f5es foram ajustadas para o banco de dados inteiro. Nesse caso, esses foram os outputs:  </p>"},{"location":"pt-BR/hypsometric_relationship/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/hypsometric_relationship/#tabelas","title":"Tabelas","text":"<p><code>results</code>(1)</p> <ol> <li>DataFrame contendo as alturas estimadas para cada um dos modelos e a altura medida no campo na coluna \"Real Height\".</li> </ol> curtis parabolic stofel henriksen prodan_i prodan_ii smd_fm ann Real Height 21.11 22.19 22.33 21.78 22.81 22.77 21.12 22.82 0.00 22.21 22.97 23.07 22.71 23.39 23.35 22.26 23.45 22.20 23.22 23.73 23.79 23.58 23.98 23.95 23.29 24.08 0.00 23.42 23.88 23.93 23.75 24.10 24.08 23.49 24.20 24.50 23.98 24.33 24.35 24.24 24.46 24.44 24.06 24.58 22.20 <p><code>metrics</code>(1)</p> <ol> <li>DataFrame contendo as m\u00e9tricas obtidas para cada modelo, atribuindo um <code>Score=10</code> para o melhor modelo.</li> </ol> Modelo MAE MAPE MSE RMSE R squared Explained Var Mean Error score henriksen 2,2125 7,6139 6,9901 2,6439 0,4163 0,4163 5,08E-15 10 curtis 2,1993 7,5325 7,0147 2,6485 0,4142 0,4154 0,1182 9 smd_fm 2,2099 7,6004 7,0020 2,6461 0,4153 0,4153 -0,0015 8 stofel 2,2060 7,5649 7,0210 2,6497 0,4137 0,4148 0,1177 7 parabolic 2,2183 7,6358 7,0099 2,6476 0,4146 0,4146 5,47E-16 6 ann 2,2194 7,6453 7,0312 2,6516 0,4128 0,4128 0,0002 5 prodan_ii 2,2008 7,5168 7,0921 2,6631 0,4077 0,4127 0,2434 4 prodan_i 2,2020 7,5241 7,0886 2,6625 0,4080 0,4125 0,2323 3 <p><code>df_coefficients</code>(1)</p> <ol> <li>DataFrame contendo os coeficientes de cada modelo e indicando qual deles foi o selecionado como melhor modelo.     Como <code>iterator</code> n\u00e3o foi declarado, a coluna fica vazia.</li> </ol> iterator model equation b0 b1 b2 selected_model curtis ln(h) = b0 + b1\u00b7(1/x) 3,8139 -17,0254 False parabolic h = b0 + b1\u00b7x + b2\u00b7x\u00b2 8,9680 0,6891 -0,0043 False stofel ln(h) = b0 + b1\u00b7ln(x) 1,6300 0,4755 False henriksen h = b0 + b1\u00b7ln(x) -20,1429 13,5058 True prodan_i h = x\u00b2 / (b0 + b1\u00b7x + b2\u00b7x\u00b2) -7,7832 1,0345 0,0131 False prodan_ii h - 1.3 = x\u00b2 / (b0 + b1\u00b7x + b2\u00b7x\u00b2) -7,9302 1,1027 0,0131 False smd_fm y = log(y) ~ x = 1/x + 1/x\u00b2 3,8008 -16,0925 False <p><code>final_results</code>(1)</p> <ol> <li>DataFrame inical contendo duas novas colunas: <code>best_predicted_height</code> com a altura estimada pelo melhor modelo.  <code>selected_model</code> indicando qual foi o melhor modelo.</li> </ol> Parcela Dap (cm) H (m) Idade (anos) best_predicted_height selected_model p-1 22,28 0 15 21,77502772 henriksen p-1 23,87 22,2 15 22,2 henriksen p-1 25,46 0 15 23,57696518 henriksen p-1 25,78 24,5 15 24,5 henriksen p-1 26,74 22,2 15 22,2 henriksen <p>Se voc\u00ea desejar que cada modelo seja ajustado para cada uma das parcelas basta substituir a linha: <code>reg = HypRel('Dap (cm)',\"H (m)\",df)</code> por: <code>reg = HypRel('Dap (cm)',\"H (m)\",df, iterator=\"Fazenda\")</code></p>"},{"location":"pt-BR/hypsometric_relationship/#graficos","title":"Gr\u00e1ficos","text":"<p>Como a linha <code>reg.plots(r'C:/Your/path/to_save')</code> informou um diret\u00f3rio para serem salvos os gr\u00e1ficos gerados, ser\u00e3o criadas duas pastas nesse diret\u00f3rio: Uma pasta chamada <code>heights</code> contendo os gr\u00e1ficos das curvas ajustadas. Uma pasta chamada <code>residuals</code> contendo os gr\u00e1ficos de res\u00edduos dos ajustes.</p> Exemplo de gr\u00e1fico gerado com a curva ajustada para o modelo de henriksen Exemplo de gr\u00e1fico de res\u00edduos gerado para o  modelo de henriksen flowchart LR     subgraph run         runText1[Executa todos os modelos dispon\u00edveis]     end     subgraph view_metrics         runText2[Retorna um DataFrame com as m\u00e9tricas dos modelos ajustados]     end     subgraph plots         runText3[Gera gr\u00e1ficos]     end     subgraph coefficients         runText4[Retorna um DataFrame com os coeficientes dos modelos ajustados]     end     subgraph predict         runText5[Retorna o DataFrame original contendo uma nova coluna com as alturas estimadas]     end     %% Links para os subgr\u00e1ficos:     HypRel-Module --&gt; run     HypRel-Module --&gt; view_metrics     HypRel-Module --&gt; plots     HypRel-Module --&gt; coefficients     HypRel-Module --&gt; predict"},{"location":"pt-BR/hypsometric_relationship/#modelos-disponiveis","title":"Modelos Dispon\u00edveis","text":""},{"location":"pt-BR/hypsometric_relationship/#curtis","title":"<li>curtis</li>","text":"\\[ \\operatorname{Altura Total} =e^{(\\beta_0+\u03b21*\\frac{1}{x})} \\]"},{"location":"pt-BR/hypsometric_relationship/#parabolic","title":"<li>parabolic</li>","text":"\\[ \\operatorname{Altura Total} = \\beta_0 + \\beta_1 * x + \\beta_2 * x^2 \\]"},{"location":"pt-BR/hypsometric_relationship/#stofels","title":"<li>stofels</li>","text":"\\[ \\operatorname{Altura Total} = e^{(\\beta_0+\\beta_1*\\ln(x))} \\]"},{"location":"pt-BR/hypsometric_relationship/#henriksen","title":"<li>henriksen</li>","text":"\\[ \\operatorname{Altura Total} = \\beta_0 + \\beta_1 * \\ln(x) \\]"},{"location":"pt-BR/hypsometric_relationship/#prodan_i","title":"<li>prodan_i</li>","text":"\\[ \\operatorname{Altura Total} = (\\frac{x^2}{\\beta_0+\\beta_1*x+\\beta_2* x^2}) \\]"},{"location":"pt-BR/hypsometric_relationship/#prodan_ii","title":"<li>prodan_ii</li>","text":"\\[ \\operatorname{Altura Total} =(\\frac{x^2}{\\beta_0+\\beta_1*x+\\beta_2* x^2})+1.3 \\]"},{"location":"pt-BR/hypsometric_relationship/#smd_fm","title":"<li>smd_fm</li>Transforma\u00e7\u00f5es de YTransforma\u00e7\u00f5es de X","text":"<p>Adapta\u00e7\u00e3o do pacote Julia \"Forest Mensuration\" por SILVA (2022), usado para realizar regress\u00f5es utilizando diferentes tipos de transforma\u00e7\u00f5es do di\u00e2metro \u00e0 altura do peito e altura nos processos de rela\u00e7\u00e3o hipsom\u00e9trica.</p> <ul> <li> \\( y \\) </li> <li> \\( \\log(y) \\) </li> <li> \\( \\log(y - 1.3) \\) </li> <li> \\( \\log(1 + y) \\) </li> <li> \\( \\frac{1}{y} \\) </li> <li> \\( \\frac{1}{y - 1.3} \\) </li> <li> \\( \\frac{1}{\\sqrt{y}} \\) </li> <li> \\( \\frac{1}{\\sqrt{y - 1.3}} \\) </li> <li> \\( \\frac{x}{\\sqrt{y}} \\) </li> <li> \\( \\frac{x}{\\sqrt{y - 1.3}} \\) </li> <li> \\( \\frac{x^2}{y} \\) </li> <li> \\( \\frac{x^2}{y - 1.3} \\) </li> </ul> <ul> <li> \\( x \\) </li> <li> \\( x^2 \\) </li> <li> \\( \\log(x) \\) </li> <li> \\( \\log(x)^2 \\) </li> <li> \\( \\frac{1}{x} \\) </li> <li> \\( \\frac{1}{x^2} \\) </li> <li> \\( x + x^2 \\) </li> <li> \\( x + \\log(x) \\) </li> <li> \\( x + \\log(x)^2 \\) </li> <li> \\( x + \\frac{1}{x} \\) </li> <li> \\( x + \\frac{1}{x^2} \\) </li> <li> \\( x^2 + \\log(x) \\) </li> <li> \\( x^2 + \\log(x)^2 \\) </li> <li> \\( x^2 + \\frac{1}{x} \\) </li> <li> \\( \\log(x) + \\log(x)^2 \\) </li> <li> \\( \\log(x) + \\frac{1}{x} \\) </li> <li> \\( \\log(x) + \\frac{1}{x^2} \\) </li> <li> \\( \\log(x)^2 + \\frac{1}{x} \\) </li> <li> \\( \\log(x)^2 + \\frac{1}{x^2} \\) </li> <li> \\( \\frac{1}{x} + \\frac{1}{x^2} \\) </li> </ul>"},{"location":"pt-BR/hypsometric_relationship/#ann","title":"<li>ann</li>","text":"<p>Explica\u00e7\u00e3o sobre Redes Neurais Artificiais abaixo.</p>"},{"location":"pt-BR/hypsometric_relationship/#rede-neural-artificial","title":"Rede Neural Artificial","text":"<p>Ao selecionar o modelo 'ann', 4 diferentes estruturas de redes neurais artificiais ser\u00e3o testadas. Apenas o resultado de um modelo ser\u00e1 retornado. O modelo retornado ser\u00e1 selecionado pela fun\u00e7\u00e3o de classifica\u00e7\u00e3o.  </p> <p>Para o modelo 'ann', o m\u00f3dulo sklearn.neural_network.MLPRegressor \u00e9 utilizado.</p> --- title: Par\u00e2metros da ANN --- classDiagram     class MLPRegressor {       \u00c9pocas: 3000       Ativa\u00e7\u00e3o: log\u00edstica       Modo do Solver: lbfgs       Tamanho do Lote: din\u00e2mico       Taxa de Aprendizado Inicial: 0.1       Modo da Taxa de Aprendizado: adaptativo     }      class Model-0 {       Tamanhos das Camadas Ocultas: (4,5)     }     class Model_1 {       Tamanhos das Camadas Ocultas: (4,2)     }     class Model_2 {       Tamanhos das Camadas Ocultas: (3,2)     }     class Model_3 {       Tamanhos das Camadas Ocultas: (4,4)     }      MLPRegressor &lt;|-- Model-0     MLPRegressor &lt;|-- Model_1     MLPRegressor &lt;|-- Model_2     MLPRegressor &lt;|-- Model_3"},{"location":"pt-BR/hypsometric_relationship/#funcao-de-ranqueamento","title":"Fun\u00e7\u00e3o de Ranqueamento","text":"<p>Para selecionar os modelos com melhor desempenho e classific\u00e1-los adequadamente, as seguintes m\u00e9tricas s\u00e3o calculadas:</p> Nome da M\u00e9trica Estrutura Erro M\u00e9dio Absoluto (MAE) \\( MAE = \\frac{1}{n} \\sum_{i=1}^{n} \\|y_i - \\hat{y}_i\\| \\) Erro Percentual M\u00e9dio Absoluto (MAPE) \\( MAPE = \\frac{100}{n} \\sum_{i=1}^{n} \\left\\|\\frac{y_i - \\hat{y}_i}{y_i}\\right\\| \\) Erro Quadr\u00e1tico M\u00e9dio (MSE) \\( MSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 \\) Raiz do Erro Quadr\u00e1tico M\u00e9dio (RMSE) \\( RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2} \\) R\u00b2 (Coeficiente de Determina\u00e7\u00e3o) \\( R^2 = 1 - \\frac{\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} \\) Vari\u00e2ncia Explicada (EV) \\( EV = 1 - \\frac{Var(y - \\hat{y})}{Var(y)} \\) Erro M\u00e9dio \\( Erro\\ M\u00e9dio = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i) \\) <p>Ap\u00f3s obter as m\u00e9tricas para cada modelo testado, o melhor modelo recebe uma pontua\u00e7\u00e3o de 10, enquanto os demais recebem pontua\u00e7\u00f5es de 9, 8 e assim por diante.</p>"},{"location":"pt-BR/hypsometric_relationship/#referencias","title":"Refer\u00eancias","text":"<p>CURTIS, R. O. (1967). Height-Diameter and Height-Diameter-Age Equations For Second-Growth Douglas-Fir. Forest Science, 13(4), 365\u2013375.       https://doi.org/10.1093/forestscience/13.4.365</p> <p>SCOLFORO, J. R. S. (2005). Biometria Florestal: Parte I: Modelos de regress\u00e3o linear e n\u00e3o-linear; Parte II: Modelos para rela\u00e7\u00e3o hipsom\u00e9trica, volume, afilamento e preso de mat\u00e9ria seca. Lavras: UFLA/FAEPE, pp. 224\u2013226.</p> <p>SILVA, M. D. (2022). Forest Mensuration.jl: Uma Introdu\u00e7\u00e3o \u00e0 Aplica\u00e7\u00f5es em Julia. 128 p. Trabalho de Conclus\u00e3o de Curso (Gradua\u00e7\u00e3o em Engenharia Florestal) \u2013 Universidade Federal de Santa Maria, Frederico Westphalen, RS, 2022.</p> <p>JAMES, G.; WITTEN, D.; HASTIE, T.; TIBSHIRANI, R. (2013). An Introduction to Statistical Learning. In Springer Texts in Statistics. Springer New York.       https://doi.org/10.1007/978-1-4614-7138-7</p>"},{"location":"pt-BR/plot_allocation/","title":"Aloca\u00e7\u00e3o de Parcelas","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Esse m\u00f3dulo permite a aloca\u00e7\u00e3o de parcelas amostrais com v\u00e1rios tipos de amostragem e formatos de parcelas. Se preferir uma interface visual, considere usar o m\u00f3dulo QGIS.</p>"},{"location":"pt-BR/plot_allocation/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>PlotAllocation(shp_dir, epsg)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o shp_dir Diret\u00f3rio do shapefile que define os limites da \u00e1rea a ser amostrada. epsg C\u00f3digo EPSG do shapefile que define os limites da \u00e1rea a ser amostrada."},{"location":"pt-BR/plot_allocation/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>methods and parameters<pre><code>PlotAllocation.create_plots(distribution, plot_format, plot_area, sample_number,\n                            by_hectare, min_border_distance, rectangle_size,\n                            x_y_angle, save_buffer, show_plot, save_dir)\n</code></pre></p> Par\u00e2metro Descri\u00e7\u00e3o distribution Tipo de distribui\u00e7\u00e3o ou aloca\u00e7\u00e3o \u00e0 qual as parcelas ser\u00e3o submetidas. plot_format Formato da parcela que ser\u00e1 instalada. plot_area \u00c1rea da parcela que ser\u00e1 instalada. N\u00e3o utilizada quando <code>plot_format = 'rectangle'</code>. sample_number Pode ser o n\u00famero de parcelas, a porcentagem da \u00e1rea total que ser\u00e1 amostrada ou uma coluna na tabela de atributos contendo o n\u00famero de parcelas por pol\u00edgono. Se o valor for &lt; 1, ser\u00e1 entendido como uma porcentagem. Se o valor for &gt;= 1, ser\u00e1 entendido como a quantidade de parcelas a serem alocadas. by_hectare Se <code>True</code>, utilizar\u00e1 <code>sample_number</code> como parcelas por hectare. Se <code>sample_number &lt; 1</code>, usar\u00e1 apenas a porcentagem. min_border_distance Dist\u00e2ncia m\u00ednima em metros que as parcelas devem estar da borda dos limites do shapefile. rectangle_size Usado quando <code>plot_format = 'rectangle'</code>. Tupla contendo os tamanhos de X e Y do ret\u00e2ngulo <code>(x,y)</code>. x_y_angle Usado quando <code>distribution = 'systematic custom'</code>. Define a dist\u00e2ncia em X e Y de cada linha na grade da distribui\u00e7\u00e3o sistem\u00e1tica e tamb\u00e9m o \u00e2ngulo de rota\u00e7\u00e3o da grade em graus <code>(x,y,angle)</code>. save_buffer Se <code>True</code>, salva o buffer considerando o tamanho da parcela ao redor do ponto. show_plot Se <code>True</code>, exibe uma figura da aloca\u00e7\u00e3o realizada. save_dir Diret\u00f3rio onde os shapefiles ser\u00e3o salvos. Se <code>None</code>, nenhum shapefile ser\u00e1 salvo. <p>Argumentos dispon\u00edveis</p> Tipo de distribui\u00e7\u00e3oFormato da parcelaEPSG <ul> <li><code>random</code> : Aloca as parcelas em uma distribui\u00e7\u00e3o aleat\u00f3ria.</li> <li><code>best sampling</code> : (recomendado) Aloca as parcelas na melhor distribui\u00e7\u00e3o poss\u00edvel para a \u00e1rea considerando os par\u00e2metros estabelecidos. </li> <li><code>systematic</code> : Aloca as parcelas em uma distribui\u00e7\u00e3o em grade, n\u00e3o permite a defini\u00e7\u00e3o de <code>sample_number</code> e aloca todas as parcelas poss\u00edveis.</li> <li><code>systematic custom</code> : Aloca as parcelas em uma distribui\u00e7\u00e3o em grade com as dist\u00e2ncias <code>x</code> e <code>y</code> das linhas da grade e o <code>\u00e2ngulo de rota\u00e7\u00e3o da grade</code> definidos pelo usu\u00e1rio.</li> </ul> <ul> <li><code>round</code> : Considera que as parcelas ter\u00e3o formato arredondado.</li> <li><code>squared</code> : Considera que as parcelas ter\u00e3o formato quadrado. </li> <li><code>rectangle</code> : Permite que o usu\u00e1rio insira os tamanhos X e Y do formato retangular desejado. </li> </ul> <ul> <li>Para obter a melhor precis\u00e3o nos c\u00e1lculos, voc\u00ea deve selecionar a zona UTM na qual sua \u00e1rea est\u00e1 localizada. Encontre sua zona UTM.</li> </ul>"},{"location":"pt-BR/plot_allocation/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considere os dados de 3 talh\u00f5es fict\u00edcios, delimitados em uma floresta pr\u00f3xima a Universidade Federal de Santa Maria, Campus Frederico Westphalen, RS-Brasil. Baixar shapefile de exemplo. </p> <p>Informa\u00e7\u00f5es da tabela de atributos:  </p> id talhao area_ha n_par 1 A 4,049 3 2 B 15,521 5 3 C 39,964 14"},{"location":"pt-BR/plot_allocation/#distribuicao-aleatoria","title":"Distribui\u00e7\u00e3o Aleat\u00f3ria","text":"<p>plot_allocation_example_1.py<pre><code>from fptools.inventory_plots import PlotAllocation#(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"random\", sample_number=\"n_par\",\n                   plot_area=400, min_border_distance=2, \n                   save_dir=\"C:/Users/Desktop\",\n                   show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Importa a classe <code>PlotAllocation</code>.  </li> <li>Cria a vari\u00e1vel <code>plots</code> com a classe <code>PlotAllocation</code>. Define o caminho do shapefile da \u00e1rea limite e o EPSG.  </li> <li>Cria as parcelas com distribui\u00e7\u00e3o <code>random</code>, utilizando a coluna <code>\"n_par\"</code> da tabela de atributos para definir o n\u00famero de parcelas, <code>plot area = 400 m\u00b2</code>, uma dist\u00e2ncia m\u00ednima da borda de 20 metros e salva o shapefile em <code>C:\\Users\\Desktop</code>.  </li> </ol>      Como <code>show_plot=True</code>, uma figura de exibi\u00e7\u00e3o pr\u00e9via de aloca\u00e7\u00e3o das parcelas ser\u00e1 gerada.         Distribui\u00e7\u00e3o: Aleat\u00f3ria;     \u00c1rea das parcelas: 400m\u00b2;     N\u00ba de parcelas: coluna \"n_par\";     Dist\u00e2ncia da borda: 2 metros;"},{"location":"pt-BR/plot_allocation/#distribuicao-sistematica-personalizada","title":"Distribui\u00e7\u00e3o Sistem\u00e1tica Personalizada","text":"<p>plot_allocation_example_2.py<pre><code>from fptools.inventory_plots import PlotAllocation#(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"systematic custom\", x_y_angle=(100,50,45),\n                    plot_area=400, min_border_distance=2, save_dir=\"C:\\Users\\Desktop\",\n                    show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Importa a classe <code>PlotAllocation</code>.  </li> <li>Cria a vari\u00e1vel <code>plots</code> com a classe <code>PlotAllocation</code>. Define o caminho do shapefile da \u00e1rea limite e o EPSG.  </li> <li>Cria as parcelas com distribui\u00e7\u00e3o <code>systematic custom</code>, <code>plot area = 400 m\u00b2</code>, com <code>dist\u00e2ncia x = 100 metros</code>, <code>dist\u00e2ncia y = 50 metros</code> e rota\u00e7\u00e3o da grade de 45\u00ba, com uma dist\u00e2ncia m\u00ednima da borda de 2 metros e salva o shapefile em <code>C:\\Users\\Desktop</code>.  </li> </ol>      Como <code>show_plot=True</code>, uma figura de exibi\u00e7\u00e3o pr\u00e9via de aloca\u00e7\u00e3o das parcelas ser\u00e1 gerada.         Distribui\u00e7\u00e3o: Sistem\u00e1tica customizada;     \u00c1rea das parcelas: 400m\u00b2;     Dist\u00e2ncia em x: 100;     Dist\u00e2ncia em y: 50;     Rota\u00e7\u00e3o: 45\u00b0;     Dist\u00e2ncia da borda: 2 metros;"},{"location":"pt-BR/plot_allocation/#formato-de-parcela-retangular","title":"Formato de parcela retangular","text":"<p>plot_alocation_example_3.py<pre><code>from fptools.inventory_plots import PlotAllocation #(1)!\n\nplots = PlotAllocation(r\"your/path/exemplo_shapefile.shp\", epsg='32722')#(2)!\n\nplots.create_plots(distribution=\"best sampling\", rectangle_size=(20,30),\n                    sample_number = 2, by_hectare = True,\n                    min_border_distance=2, save_dir=\"C:\\Users\\Desktop\",\n                    show_plot=True, save_buffer=True)#(3)!\n</code></pre></p> <ol> <li>Importa a classe <code>PlotAllocation</code>.  </li> <li>Cria a vari\u00e1vel <code>plots</code> com a classe <code>PlotAllocation</code>. Define o caminho do shapefile da \u00e1rea limite e o EPSG.  </li> <li>Cria as parcelas com distribui\u00e7\u00e3o <code>best sampling</code>, uma <code>largura do ret\u00e2ngulo (x) = 2 metros</code> e <code>altura (y) = 30 metros</code>, com uma dist\u00e2ncia m\u00ednima da borda de 2 metros, uma amostragem de 2 parcelas por hectare e salva o shapefile em <code>C:\\Users\\Desktop</code>.  </li> </ol>      Como <code>show_plot=True</code>, uma figura de exibi\u00e7\u00e3o pr\u00e9via de aloca\u00e7\u00e3o das parcelas ser\u00e1 gerada.         Distribui\u00e7\u00e3o: Best sampling;     \u00c1rea das parcelas: 400m\u00b2;     N\u00ba parcelas: 2/hectare;     Dist\u00e2ncia da borda: 2 metros;"},{"location":"pt-BR/plot_allocation_qgis/","title":"Aloca\u00e7\u00e3o de Parcelas com QGIS","text":"<p>Com o Plugin FPT Plot Allocation, voc\u00ea poder\u00e1 alocar parcelas de invent\u00e1rio utilizando diversos m\u00e9todos de amostragem e formatos de parcela, tudo por meio de uma interface gr\u00e1fica intuitiva e amig\u00e1vel.</p>"},{"location":"pt-BR/plot_allocation_qgis/#instalacao-do-plugin","title":"Instala\u00e7\u00e3o do Plugin","text":"<p>No QGIS, v\u00e1 para \"Complementos\"  \"Gerenciar e Instalar Complementos\" e pesquise por \"FPT Plot Allocation\".</p>"},{"location":"pt-BR/plot_allocation_qgis/#instalacao-via-arquivo-zip","title":"Instala\u00e7\u00e3o via arquivo ZIP","text":"<p>Se preferir, clique aqui para baixar o arquivo ZIP contendo os arquivos do plugin. Para mais informa\u00e7\u00f5es sobre a instala\u00e7\u00e3o, consulte o guia de instala\u00e7\u00e3o de plugins do QGIS.</p>      Durante a instala\u00e7\u00e3o do plugin, o c\u00f3digo tentar\u00e1 instalar a vers\u00e3o 1.5.2 do pacote externo scikit-learn.     Se ocorrer um erro, considere instal\u00e1-lo manualmente no \"OSGeo4W Shell\" executando o comando:     <code>pip install scikit-learn==1.5.2</code>        Copiar c\u00f3digo         C\u00f3digo copiado para a \u00e1rea de transfer\u00eancia!"},{"location":"pt-BR/plot_allocation_qgis/#interface-do-plugin","title":"Interface do Plugin","text":"Esta \u00e9 a interface do plugin. Abaixo, voc\u00ea aprender\u00e1 como configurar e alocar suas parcelas."},{"location":"pt-BR/plot_allocation_qgis/#funcionalidades-do-plugin","title":"Funcionalidades do Plugin","text":"Par\u00e2metros Descri\u00e7\u00e3o Type of distribution Tipo de distribui\u00e7\u00e3o das parcelas. Plot format Formato da parcela que ser\u00e1 instalada. Boundary layer O shapefile com o pol\u00edgono da \u00e1rea. Use a column to define plots number Se selecionado, permite ao usu\u00e1rio escolher uma coluna para definir o n\u00famero de parcelas por pol\u00edgono. Plot area \u00c1rea em metros quadrados que cada parcela ter\u00e1. Sample numbers or sample percentage Pode ser o n\u00famero de parcelas ou a porcentagem da \u00e1rea total que ser\u00e1 amostrada. Se <code>valor &lt; 1</code>, ser\u00e1 entendido como porcentagem. Se <code>valor &gt;= 1</code>, ser\u00e1 entendido que voc\u00ea est\u00e1 definindo a quantidade de parcelas a serem alocadas. By hectare Se selecionado, aplica o valor de <code>N\u00famero de parcelas ou porcentagem da amostragem</code> por hectare. O valor deve ser maior que 1. Minimum border distance (meters) (Opcional) Define a dist\u00e2ncia m\u00ednima em metros que cada parcela ter\u00e1 da borda. EPSG O EPSG da sua \u00e1rea. Create buffer for plots (Opcional) Se marcado, criar\u00e1 um buffer mostrando a \u00e1rea das parcelas. Output (Opcional) Selecione uma pasta para salvar o shapefile das suas parcelas. <p>Argumentos dispon\u00edveis</p> Tipo de distribui\u00e7\u00e3oFormato da parcelaEPSG <ul> <li><code>random</code> : Aloca as parcelas de forma aleat\u00f3ria.</li> <li><code>best sampling</code> : (recomendado) Aloca as parcelas na melhor distribui\u00e7\u00e3o poss\u00edvel para a \u00e1rea, considerando os par\u00e2metros estabelecidos.</li> <li><code>systematic</code> : Aloca as parcelas em uma distribui\u00e7\u00e3o em grade, n\u00e3o permite a defini\u00e7\u00e3o de <code>n\u00famero de parcelas ou porcentagem da amostragem</code> e aloca todas as parcelas poss\u00edveis.</li> <li><code>systematic custom</code> : Aloca as parcelas em uma distribui\u00e7\u00e3o em grade com as dist\u00e2ncias <code>x</code> e <code>y</code> das linhas da grade e o <code>\u00e2ngulo de rota\u00e7\u00e3o da grade</code> definidos pelo usu\u00e1rio.</li> </ul> <ul> <li><code>round</code> : Considera que as parcelas ter\u00e3o um formato arredondado.</li> <li><code>squared</code> : Considera que as parcelas ter\u00e3o um formato quadrado. </li> <li><code>rectangle</code> : Permite que o usu\u00e1rio insira os tamanhos X e Y do formato retangular desejado. </li> </ul> <ul> <li>Para obter a melhor precis\u00e3o nos c\u00e1lculos, voc\u00ea deve selecionar a zona UTM na qual sua \u00e1rea est\u00e1 localizada. Encontre sua zona UTM.</li> </ul>"},{"location":"pt-BR/plot_allocation_qgis/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considere os dados de 3 talh\u00f5es fict\u00edcios, delimitados em uma floresta pr\u00f3xima a Universidade Federal de Santa Maria, Campus Frederico Westphalen, RS-Brasil. Baixar shapefile de exemplo. </p>      Vis\u00e3o das limita\u00e7\u00f5es do shapefile    <p>Informa\u00e7\u00f5es da tabela de atributos:  </p> id talhao area_ha n_par 1 A 4,049 3 2 B 15,521 5 3 C 39,964 14      Exemplo de aloca\u00e7\u00e3o de parcelas usando a distriubi\u00e7\u00e3o \"best sampling\", parcelas quadradas de 400m\u00b2, dist\u00e2ncia de borda de 1 metro e usando a coluna \"n_par\" da tabela de atributos para definir o n\u00famero de parcelas"},{"location":"pt-BR/sampling_stats/","title":"Estat\u00edstica amostral","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Este m\u00f3dulo permite calcular par\u00e2metros de amostragem simples e estratificada com base nos volumes das unidades amostrais.</p>"},{"location":"pt-BR/sampling_stats/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>SamplingStats(volume_df)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o volume_df O dataframe contendo os dados de volume por unidade amostral."},{"location":"pt-BR/sampling_stats/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>m\u00e9todos e par\u00e2metros<pre><code>  SamplingStats.simple(total_area, plot_id, plot_area,\n                       volume, error_lim=10, conf=95)#(1)!\n  SamplingStats.stratified(total_area, stratum_id, stratum_area,\n                           plot_id, plot_area, volume, error_lim=10, conf=95)#(2)!\n  SamplingStats.stratified_anova()\n</code></pre></p> <ol> <li> <p>total_area = Nome da coluna que cont\u00e9m o valor da \u00e1rea total em metros quadrados do povoamento florestal avaliado.                                      plot_id = Nome da coluna que cont\u00e9m o identificador \u00fanico da parcela/unidade amostral. plot_area =  Nome da coluna que cont\u00e9m a \u00e1rea em metros quadrados da parcela/unidade amostral. volume = Nome da coluna que cont\u00e9m os valores de volume em metros c\u00fabicos de cada parcela/unidade amostral. error_lim = (Opcional) Valor n\u00famerico ou nome da coluna que contenha o limite de erro tolerado em valor percentual. conf = (opcional) Valor num\u00e9rico ou nome da coluna que representa o n\u00edvel de confian\u00e7a (por exemplo, 95%) a ser utilizado nos c\u00e1lculos estat\u00edsticos.</p> </li> <li> <p>total_area = Nome da coluna que cont\u00e9m o valor da \u00e1rea total em metros quadrados do povoamento florestal avaliado.  stratum_id = Nome da coluna que cont\u00e9m o identificador \u00fanico do estrato.                                    plot_id = Nome da coluna que cont\u00e9m o identificador \u00fanico da parcela/unidade amostral. plot_area =  Nome da coluna que cont\u00e9m a \u00e1rea em metros quadrados da parcela/unidade amostral. volume = Nome da coluna que cont\u00e9m os valores de volume em metros c\u00fabicos de cada parcela/unidade amostral. error_lim = (Opcional) Valor n\u00famerico ou nome da coluna que contenha o limite de erro tolerado em valor percentual. conf = (opcional) Valor num\u00e9rico ou nome da coluna que representa o n\u00edvel de confian\u00e7a (por exemplo, 95%) a ser utilizado nos c\u00e1lculos estat\u00edsticos.</p> </li> </ol> Par\u00e2metros Descri\u00e7\u00e3o .simple() Retorna um DataFrame contendo os par\u00e2metros estat\u00edsticos e a sufici\u00eancia amostral para amostragem aleat\u00f3ria simples. .stratified() Retorna um DataFrame contendo os par\u00e2metros estat\u00edsticos e a sufici\u00eancia amostral para amostragem estratificada. .stratified_anova() Retorna um DataFrame contendo an\u00e1lise de vari\u00e2ncia (ANOVA) da estratifica\u00e7\u00e3o realizada com o m\u00e9todo <code>.stratified()</code>."},{"location":"pt-BR/sampling_stats/#amostragem-simples","title":"Amostragem simples","text":""},{"location":"pt-BR/sampling_stats/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considere a adapta\u00e7\u00e3o do exemplo utilizado por Sanquetta et al. (2014) para exemplificar o c\u00e1lculo das estat\u00edsticas do processo de amostragem aleat\u00f3ria simples.</p> Fazenda Parcela area_total (m\u00b2) area_parcela (m\u00b2) Volume (m\u00b3) limite_erro(%) nivel_confianca(%) Fazenda 1 1 400000 600 20,85 10 95 Fazenda 1 2 400000 600 19,47 10 95 Fazenda 1 3 400000 600 24,13 10 95 Fazenda 1 4 400000 600 24,34 10 95 Fazenda 1 5 400000 600 25,13 10 95 Fazenda 1 6 400000 600 22,37 10 95 Fazenda 1 7 400000 600 22,51 10 95 Fazenda 1 8 400000 600 19,78 10 95 Fazenda 1 9 400000 600 25,05 10 95 Fazenda 1 10 400000 600 28,84 10 95 Fazenda 1 11 400000 600 23,70 10 95 Fazenda 1 12 400000 600 24,78 10 95 Fazenda 1 13 400000 600 22,58 10 95 Fazenda 1 14 400000 600 23,70 10 95 Fazenda 1 15 400000 600 36,16 10 95 Fazenda 1 16 400000 600 17,83 10 95 <p> Fazer download do arquivo. </p> <p>sampling_stats_simple_example.py<pre><code>from fptools.sampling_stats import SamplingStats#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>SamplingStats</code>.  </li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>sampling_stats_simple_example.py<pre><code>df = pd.read_excel(r'sua_pasta/volume_parcelas_simples_pt.xlsx')#(1)!\n\nss = SamplingStats(df)#(2)!\n\nss_results = ss.simple(total_area='area_total (m\u00b2)', plot_id='Parcela',\n                       plot_area ='area_parcela (m\u00b2)',volume = 'Volume (m\u00b3)',\n                       error_lim='limite_erro(%)', conf='nivel_confianca(%)')#(3)!\n\nss_results.to_excel('simple_sampling_stats.xlsx', index=False)#(4)!\n</code></pre></p> <ol> <li>Carrega arquivo xlsx contendo os dados.</li> <li>Cria a vari\u00e1vel <code>ss</code> contendo a classe <code>SamplingStats</code> e recebendo o DataFrame <code>df</code>.</li> <li>Indica o nome das colunas para cada par\u00e2metro da fun\u00e7\u00e3o <code>.simple()</code> e salve os resultados na vari\u00e1vel <code>ss_result</code>.</li> <li>Salva os resultados em um arquivo <code>simple_sampling_stats.xls</code> para posterior visualiza\u00e7\u00e3o.</li> </ol> Uma mensagem aparecer\u00e1 na sa\u00edda do executor do c\u00f3digo informando sobre sucesso dos c\u00e1lculos. <p>As seguintes informa\u00e7\u00f5es ser\u00e3o geradas pela fun\u00e7\u00e3o <code>simple()</code></p> metric value population finite real_n_par 16 ideal_n_par 15 mean_stratified (m\u00b3/plot) 23,83 variance (m\u00b3/plot) 17,82 st_deviation (m\u00b3/plot) 4,22 coeff_variation (%) 17,72 variance_of_the_mean (m\u00b3/plot) 1,09 st_error_of_the_mean (m\u00b3/plot) 1,04 abs_sampl_error (m\u00b3/plot) 2,24 rel_sampl_error (%) 9,39 mean_confidence_interval (m\u00b3) (21,59, 26,06) confidence_interval_total population (m\u00b3) (14400,52, 17383,7) total (m\u00b3/ha) 397,3 total_population (m\u00b3) 15892,11"},{"location":"pt-BR/sampling_stats/#amostragem-estratificada","title":"Amostragem estratificada","text":""},{"location":"pt-BR/sampling_stats/#exemplo-de-uso_1","title":"Exemplo de Uso","text":"<p>sampling_stats_stratified_example.py<pre><code>from fptools.sampling_stats import SamplingStats#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>SamplingStats</code>.  </li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>sampling_stats_stratified_example.py<pre><code>df_stratified = pd.read_excel(r'sua_pasta/volume_parcelas_estratificado_pt.xlsx')#(1)!\n\nss = SamplingStats(df_stratified)#(2)!\n\nss_results = ss.simple.stratified(total_area='area_total (m\u00b2)',\n                           stratum_id='Estrato',\n                           stratum_area='\u00c1rea do estrato (m\u00b2)',\n                           plot_id='Parcela',\n                           plot_area = 'area_parcela (m\u00b2)',\n                           volume=\"Volume (m\u00b3)\",\n                           error_lim='limite_erro(%)',\n                           conf='nivel_confianca(%)')#(3)!\n\nss_results.to_excel('stratified_sampling_stats.xlsx', index=False)#(4)!\nanova = ss.stratified_anova()#(5)!\nanova.to_excel(\"anova.xlsx\", index=False)#(6)!\n</code></pre></p> <ol> <li>Carrega o arquivo xlsx contendo os dados.</li> <li>Cria a vari\u00e1vel <code>ss</code> contendo a classe <code>SamplingStats</code> e recebendo o DataFrame <code>df_stratified</code>.</li> <li>Indica o nome das colunas para cada par\u00e2metro da fun\u00e7\u00e3o <code>.stratified()</code> e salve os resultados na vari\u00e1vel <code>ss_result</code>.</li> <li>Salva os resultados em um arquivo <code>stratified_sampling_stats.xlsx</code> para posterior visualiza\u00e7\u00e3o.</li> <li>Salva os valores da an\u00e1lise de vari\u00e2ncia na vari\u00e1vel <code>anova</code>.</li> <li>Salva a an\u00e1lise de vari\u00e2ncia em um arquivo <code>anova.xlsx</code></li> </ol> <p>Para esse exemplo, tamb\u00e9m usaremos os valores obtidos em Sanquetta et al. (2014).  Fazer download do arquivo. </p> <p>As seguintes informa\u00e7\u00f5es ser\u00e3o geradas pela fun\u00e7\u00e3o <code>stratified()</code>. Nesse caso, s\u00e3o gerados os resumos estat\u00edsticos tanto para o total quanto para os estratos individuais.</p> metrics total Estrato 1 Estrato 2 population finite finite finite real_n_par 24 12 12 ideal_n_par 8 5,2 2,8 mean (m\u00b3/plot) 107,25 89,08 125,42 variance (m\u00b3/plot) 137,91 71,54 261,17 st_deviation (m\u00b3/plot) 11,15 8,46 16,16 coeff_variation (%) 10,4 9,49 12,89 variance_of_the_mean (m\u00b3/plot) 5,05 5,85 21,02 st_error_of_the_mean (m\u00b3/plot) 2,25 2,42 4,58 abs_sampl_error (m\u00b3) 5,5 5,92 11,22 rel_sampl_error (%) 5,13 6,64 8,94 mean_confidence_interval (m\u00b3) (101,75, 112,75) (83,16, 95,0) (114,2, 136,63) confidence_interval_total population (m\u00b3) (101752,9, 112747,1) (54056,81, 61751,53) (39969,52, 47822,15) total (m\u00b3/ha) 107,25 89,08 125,42 total_population (m\u00b3) 107250 57904,17 43895,83 <p>An\u00e1lise de vari\u00e2ncia (ANOVA) gerada:</p> Fonte de Varia\u00e7\u00e3o SQ gl QM F F_cr\u00edtico H\u2080 Entre Estratos 8.633,527 1,000 8.633,527 51,898 4,301 Rejeitada Dentro dos Estratos 3.659,833 22,000 166,356 Total 12.293,360 23,000"},{"location":"pt-BR/sampling_stats/#equacoes-utilizadas","title":"Equa\u00e7\u00f5es utilizadas","text":""},{"location":"pt-BR/sampling_stats/#simples","title":"<li>Simples</li>","text":""},{"location":"pt-BR/sampling_stats/#intensidade-amostral","title":"Intensidade amostral","text":""},{"location":"pt-BR/sampling_stats/#populacoes-finitas","title":"Popula\u00e7\u00f5es finitas","text":"\\[ \\text{N\u00famero ideal de parcelas}: \\operatorname{n} = \\frac{N t^2 S_x^2}{N E^2 + t^2 S_x^2} \\]"},{"location":"pt-BR/sampling_stats/#populacoes-infinitas","title":"Popula\u00e7\u00f5es infinitas","text":"\\[ \\text{N\u00famero ideal de parcelas}: \\operatorname{n} = \\frac{t^2 S_x^2}{E^2} \\]"},{"location":"pt-BR/sampling_stats/#estatisticas","title":"Estat\u00edsticas","text":"\\[ \\text{M\u00e9dia Aritm\u00e9tica}: \\quad \\bar{x} = \\frac{\\sum_{i=1}^{n} X_i}{n} \\] \\[ \\text{Vari\u00e2ncia}: \\quad s_x^2 = \\frac{\\sum_{i=1}^{n} (X_i - \\bar{x})^2}{n - 1} \\] \\[ \\text{Desvio Padr\u00e3o}: \\quad s_x = \\sqrt{ \\frac{\\sum_{i=1}^{n} (X_i - \\bar{x})^2}{n - 1} } \\] \\[ \\text{Vari\u00e2ncia da M\u00e9dia}: \\quad s_{\\bar{x}}^2 = \\frac{s_x^2}{n} \\cdot \\left( \\frac{N - n}{N} \\right) \\] \\[ \\text{Erro Padr\u00e3o}: \\quad s_{\\bar{x}} = \\pm \\frac{s_x}{\\sqrt{n}} \\cdot \\sqrt{1 - f} \\] \\[ \\text{Coeficiente de Varia\u00e7\u00e3o}: \\quad \\operatorname{cv}(\\%) = \\frac{s_x}{\\bar{x}} \\cdot 100 \\] \\[ \\text{Erro de Amostragem Absoluto}: \\quad E_a = \\pm t \\cdot s_{\\bar{x}} \\] \\[ \\text{Erro de Amostragem Relativo}: \\quad E_r = \\pm \\frac{t \\cdot s_{\\bar{x}}}{\\bar{x}} \\cdot 100 \\] \\[ \\text{Intervalo de confian\u00e7a para a m\u00e9dia}: \\quad IC \\left[ \\bar{x} - (t \\cdot s_{\\bar{x}}) \\leq \\bar{X} \\leq \\bar{x} + (t \\cdot s_{\\bar{x}}) \\right] = P \\] \\[ \\text{Total da Popula\u00e7\u00e3o}: \\quad \\hat{X} = N \\cdot \\bar{x} \\] \\[ \\text{Intervalo de confian\u00e7a para o Total}: \\quad IC \\left[ \\hat{X} - N(t \\cdot s_{\\bar{x}}) \\leq X \\leq \\hat{X} + N(t \\cdot s_{\\bar{x}}) \\right] = P \\]"},{"location":"pt-BR/sampling_stats/#estratificada","title":"<li>Estratificada</li>","text":""},{"location":"pt-BR/sampling_stats/#intensidade-amostral_1","title":"Intensidade amostral","text":""},{"location":"pt-BR/sampling_stats/#populacoes-finitas_1","title":"Popula\u00e7\u00f5es finitas","text":"\\[ \\text{N\u00famero ideal de parcelas}: \\operatorname{n}= \\frac{t^2 \\sum_{h=1}^{L} W_h s_h^2}{E^2 + {t^2} \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N}} \\]"},{"location":"pt-BR/sampling_stats/#populacoes-infinitas_1","title":"Popula\u00e7\u00f5es infinitas","text":"\\[ \\text{N\u00famero ideal de parcelas}: \\operatorname{n} = \\frac{t^2 \\sum_{h=1}^{L} W_h s_h^2}{E^2} \\]"},{"location":"pt-BR/sampling_stats/#estatisticas_1","title":"Estat\u00edsticas","text":"\\[ \\text{M\u00e9dia por Estrato}: \\quad \\bar{x}_h = \\frac{\\sum_{i=1}^{n_h} x_{ih}}{n_h} \\] \\[ \\text{M\u00e9dia Estratificada}: \\quad \\bar{x}_{st} = \\frac{\\sum_{h=1}^{L} \\left( N_h \\cdot \\bar{x}_h \\right)}{N} = \\sum_{h=1}^{L} \\left( W_h \\cdot \\bar{x}_h \\right) \\] \\[ \\text{Vari\u00e2ncia por Estrato}: \\quad s_h^2 = \\frac{\\sum_{i=1}^{n_h} (x_{ih} - \\bar{x}_h)^2}{n_h - 1} \\] \\[ \\text{Vari\u00e2ncia Estratificada}: \\quad s_{st}^2 = \\sum_{h=1}^{L} \\left( W_h s_h^2 \\right) \\] \\[ \\text{Vari\u00e2ncia da M\u00e9dia Estratificada}: \\quad s_{\\bar{x}(st)}^2 = \\sum_{h=1}^{L} W_h^2 \\cdot \\frac{s_h^2}{n_h} - \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N} \\] \\[ \\text{Erro Padr\u00e3o Estratificado}: \\quad s_{\\bar{x}(st)} = \\sqrt{ \\sum_{h=1}^{L} W_h^2 \\cdot \\frac{s_h^2}{n_h} - \\sum_{h=1}^{L} \\frac{W_h s_h^2}{N} } \\] \\[ \\text{Erro de Amostragem Absoluto}: \\quad E_a = \\pm t \\cdot s_{\\bar{x}(st)} \\] \\[ \\text{Erro de Amostragem Relativo}: \\quad E_r = \\pm \\frac{t \\cdot s_{\\bar{x}(st)}}{\\bar{x}_{(st)}} \\cdot 100 \\] \\[ \\text{Intervalo de confian\u00e7a para a M\u00e9dia Estratificada}: \\quad IC \\left[ \\bar{x}_{(st)} - (t \\cdot s_{\\bar{x}(st)}) \\leq \\bar{X} \\leq \\bar{x}_{(st)} + (t \\cdot s_{\\bar{x}(st)}) \\right] = P \\] \\[ \\text{Total por Estrato}: \\quad \\hat{X}_h = N_h \\cdot \\bar{x}_h \\] \\[ \\text{Total da Popula\u00e7\u00e3o}: \\quad \\hat{X} = \\sum_{h=1}^{L} \\hat{X}_h = N \\cdot \\bar{x}_{st} \\] \\[ \\text{Intervalo de Confian\u00e7a para o Total}: \\quad IC\\left[ \\hat{X} - N(t \\cdot s_{\\bar{x}(st)}) \\leq X \\leq \\hat{X} + N(t \\cdot s_{\\bar{x}(st)}) \\right] = P \\]"},{"location":"pt-BR/sampling_stats/#analise-de-variancia","title":"An\u00e1lise de vari\u00e2ncia","text":"\\[ \\text{Soma dos quadrados entre estratos}: \\operatorname{SQ}_e = \\sum_{h=1}^{L} n_h \\left( \\bar{x}_h - \\bar{x} \\right)^2 \\] \\[ \\text{Soma dos quadrados dentro dos estratos}\\operatorname{SQ}_d = \\sum_{h=1}^{L} \\sum_{i=1}^{n_h} \\left( x_{ih} - \\bar{x}_h \\right)^2 \\] \\[ \\text{Soma dos quadrados totais}\\operatorname{SQ}_t = \\sum_{h=1}^{L} \\sum_{i=1}^{n_h} \\left( x_{ih} - \\bar{x} \\right)^2 \\] \\[ \\text{Quadrado m\u00e9dio entre estratos}\\operatorname{QM}_e = \\frac{\\operatorname{SQ}_e}{\\operatorname{GL}_e} \\] \\[ \\text{Quadrado m\u00e9dio dentro dos estratos}\\operatorname{QM}_d = \\frac{\\operatorname{SQ}_d}{\\operatorname{GL}_d} \\] \\[ \\text{Valor de F calculado}\\operatorname{F} = \\frac{\\operatorname{QM}_e}{\\operatorname{QM}_d} \\]"},{"location":"pt-BR/sampling_stats/#notacao","title":"Nota\u00e7\u00e3o","text":"<ul> <li>\\( N \\): N\u00famero total de unidades da popula\u00e7\u00e3o ou n\u00famero potencial</li> <li>\\( n \\): N\u00famero de unidades amostradas ou medidas</li> <li>\\( n_h \\): N\u00famero de unidades amostradas ou medidas no estrato</li> <li>\\( t\\): Valor da distribui\u00e7\u00e3o t de Student</li> <li>\\( s_x^2 \\): Vari\u00e2ncia</li> <li>\\( s_h^2 \\): Vari\u00e2ncia do estrato h</li> <li>\\( s_{\\bar{x}(st)} \\): Erro padr\u00e3o da m\u00e9dia do estrato</li> <li>\\( W_h  \\): Propor\u00e7\u00e3o do estrato h na popula\u00e7\u00e3o</li> <li>\\( E \\): Limite do erro tolerato (%)</li> <li>\\( \\bar{x} \\): M\u00e9dia amostral</li> <li>\\( \\bar{x}_h \\): M\u00e9dia amostral do estrato</li> <li>\\( x_{ih} \\): volume da i-\u00e9sima parcela dentro do estrato h</li> </ul>"},{"location":"pt-BR/sampling_stats/#referencias","title":"Refer\u00eancias","text":"<p>SANQUETTA, C. R.; CORTE, A. P. D.; RODRIGUES, A. L.; WATZLAWICK, L. F. (2014). Invent\u00e1rios florestais: planejamento e execu\u00e7\u00e3o. Curitiba: Multi-Graphic, 406 p.</p>"},{"location":"pt-BR/stratifier/","title":"Estratificador","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Com este m\u00f3dulo, voc\u00ea poder\u00e1 obter assist\u00eancia no processo de estratifica\u00e7\u00e3o de seus plantios florestais. Utilize dados de invent\u00e1rio florestal para estratificar automaticamente as planta\u00e7\u00f5es, selecionando as vari\u00e1veis florestais que considera mais relevantes e utilizando um n\u00famero pr\u00e9-definido de estratos ou permitindo que o m\u00f3dulo determine o n\u00famero ideal de estratos.</p>"},{"location":"pt-BR/stratifier/#estratificacao-florestal-com-python","title":"Estratifica\u00e7\u00e3o Florestal com Python","text":"<p>O processo de estratifica\u00e7\u00e3o florestal requer o conhecimento de diversos fatores:</p> <ul> <li>Localiza\u00e7\u00e3o geogr\u00e1fica  </li> <li>Esp\u00e9cie florestal  </li> <li>Tipo de solo  </li> <li>Idade do povoamento  </li> <li>Finalidade dos produtos  </li> <li>Hist\u00f3rico de manejo  </li> </ul> <p>Nesse contexto, o m\u00f3dulo Python desenvolvido para estratifica\u00e7\u00e3o surge como uma ferramenta de apoio ao planejamento florestal, oferecendo uma vis\u00e3o inicial orientada por dados quantitativos.</p>"},{"location":"pt-BR/stratifier/#funcoes-principais","title":"Fun\u00e7\u00f5es Principais","text":"<p>O m\u00f3dulo inclui fun\u00e7\u00f5es como:</p> <ul> <li><code>stratify_kmeans</code> </li> <li><code>stratify_hierarchical</code></li> </ul> <p>Essas fun\u00e7\u00f5es utilizam algoritmos de agrupamento multivariado (<code>k-means</code> e hier\u00e1rquico, respectivamente) para identificar padr\u00f5es em vari\u00e1veis cont\u00ednuas, como:</p> <ul> <li>Di\u00e2metro m\u00e9dio  </li> <li>Altura m\u00e9dia  </li> <li>Volume por hectare  </li> <li>Idade  </li> <li>\u00cdndice de s\u00edtio  </li> </ul> <p>Os algoritmos agrupam as unidades amostrais em estratos homog\u00eaneos, que podem ser utilizados para:</p> <ul> <li>Invent\u00e1rio florestal  </li> <li>Aloca\u00e7\u00e3o amostral  </li> <li>Otimiza\u00e7\u00e3o do manejo  </li> </ul> <p>Importante</p> <p>Os resultados n\u00e3o substituem a interpreta\u00e7\u00e3o t\u00e9cnica especializada, mas fornecem uma base objetiva para an\u00e1lise explorat\u00f3ria, facilitando a tomada de decis\u00e3o em projetos florestais.</p>"},{"location":"pt-BR/stratifier/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":""},{"location":"pt-BR/stratifier/#estratificador_1","title":"Estratificador","text":"<pre><code>Stratifier(df, y, *train_columns, iterator=None)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados do invent\u00e1rio florestal. *groups_columns Colunas que ser\u00e3o utilizadas para a estratifica\u00e7\u00e3o. Apenas num\u00e9ricas. iterator (Opcional) A estratifica\u00e7\u00e3o ser\u00e1 realizada para cada <code>iterator</code>."},{"location":"pt-BR/stratifier/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>functions and parameters<pre><code>Stratifier.stratify_kmeans(k=None, k_method=None, max_k=100,\n                          show_plots=True, save_plots_dir=None)#(1)!\n\nStratifier.stratify_hierarchical(k=None, k_method=None, max_k=10,\n                                show_plots=True, save_plots_dir=None)#(2)!\n</code></pre></p> <ol> <li> <p>k = (Opcional) N\u00famero desejado de estratos. k_method = (Opcional) Caso <code>k</code> n\u00e3o seja especificado, define qual m\u00e9todo ser\u00e1 usado para determinar o n\u00famero de estratos. Op\u00e7\u00f5es: <code>elbow</code>, <code>silhouette</code>, <code>davies_bouldin</code>, <code>calinski_harabasz</code>. <code>Padr\u00e3o = \"elbow\"</code>. max_k = (Opcional) N\u00famero m\u00e1ximo de estratos a serem criados. show_plots = Se <code>true</code>, exibe o gr\u00e1fico de radar com os estratos gerados. save_plot_dir = (Opcional) Diret\u00f3rio para salvar os gr\u00e1ficos dos estratos gerados.  </p> </li> <li> <p>k = (Opcional) N\u00famero desejado de estratos. k_method = (Opcional) Caso <code>k</code> n\u00e3o seja especificado, define qual m\u00e9todo ser\u00e1 usado para determinar o n\u00famero de estratos. Op\u00e7\u00f5es: <code>elbow</code>, <code>silhouette</code>, <code>davies_bouldin</code>, <code>calinski_harabasz</code>. <code>Padr\u00e3o = \"elbow\"</code>. max_k = (Opcional) N\u00famero m\u00e1ximo de estratos a serem criados. show_plots = Se <code>true</code>, exibe o gr\u00e1fico de radar com os estratos gerados. save_plot_dir = (Opcional) Diret\u00f3rio para salvar os gr\u00e1ficos dos estratos gerados.  </p> </li> </ol> M\u00e9todos Descri\u00e7\u00e3o .stratify_kmeans() Realiza a estratifica\u00e7\u00e3o utilizando o algoritmo <code>K-Means</code>. .stratify_hierarchical() Realiza a estratifica\u00e7\u00e3o utilizando o algoritmo <code>Agglomerative Clustering</code>. <p>Importante</p> <p>Quando a vari\u00e1vel <code>k</code> n\u00e3o for definida, o algoritmo tentar\u00e1 determinar automaticamente o n\u00famero ideal de estratos utilizando o m\u00e9todo <code>elbow</code> como padr\u00e3o.</p> <p>Para selecionar outro m\u00e9todo de defini\u00e7\u00e3o autom\u00e1tica de <code>k</code>, basta informar o par\u00e2metro <code>method</code> com o nome do m\u00e9todo desejado. Os m\u00e9todos dispon\u00edveis s\u00e3o:</p> <ul> <li><code>elbow</code>: Baseado na an\u00e1lise da in\u00e9rcia para diferentes valores de <code>k</code>. Utiliza a segunda derivada para identificar o ponto de inflex\u00e3o.</li> <li><code>silhouette</code>: Utiliza o coeficiente de silhueta para avaliar a separa\u00e7\u00e3o entre os grupos. Maior valor indica melhor agrupamento.</li> <li><code>davies_bouldin</code>: Avalia a compacidade e separa\u00e7\u00e3o dos grupos. Quanto menor o \u00edndice, melhor o agrupamento.</li> <li><code>calinski_harabasz</code>: Utiliza a raz\u00e3o entre dispers\u00e3o entre grupos e dispers\u00e3o intra-grupo. Quanto maior o \u00edndice, melhor o agrupamento.</li> </ul> <p>Cada m\u00e9todo adapta-se melhor a diferentes caracter\u00edsticas dos dados. A escolha correta pode melhorar significativamente a qualidade dos estratos gerados.</p> <p>De mesmo modo, o usu\u00e1rio pode limitar o n\u00famero m\u00e1ximo de estratos por meio da vari\u00e1vel <code>max_k</code>, que define o maior valor de <code>k</code> a ser considerado durante o processo de avalia\u00e7\u00e3o autom\u00e1tica.</p>"},{"location":"pt-BR/stratifier/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Como exemplo, iremos usar uma adapta\u00e7\u00e3o dos dados obtidos por Arce e Dobner Jr. (2024) para Eucalyptus dunnii. A base de dados \u00e9 composta por 81 parcelas de 300m\u00b2, com idade igual a 7 anos.</p> <p> Fazer download do arquivo. </p> <p>stratifier_example.py<pre><code>from fptools.stratifier import Stratifier#(1)!\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>Stratifier</code>.  </li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>stratifier_example.py<pre><code>df = pd.read_excel(r'C:\\Seu\\diret\u00f3rio\\dados_stratifier.xlsx')#(1)!\n\ncolumns_to_check = [\n    'Idade', 'N_ha', 'd', 'h', 'Hdom',\n    'G_m2_ha', 'V_m3_ha',\n]#(2)!\n\nst = Stratifier(df, *columns_to_check)#(3)!\n\nstratified_df = st.stratify_kmeans(save_plots_dir=r\"C:\\Seu\\diret\u00f3rio\\para\\salvar\\os\\plots\")#(4)!\n</code></pre></p> <ol> <li>Carrega seu arquivo <code>xlsx</code> contendo os dados do invent\u00e1rio.  </li> <li>Cria uma lista chamada <code>columns_to_check</code> contendo as colunas que ser\u00e3o utilizadas para a estratifica\u00e7\u00e3o.  </li> <li>Cria a vari\u00e1vel <code>st</code> utilizando o dataframe <code>df</code>, passando as colunas <code>columns_to_check</code> como par\u00e2metros de estratifica\u00e7\u00e3o. Como  </li> <li>Realiza a estratifica\u00e7\u00e3o utilizando o algoritmo \"KMeans\", permitindo que o algoritmo determine o n\u00famero de estratos. Salva os resultados na vari\u00e1vel <code>stratified_df</code>. Salva o gr\u00e1fico de radar gerado no diret\u00f3rio informado. </li> </ol>"},{"location":"pt-BR/stratifier/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/stratifier/#tabelas","title":"Tabelas","text":"<p><code>stratified_df</code> (1)</p> <ol> <li>DataFrame inicial com uma coluna a mais chamada <code>Cluster</code>, que cont\u00e9m o n\u00famero do cluster que aquela linha de dados foi enquadrada, variando de 0 a <code>n</code>. </li> </ol> Chave_Parcela Idade N_ha d h Hdom G_m2_ha V_m3_ha S Cluster 14401109002_P1 7 866,67 16,63 16,09 16,50 19,43 112,77 15,44 0 14401109003_P2 7 866,67 16,55 15,02 16,47 19,91 110,36 15,17 0 14401110009_P3 7 600,00 16,96 14,07 15,32 13,92 64,83 14,71 0 1440817_P3 7 1066,67 16,45 14,53 16,49 24,24 129,46 14,61 0 1440818_P6 7 833,33 17,27 14,62 16,00 20,79 112,73 12,64 0"},{"location":"pt-BR/stratifier/#graficos","title":"Gr\u00e1ficos","text":"Exemplo de gr\u00e1fico de radar gerado pelo m\u00e9todo stratify_kmeans. O gr\u00e1fico demonstra onde se encontrada a m\u00e9dia normalizada de cada vari\u00e1vel para cada cluster."},{"location":"pt-BR/stratifier/#referencias","title":"Refer\u00eancias","text":"<p>ARCE, JULIO EDUARDO; DOBNER JR., MARIO. (2024).       Manejo e planejamento de florestas plantadas: com \u00eanfase nos g\u00eaneros Pinus e Eucalyptus. Curitiba, PR: Ed. dos Autores, 419p.</p> <p>KARCZMAREK, Pawel; KIERSZTYN, Adam; PEDRYCZ, Witold; AL, Ebru. K-Means-based isolation forest. Knowledge-Based Systems, Amsterdam, v. 195, p. 105659, 11 maio 2020. Dispon\u00edvel em:      https://doi.org/10.1016/j.knosys.2020.105659. Acesso em: 22 maio 2025.</p> <p>DETRINIDAD, E.; L\u00d3PEZ-RUIZ, V\u00edctor-Ra\u00fal. The Interplay of Happiness and Sustainability: A Multidimensional Scaling and K-Means Cluster Approach. Sustainability, v. 16, n. 22, p. 10068\u201310068, 19 nov. 2024.</p> <p>M\u00c4RZINGER, T.; KOT\u00cdK, J.; PFEIFER, C. Application of Hierarchical Agglomerative Clustering (HAC) for Systemic Classification of Pop-Up Housing (PUH) Environments. Applied Sciences, v. 11, n. 23, p. 11122, 24 nov. 2021.</p>"},{"location":"pt-BR/tree_volume_planning/","title":"Planejamento de cubagem","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Utilize dados de invent\u00e1rio florestal para planejar as \u00e1rvores a serem amostradas para medi\u00e7\u00e3o de volume, garantindo uma amostragem suficiente da planta\u00e7\u00e3o.</p>"},{"location":"pt-BR/tree_volume_planning/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>TreeVolumePlanning(df, tree_dbh, tree_height)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O DataFrame contendo os dados das \u00e1rvores. tree_dbh Nome da coluna que cont\u00e9m os valores do di\u00e2metro \u00e0 altura do peito (DAP) das \u00e1rvores (cent\u00edmetros). tree_height Nome da coluna que cont\u00e9m as alturas totais das \u00e1rvores (metros)."},{"location":"pt-BR/tree_volume_planning/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"methods and parameters<pre><code>  TreeVolumePlanning.resume(n_classes=None, dbh_classes=None, height_classes=None,\n                        only_height_classes=False, only_dbh_classes=False)#(1)!\n\n\n  TreeVolumePlanning.p_resume(n_classes=None, dbh_classes=None, height_classes=None,\n                          only_height_classes=False, only_dbh_classes=False)#(2)!\n\n\n  TreeVolumePlanning.get_values(n_measured_trees=10, n_classes=None, dbh_classes=None, height_classes=None,\n                            only_height_classes=False, only_dbh_classes=False)#(3)!\n</code></pre> <ol> <li> <p>n_classes = N\u00famero de classes \u00e0s quais os valores de altura e di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos.                                        dbh_classes = (Opcional) N\u00famero de classes de DAP \u00e0s quais os valores de di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   height_classes = (Opcional) N\u00famero de classes de altura \u00e0s quais os valores de altura ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   only_height_classes = (Opcional) Se <code>True</code>, apenas as classes de altura ser\u00e3o usadas para o resumo. only_dbh_classes = (Opcional) Se <code>True</code>, apenas as classes de DAP ser\u00e3o usadas para o resumo.  </p> </li> <li> <p>n_classes = N\u00famero de classes \u00e0s quais os valores de altura e di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos.                                        dbh_classes = (Opcional) N\u00famero de classes de DAP \u00e0s quais os valores de di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   height_classes = (Opcional) N\u00famero de classes de altura \u00e0s quais os valores de altura ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   only_height_classes = (Opcional) Se <code>True</code>, apenas as classes de altura ser\u00e3o usadas para o resumo. only_dbh_classes = (Opcional) Se <code>True</code>, apenas as classes de DAP ser\u00e3o usadas para o resumo.  </p> </li> <li> <p>n_measured_trees = N\u00famero de \u00e1rvores que ser\u00e3o selecionadas para cubagem. O padr\u00e3o \u00e9 10.   n_classes = N\u00famero de classes \u00e0s quais os valores de altura e di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos.                                        dbh_classes = (Opcional) N\u00famero de classes de DAP \u00e0s quais os valores de di\u00e2metro \u00e0 altura do peito ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   height_classes = (Opcional) N\u00famero de classes de altura \u00e0s quais os valores de altura ser\u00e3o submetidos. Se <code>None</code>, usa o valor de <code>n_classes</code>.   only_height_classes = (Opcional) Se <code>True</code>, apenas as classes de altura ser\u00e3o usadas para o resumo. only_dbh_classes = (Opcional) Se <code>True</code>, apenas as classes de DAP ser\u00e3o usadas para o resumo.  </p> </li> </ol> M\u00e9todos Descri\u00e7\u00e3o .resume() Retorna um resumo de quantas \u00e1rvores do dataframe fornecido est\u00e3o em cada classe. .p_resume() Retorna um resumo da porcentagem de \u00e1rvores do dataframe fornecido em cada classe. .get_values() Retorna um dataframe indicando quantas \u00e1rvores devem ser amostradas para medi\u00e7\u00e3o de volume em cada classe, com base na representa\u00e7\u00e3o percentual de cada classe no invent\u00e1rio total."},{"location":"pt-BR/tree_volume_planning/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considerando os dados resultantes da rela\u00e7\u00e3o hipsom\u00e9trica realizado no m\u00f3dulo anterior, iremos realizar o planejamento da cubagem das \u00e1rvores.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Parcela Dap (cm) H (m) Idade (anos) best_predicted_height selected_model p-1 22,28 0 15 21,91910582 y = y ~ x = 1/x^2 p-1 23,87 22,2 15 22,2 Real Height p-1 25,46 0 15 23,30513332 y = y ~ x = 1/x^2 p-1 25,78 24,5 15 24,5 Real Height p-1 26,74 22,2 15 22,2 Real Height <p>taper_functions_example.py<pre><code>from fptools.tree_volume_planning import TreeVolumePlanning#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>TreeVolumePlanning</code>.</li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>taper_functions_example.py<pre><code>df = pd.read_excel(r'C:\\Seu\\diretorio\\final_results.xlsx')#(1)!\n\ncub = TreeVolumePlanning(df ,'Dap (cm)','best_predicted_height')#(2)!\n\nresume = cub.resumen(n_classes=6)#(3)!\n\npercentual_resume = cub.p_resume(n_classes=6)#(4)!\n\nto_measure = cub.get_values(n_measured_trees=50, n_classes=6)#(5)!\n</code></pre></p> <ol> <li>Carrega seu arquivo <code>.xlsx</code>.</li> <li>Cria a vari\u00e1vel <code>cub</code> contendo a classe <code>TreeVolumePlanning</code>, utilizando a coluna <code>Dap (cm)</code> para os valores de DAP e a coluna <code>best_predicted_height</code> para os valores de altura.</li> <li>Retorna um resumo de quantas \u00e1rvores do dataframe fornecido est\u00e3o em cada classe (6 classes) e salva na vari\u00e1vel <code>resume</code>.</li> <li>Retorna um resumo da porcentagem de \u00e1rvores do dataframe fornecido em cada classe (6 classes) e salva na vari\u00e1vel <code>percentual_resume</code>.</li> <li>Retorna um dataframe indicando quantas \u00e1rvores devem ser amostradas para medi\u00e7\u00e3o de volume em cada classe, distribuindo as 50 \u00e1rvores (<code>n_measured_trees</code>) com base na representa\u00e7\u00e3o percentual de cada classe no invent\u00e1rio total, e salva na vari\u00e1vel <code>to_measure</code>.</li> </ol>"},{"location":"pt-BR/tree_volume_planning/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/tree_volume_planning/#tabelas","title":"Tabelas","text":"<p><code>resume</code>(1)</p> <ol> <li>DataFrame contendo quantas \u00e1rvores est\u00e3o em cada uma das 6 classes de altura e dap geradas.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 9 2 0 3 2 0 (27.108, 31.937] 3 13 4 4 1 0 (31.937, 36.765] 0 14 8 13 2 0 (36.765, 41.593] 0 5 9 21 1 0 (41.593, 46.422] 0 2 2 6 3 1 (46.422, 51.25] 0 0 3 0 2 2 <p><code>percentual_resume</code>(1)</p> <ol> <li>DataFrame contendo quantas \u00e1rvores est\u00e3o em cada uma das 6 classes de altura e dap geradas em valores percentuais em rela\u00e7\u00e3o ao total de \u00e1rvores.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 6,67 1,48 0,00 2,22 1,48 0,00 (27.108, 31.937] 2,22 9,63 2,96 2,96 0,74 0,00 (31.937, 36.765] 0,00 10,37 5,93 9,63 1,48 0,00 (36.765, 41.593] 0,00 3,70 6,67 15,56 0,74 0,00 (41.593, 46.422] 0,00 1,48 1,48 4,44 2,22 0,74 (46.422, 51.25] 0,00 0,00 2,22 0,00 1,48 1,48 <p><code>to_measure</code>(1)</p> <ol> <li>DataFrame contendo quantas \u00e1rvores (das 50 espec\u00edficadas em <code>n_measured_trees</code>) devem ser medidas em cada das 6 classes de altura e dap.</li> </ol> DBH classes H(21.904, 24.516] H(24.516, 27.113] H(27.113, 29.71] H(29.71, 32.306] H(32.306, 34.903] H(34.903, 37.5] (22.251, 27.108] 3 1 0 1 1 0 (27.108, 31.937] 1 5 2 1 0 0 (31.937, 36.765] 0 5 3 5 1 0 (36.765, 41.593] 0 2 3 8 0 0 (41.593, 46.422] 0 1 1 2 1 0 (46.422, 51.25] 0 0 1 0 1 1 <p>Desse modo o usu\u00e1rio obt\u00e9m quantas \u00e1rvores devem ser cubadas em cada classe de dap e altura.</p> <p>Sobre os intervalos de classe</p> <p>Os intervalos usam a seguinte nota\u00e7\u00e3o: - <code>(</code> indica que o valor n\u00e3o est\u00e1 inclu\u00eddo - <code>]</code> indica que o valor est\u00e1 inclu\u00eddo </p> <p>Por exemplo, o intervalo <code>(22.251, 27.108]</code> inclui valores maiores que 22.251 e menores ou iguais a 27.108.</p> <p>N\u00e3o \u00e9 obrigat\u00f3rio criar classes para altura e dap ao mesmo tempo, \u00e9 poss\u00edvel criar somente classes de altura ou somente classes de dap conforme exemplo abaixo:</p> <p>taper_functions_example.py<pre><code>to_measure = cub.get_values(n_measured_trees=50, dbh_classes=6,\n                            only_dbh_classes=True)#(1)!\n</code></pre></p> <ol> <li>Define que ser\u00e3o medidas 50 \u00e1rvores, separadas em 6 classes de dap somente.</li> </ol> DBH classes n_trees (22.25, 27.108] 6 (31.937, 36.765] 14 (46.422, 51.25] 3 (36.765, 41.593] 13 (27.108, 31.937] 9 (41.593, 46.422] 5 <p>Tamb\u00e9m \u00e9 poss\u00edvel criar n\u00fameros diferentes de classes para altura ou para dap, conforme exemplo abaixo:  </p> <p>taper_functions_example.py<pre><code>to_measure = cub.get_values(n_measured_trees=50, dbh_classes=6,\n                            height_classes=2)#(1)!\n</code></pre></p> <ol> <li>Define que ser\u00e3o medidas 50 \u00e1rvores, separadas em 6 classes de dap e 2 classes de altura.</li> </ol> DBH classes H(21.904, 29.71] H(29.71, 37.5] (22.251, 27.108] 4 2 (27.108, 31.937] 7 2 (31.937, 36.765] 8 6 (36.765, 41.593] 5 8 (41.593, 46.422] 2 4 (46.422, 51.25] 1 1"},{"location":"pt-BR/utils/","title":"Utils","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Este m\u00f3dulo cont\u00e9m fun\u00e7\u00f5es auxiliares que podem ser \u00fateis ao usu\u00e1rio durante o processamento e an\u00e1lise de dados florestais.</p>"},{"location":"pt-BR/utils/#funcoes-disponiveis","title":"Fun\u00e7\u00f5es Dispon\u00edveis","text":"<pre><code>from fptools.utils import stats_summary, get_metrics, plot_x_y\n</code></pre>"},{"location":"pt-BR/utils/#stats_summary","title":"<code>stats_summary</code>","text":"<p>Gera um resumo estat\u00edstico para as colunas num\u00e9ricas especificadas de um DataFrame.</p> <p>Par\u00e2metros: - <code>df</code>: DataFrame do pandas com os dados de entrada. - <code>*args</code>: Nomes das colunas num\u00e9ricas a serem resumidas. - <code>ignore_zeros</code> (bool): Se <code>True</code>, ignora os valores zero no c\u00e1lculo. - <code>language</code> (str): Define o idioma das colunas de sa\u00edda. Aceita <code>\"en\"</code> ou <code>\"pt-br\"</code>.  </p> <p>Sa\u00edda: - DataFrame com estat\u00edsticas: m\u00e9dia, m\u00ednimo, m\u00e1ximo, desvio padr\u00e3o, coeficiente de varia\u00e7\u00e3o (CV), quartis (Q1, Q2, Q3) e intervalo interquart\u00edlico (IQR).</p>"},{"location":"pt-BR/utils/#get_metrics","title":"<code>get_metrics</code>","text":"<p>Calcula m\u00e9tricas de avalia\u00e7\u00e3o de modelos preditivos.</p> <p>Par\u00e2metros: - <code>real_y</code>: Lista ou array com os valores reais. - <code>predicted_y</code>: Lista ou array com os valores previstos.  </p> <p>M\u00e9tricas calculadas: - MAE: Erro absoluto m\u00e9dio. - MAPE: Erro percentual absoluto m\u00e9dio. - MSE: Erro quadr\u00e1tico m\u00e9dio. - RMSE: Raiz do erro quadr\u00e1tico m\u00e9dio. - R\u00b2: Coeficiente de determina\u00e7\u00e3o. - Vari\u00e2ncia explicada. - Erro m\u00e9dio (tend\u00eancia do modelo).  </p> <p>Sa\u00edda: - Tupla com os valores das m\u00e9tricas na ordem: <code>(mae, mape, mse, rmse, r_squared, explained_variance, mean_error)</code>.  </p>"},{"location":"pt-BR/utils/#plot_x_y","title":"<code>plot_x_y</code>","text":"<p>Gera um gr\u00e1fico de dispers\u00e3o (scatter plot) para uma vari\u00e1vel <code>x</code> e uma ou mais vari\u00e1veis <code>y</code>.</p> <p>Par\u00e2metros: - <code>x</code>: Lista ou array com os valores do eixo X. - <code>*ys</code>: Uma ou mais listas ou arrays com os valores do eixo Y.  </p> <p>Comportamento: - Cada s\u00e9rie <code>y</code> \u00e9 representada com um estilo distinto de marcador e cor. - Os eixos iniciam em zero, h\u00e1 grade no fundo e legenda para cada s\u00e9rie <code>y</code>.  </p> <p>Sa\u00edda: - Exibe o gr\u00e1fico na tela.  </p>"},{"location":"pt-BR/volumetrics/","title":"Volumetria","text":"<p>Warning</p> <p>Esta biblioteca est\u00e1 em desenvolvimento, nenhuma das solu\u00e7\u00f5es apresentadas est\u00e1 dispon\u00edvel para download.</p> <p>Processe dados de invent\u00e1rio florestal e ajuste equa\u00e7\u00f5es volum\u00e9tricas e fun\u00e7\u00f5es de afilamento para uso posterior.</p>"},{"location":"pt-BR/volumetrics/#parametros-da-classe","title":"Par\u00e2metros da Classe","text":"<pre><code>Volumetrics(df, tree_identifier, tree_height, tree_dbh,\n          segment_height, segment_diameter, tree_bark)\n</code></pre> Par\u00e2metros Descri\u00e7\u00e3o df O dataframe contendo os dados de cubagem. tree_identifier Nome da coluna que cont\u00e9m os identificadores \u00fanicos das \u00e1rvores. tree_height Nome da coluna que cont\u00e9m as alturas totais das \u00e1rvores (metros). tree_dbh Nome da coluna contendo os valores do di\u00e2metro \u00e0 altura do peito (DAP) das \u00e1rvores (cent\u00edmetros). segment_height (Opcional) Nome da coluna contendo as alturas dos segmentos cubados das \u00e1rvores (metros). Obrigat\u00f3rio para o m\u00e9todo <code>fit_taper_functions()</code>. segment_diameter (Opcional) Nome da coluna contendo os di\u00e2metros dos segmentos cubados das \u00e1rvores (cent\u00edmetros). Obrigat\u00f3rio para o m\u00e9todo <code>fit_taper_functions()</code>. tree_bark (Opcional) Nome da coluna contendo os valores da espessura da casca das \u00e1rvores (cent\u00edmetros). Se <code>tree_bark == None</code>, retorna apenas volumes com casca no m\u00e9todo <code>get_volumes()</code>."},{"location":"pt-BR/volumetrics/#metodos-da-classe","title":"M\u00e9todos da Classe","text":"<p>functions and parameters<pre><code>  Volumetrics.get_volumes(iterator=None)#(1)!\n\n  Volumetrics.fit_taper_functions(models, iterator, save_dir = None)#(2)!\n\n  Volumetrics.fit_volumetric_functions(models, iterator, vol_column,\n                                       save_dir = None)#(3)!\n\n  Volumetrics.get_individual_diameter(hi, tree_height, tree_dbh)#(4)!\n\n  Volumetrics.get_individual_taper_volume(tree_height, tree_dbh, stump=0.1)#(5)!\n\n  Volumetrics.get_individual_volume(tree_height, tree_dbh)#(6)!\n</code></pre></p> <ol> <li>iterator = (Opcional) Nome de uma coluna a ser usada como iterador. Pode ser o nome da fazenda, nome da parcela, c\u00f3digo ou qualquer identificador \u00fanico.  </li> <li> <p>models = (Opcional) Lista de modelos a serem ajustados! Se <code>models == None</code>, utiliza todos os modelos dispon\u00edveis.     Modelos dispon\u00edveis: <code>['schoepfer', 'bi', 'kozak','johnson', 'matte', 'ann']</code> iterator = (Opcional) Nome de uma coluna a ser usada como iterador. Pode ser o nome da fazenda, nome da parcela, c\u00f3digo ou qualquer identificador \u00fanico. save_dir = (Opcional) Diret\u00f3rio para salvar os par\u00e2metros da fun\u00e7\u00e3o ajustada e o modelo ANN.  </p> </li> <li> <p>models = (Opcional) Lista de modelos a serem ajustados! Se <code>models == None</code>, utiliza todos os modelos dispon\u00edveis.                                      iterator = (Opcional) Nome de uma coluna a ser usada como iterador. Pode ser o nome da fazenda, nome da parcela, c\u00f3digo ou qualquer identificador \u00fanico. vol_column = (Opcional) Nome da coluna com os valores de volume. Se <code>vol_column == None</code>, utiliza os volumes obtidos pelo m\u00e9todo <code>get_volumes()</code> para ajustar as fun\u00e7\u00f5es volum\u00e9tricas. save_dir = (Opcional) Diret\u00f3rio para salvar os par\u00e2metros da fun\u00e7\u00e3o ajustada e o modelo ANN.  </p> </li> <li> <p>hi = Fra\u00e7\u00e3o da altura da \u00e1rvore para a qual se deseja obter o di\u00e2metro (metros). tree_height = Altura total da \u00e1rvore (metros). tree_dbh = Di\u00e2metro \u00e0 altura do peito (DAP) da \u00e1rvore (cent\u00edmetros).  </p> </li> <li> <p>tree_height = Altura total da \u00e1rvore (metros). tree_dbh = Di\u00e2metro \u00e0 altura do peito (DAP) da \u00e1rvore (cent\u00edmetros). stump = Altura do toco (metros). Por padr\u00e3o, usa <code>stump = 0.1</code>.  </p> </li> <li> <p>tree_height = Altura total da \u00e1rvore (metros). tree_dbh = Di\u00e2metro \u00e0 altura do peito (DAP) da \u00e1rvore (cent\u00edmetros).  </p> </li> </ol> M\u00e9todos Descri\u00e7\u00e3o .get_volumes() Retorna o volume de cada segmento cubado e o volume total de cada \u00e1rvore, separado por <code>tree_identifier</code>. Se <code>tree_bark == None</code>, retorna apenas o volume com casca; caso contr\u00e1rio, retorna o volume com e sem casca. .fit_taper_functions() Ajusta os modelos dispon\u00edveis de fun\u00e7\u00f5es de afilamento. Salva um arquivo <code>.json</code> com os coeficientes para cada modelo ajustado e um arquivo <code>.pkl</code> para os modelos de ANN ajustados. .get_individual_diameter() Retorna um dataframe pandas com o di\u00e2metro em uma altura <code>hi</code> da \u00e1rvore para cada modelo de afilamento ajustado. .get_individual_taper_volume() Retorna um DataFrame pandas com o volume estimado para a altura e di\u00e2metro \u00e0 altura do peito fornecidos para cada fun\u00e7\u00e3o de afilamento ajustada. Utiliza a integra\u00e7\u00e3o das fun\u00e7\u00f5es de afilamento para obter o resultado. .fit_volumetric_functions() Ajusta os modelos volum\u00e9tricos dispon\u00edveis. Salva um arquivo <code>.json</code> com os coeficientes para cada modelo ajustado e um arquivo <code>.pkl</code> para os modelos de ANN ajustados. .get_individual_volume() Retorna um DataFrame pandas com o volume estimado para a altura e di\u00e2metro \u00e0 altura do peito fornecidos para cada fun\u00e7\u00e3o volum\u00e9trica ajustada."},{"location":"pt-BR/volumetrics/#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>Considere uma base de dados de cubagem composta por 50 \u00e1rvores do g\u00eanero Eucalyptus, nas quais os di\u00e2metros foram mensurados nas alturas de 0,1 metro, 0,6 metro, 1,30 metro e, a partir desse ponto, em intervalos de 2 metros ao longo do fuste.</p> <p> Fazer download do arquivo. </p> <p>Primeiras 5 linhas do arquivo:</p> Fazenda arvore_n dap (cm) altura_total (m) se\u00e7\u00e3o (m) diametro_c_casca (cm) diametro_s_casca (cm) casca (cm) Fazenda 1 1 24,8 28,0 0,1 30,05 26,51 1,74 Fazenda 1 1 24,8 28,0 0,6 26,55 23,15 1,96 Fazenda 1 1 24,8 28,0 1,3 24,75 21,93 1,94 Fazenda 1 1 24,8 28,0 2,0 23,85 21,48 1,90 Fazenda 1 1 24,8 28,0 4,0 21,40 19,30 1,11 <p>taper_functions_example.py<pre><code>from fptools.Volumetrics import Volumetrics#(1)!\n\nimport pandas as pd#(2)!\n</code></pre></p> <ol> <li>Importa a classe <code>Volumetrics</code>.  </li> <li>Importa o <code>pandas</code> para manipula\u00e7\u00e3o de dados.</li> </ol> <p>taper_functions_example.py<pre><code>dados = pd.read_excel(r'C:\\seu\\diret\u00f3rio\\exemplo_volumetrics.xlsx')#(1)!\n\nvol = Volumetrics(df=dados, tree_identifier='arvore_n',\n                  tree_height='altura_total (m)',\n                  tree_dbh ='dap (cm)',\n                  segment_height='se\u00e7\u00e3o (m)',\n                  segment_diameter= 'diametro_c_casca (cm)',\n                  tree_bark='casca (cm)')#(2)!\n\ncalculated_volumes_df = vol.get_volumes(iterator=\"Fazenda\")#(3)!\ncalculated_volumes_df.to_excel(\"exemplo_volumetrics_with_vol.xlsx\",\n                               index=False)#(4)!\n\nmetrics_taper = vol.fit_taper_functions(save_dir=\"seu/diret\u00f3rio/para/salvar\",iterator=\"Fazenda\")#(5)!\n\nindividual_diameter = vol.get_individual_diameter(10, 31, 30)#(6)!\n\ntaper_volume = vol.get_individual_taper_volume(35, 32, stump=0.15)#(7)!\n\nmetrics_vol = vol.fit_volumetric_functions(save_dir=output_path, iterator=\"Fazenda\")#(8)!\n\nindividual_volume = vol.get_individual_volume(tree_height=21.8, tree_dbh=19)#(9)!\n</code></pre></p> <ol> <li>Carrega seu arquivo <code>.xlsx</code>.</li> <li>Cria a vari\u00e1vel <code>vol</code> contendo a classe <code>Volumetrics</code>.</li> <li>Calcula os volumes para cada \u00e1rvore e segmento, separando por <code>iterator</code> e salva os resultados na vari\u00e1vel <code>calculated_volumes_df</code>.    Ser\u00e1 retornado o DataFrame incial com as seguintes colunas adicionais: <code>segment_vol_with_bark</code>,<code>segment_vol_without_bark</code>,<code>tree_vol_with_bark</code>,<code>tree_vol_without_bark</code>,<code>bark_factor</code> e <code>mean_bark_factor</code>.       </li> <li>Salva o DataFrame com os volumes calculados em <code>exemplo_volumetrics_with_vol.xlsx</code>.   </li> <li>Ajusta as fun\u00e7\u00f5es de afilamento e rede neural artificial para cada <code>iterator</code> e salva as m\u00e9tricas de desempenho na vari\u00e1vel <code>metrics_taper</code>. Isso criar\u00e1 um arquivo <code>.json</code> com os coeficientes dos modelos e arquivos <code>.pkl</code> para os modelos ajustados de RNA e salvar\u00e1 os arquivos gerados em <code>save_dir</code>.</li> <li>Obt\u00e9m o di\u00e2metro a 10 metros de uma \u00e1rvore com altura total de 31 metros e di\u00e2metro \u00e0 altura do peito (DAP) de 30 cent\u00edmetros usando os ajustes realizados e salva na vari\u00e1vel <code>individual_diameter</code>.</li> <li>Obt\u00e9m os volumes calculados pela integra\u00e7\u00e3o das fun\u00e7\u00f5es de afilamento para uma \u00e1rvore com altura de 35 metros, di\u00e2metro \u00e0 altura do peito de 32 cent\u00edmetros, considerando uma altura de toco de 0,15 metros e salve na vari\u00e1vel <code>taper_volume</code>.</li> <li>Ajusta todas fun\u00e7\u00f5es volum\u00e9tricas para cada <code>iterator</code> e salva em <code>save_dir</code>, salvando as m\u00e9tricas na vari\u00e1vel <code>metrics_vol</code>. Como nenhuma coluna de volumes <code>vol_column</code> foi fornecida, usar\u00e1 o volume obtido pelo m\u00e9todo <code>get_volumes</code> para ajuste dos volumes.</li> <li>Calcula o volume de uma \u00e1rvore de 21,8 metros de altura e 19 cent\u00edmetros de dap usando todas as fun\u00e7\u00f5es volum\u00e9tricas e salva na vari\u00e1vel <code>individual_volume</code>.</li> </ol>"},{"location":"pt-BR/volumetrics/#saidas","title":"Sa\u00eddas","text":""},{"location":"pt-BR/volumetrics/#tabelas","title":"Tabelas","text":"<p><code>calculated_volumes_df</code>(1)</p> <ol> <li>DataFrame incial com as seguintes colunas adicionais: <code>segment_vol_with_bark</code>,<code>segment_vol_without_bark</code>,<code>tree_vol_with_bark</code>,<code>tree_vol_without_bark</code>,<code>bark_factor</code> e <code>mean_bark_factor</code>.       </li> </ol> Fazenda arvore_n dap (cm) altura_total (m) se\u00e7\u00e3o (m) diametro_c_casca (cm) diametro_s_casca (cm) casca (cm) segment_vol_with_bark segment_vol_without_bark tree_vol_with_bark tree_vol_without_bark bark_factor mean_bark_factor Fazenda 1 1 24,84076433 28 0,1 30,05 26,51 1,74 0,007092165 0,005544635 0,559879936 0,387477996 0,692073373 0,682430303 Fazenda 1 1 24,84076433 28 0,6 26,55 23,15 1,96 0,031450877 0,023341421 0,559879936 0,387477996 0,692073373 0,682430303 Fazenda 1 1 24,84076433 28 1,3 24,75 21,93 1,94 0,036171179 0,026055822 0,559879936 0,387477996 0,692073373 0,682430303 Fazenda 1 1 24,84076433 28 2,0 23,85 21,48 1,90 0,032463883 0,02310445 0,559879936 0,387477996 0,692073373 0,682430303 Fazenda 1 1 24,84076433 28 4,0 21,40 19,30 1,11 0,080407591 0,065402308 0,559879936 0,387477996 0,692073373 0,682430303 Fazenda 1 1 24,84076433 28 6,0 20,50 19,17 1,81 0,068942643 0,047175553 0,559879936 0,387477996 0,692073373 0,682430303 <p>Sobre as colunas geradas</p> <ul> <li><code>segment_vol_with_bark</code>: Volume do segmento do fuste com casca, calculado entre duas se\u00e7\u00f5es consecutivas de medi\u00e7\u00e3o.</li> <li><code>segment_vol_without_bark</code>: Volume do segmento do fuste sem casca, calculado entre duas se\u00e7\u00f5es consecutivas de medi\u00e7\u00e3o.</li> <li><code>tree_vol_with_bark</code>: Volume total da \u00e1rvore com casca, obtido pela soma dos volumes de todos os segmentos com casca.</li> <li><code>tree_vol_without_bark</code>: Volume total da \u00e1rvore sem casca, obtido pela soma dos volumes de todos os segmentos sem casca.</li> <li><code>bark_factor</code>: Fator de casca do segmento, calculado como a raz\u00e3o entre o volume com casca e o volume sem casca para aquele segmento.</li> <li><code>mean_bark_factor</code>: Fator de casca m\u00e9dio da \u00e1rvore, calculado como a m\u00e9dia dos fatores de casca de todos os segmentos.</li> </ul> <p><code>metrics_taper</code>(1)</p> <ol> <li>DataFrame com as m\u00e9tricas de avalia\u00e7\u00e3o geradas para cada <code>iterator</code> e modelo de afilamento e rede neural artificial, incluindo a pontua\u00e7\u00e3o atribu\u00edda a cada modelo com base em seu desempenho.</li> </ol> iterator model MAE MAPE MSE RMSE R squared Explained Var Mean Error score Fazenda 1 kozak 0,580666 5,718699 0,572843 0,756864 0,994621 0,994621 -0,000167 10 Fazenda 1 bi 0,635942 5,972947 0,643045 0,801901 0,993962 0,994016 -0,075560 9 Fazenda 1 ann 0,576319 5,651187 0,560707 0,748804 0,994735 0,994739 0,020658 8 Fazenda 1 schoepfer 0,769151 7,532993 1,033545 1,016634 0,990295 0,990356 -0,080168 7 Fazenda 1 johnson 1,078775 10,108434 1,978243 1,406500 0,981425 0,981571 -0,124507 6 Fazenda 1 matte 1,424262 14,718423 3,337336 1,826838 0,968664 0,969344 0,269282 5 Fazenda 2 ann 1,342497 7,238220 3,318417 1,821652 0,988023 0,988023 0,001891 10 Fazenda 2 kozak 1,350729 7,357823 3,468079 1,862278 0,987483 0,987483 -0,002186 9 Fazenda 2 bi 1,374535 7,880664 3,483492 1,866412 0,987427 0,987435 -0,045863 8 Fazenda 2 schoepfer 1,678529 8,785657 4,895865 2,212660 0,982329 0,982373 0,110280 7 Fazenda 2 matte 2,180025 13,928099 7,414827 2,723018 0,973238 0,974475 0,585444 6 Fazenda 2 johnson 2,216439 12,099970 9,165003 3,027376 0,966921 0,966956 0,097858 5 <p><code>individual_diameter</code>(1)</p> <ol> <li>DataFrame com os di\u00e2metros individuais estimados pelas fun\u00e7\u00f5es de afilamento e rede neural artificial para cada <code>iterator</code> e modelo de afilamento para uma \u00e1rvore de 31 metros de altura, 30 cent\u00edmetros de DAP, em uma altura de 10 metros.</li> </ol> iterator model Predicted_diameter (cm) Fazenda 1 schoepfer 22,75296935 Fazenda 1 bi 22,35954058 Fazenda 1 kozak 22,45146956 Fazenda 1 johnson 23,41945889 Fazenda 1 matte 22,83651908 Fazenda 1 ann 23,33443805 Fazenda 2 schoepfer 21,48912862 Fazenda 2 bi 23,08526645 Fazenda 2 kozak 22,40805692 Fazenda 2 johnson 22,46401882 Fazenda 2 matte 21,43830806 Fazenda 2 ann 23,71472482 <p><code>taper_volume</code>(1)</p> <ol> <li>DataFrame com os volumes estimados pela integra\u00e7\u00e3o das fun\u00e7\u00f5es de afilamento e rede neural artificial para cada <code>iterator</code> e modelo de afilamento para uma \u00e1rvore de 35 metros de altura, 32 cent\u00edmetros de DAP.</li> </ol> iterator model Predicted_volume (m\u00b3) Fazenda 1 schoepfer 1,166056704 Fazenda 1 bi 1,143061281 Fazenda 1 kozak 1,165284829 Fazenda 1 johnson 1,201758409 Fazenda 1 matte 1,150231088 Fazenda 1 ann 1,326654958 Fazenda 2 schoepfer 1,055148596 Fazenda 2 bi 1,179288353 Fazenda 2 kozak 1,147756782 Fazenda 2 johnson 1,108690858 Fazenda 2 matte 1,066598472 Fazenda 2 ann 1,178903371 <p><code>metrics_vol</code>(1)</p> <ol> <li>DataFrame com as m\u00e9tricas de avalia\u00e7\u00e3o geradas para cada <code>iterator</code>, modelo volum\u00e9trico e rede neural artificial, incluindo a pontua\u00e7\u00e3o atribu\u00edda a cada modelo com base em seu desempenho.</li> </ol> iterator model MAE MAPE MSE RMSE R squared Explained Var Mean Error score Fazenda 1 honner 0,028987 6,510184 0,001409 0,037535 0,998022 0,998143 -0,009291 10 Fazenda 1 ann 0,020789 5,362507 0,000713 0,026703 0,998999 0,998999 -0,000569 9 Fazenda 1 takata 0,027501 5,250705 0,001291 0,035934 0,998187 0,998214 -0,004318 8 Fazenda 1 spurr_log 0,026612 4,438766 0,001235 0,035137 0,998267 0,998277 -0,002731 7 Fazenda 1 schumacher_hall 0,027584 4,649301 0,001203 0,034683 0,998311 0,998321 -0,002636 6 Fazenda 1 meyer 0,025136 6,229777 0,001112 0,033346 0,998439 0,998439 0,000000 5 Fazenda 1 stoate 0,026301 6,530368 0,001158 0,034029 0,998374 0,998374 0,000000 4 Fazenda 1 spurr 0,026008 9,348743 0,001177 0,034306 0,998348 0,998348 0,000000 3 Fazenda 1 naslund 0,024859 11,898225 0,001020 0,031930 0,998569 0,998571 0,001263 2 Fazenda 1 ogaya 0,410646 151,1923 0,213968 0,462567 0,699650 0,719168 -0,117918 1 Fazenda 2 naslund 0,153069 6,603060 0,048230 0,219612 0,974528 0,974529 -0,001349 10 Fazenda 2 schumacher_hall 0,160824 9,781453 0,048410 0,220023 0,974433 0,974447 -0,005183 9 Fazenda 2 spurr_log 0,160540 9,932109 0,048446 0,220105 0,974414 0,974428 -0,005270 8 Fazenda 2 takata 0,159037 6,922203 0,049057 0,221488 0,974091 0,974091 -0,000386 7 Fazenda 2 ann 0,150892 5,508166 0,043498 0,208562 0,977027 0,977053 0,007015 6 Fazenda 2 meyer 0,155147 8,411204 0,047824 0,218687 0,974742 0,974742 0,000000 5 Fazenda 2 stoate 0,161432 14,918844 0,048986 0,221328 0,974129 0,974129 0,000000 4 Fazenda 2 spurr 0,181962 28,583026 0,055897 0,236425 0,970479 0,970479 0,000000 3 Fazenda 2 honner 0,189541 6,829942 0,062964 0,250927 0,966746 0,967397 0,035110 2 Fazenda 2 ogaya 0,430466 40,223791 0,284181 0,533086 0,849913 0,850523 0,034001 1 <p><code>individual_volume</code>(1)</p> <ol> <li>DataFrame com os volumes estimados pelas fun\u00e7\u00f5es volum\u00e9tricas e rede neural artificial para cada <code>iterator</code> para uma \u00e1rvore de 21,8 metros de altura, 19 cent\u00edmetros de DAP.</li> </ol> iterator model Predicted_volume (m\u00b3) Fazenda 1 spurr 0,241827831 Fazenda 1 schumacher_hall 0,248607044 Fazenda 1 honner 0,262977386 Fazenda 1 ogaya 0,860375777 Fazenda 1 naslund 0,245824632 Fazenda 1 takata 0,255820523 Fazenda 1 spurr_log 0,251481659 Fazenda 1 meyer 0,228396501 Fazenda 1 stoate 0,241410100 Fazenda 1 ann 0,271805848 Fazenda 2 spurr 0,421606899 Fazenda 2 schumacher_hall 0,332105882 Fazenda 2 honner 0,232727813 Fazenda 2 ogaya 0,939382897 Fazenda 2 naslund 0,324612548 Fazenda 2 takata 0,287273333 Fazenda 2 spurr_log 0,336234242 Fazenda 2 meyer 0,200621992 Fazenda 2 stoate 0,242861095 Fazenda 2 ann 0,284503571"},{"location":"pt-BR/volumetrics/#arquivos-json","title":"Arquivos <code>.json</code>","text":"<p>Para cada fun\u00e7\u00e3o de afilamento e fun\u00e7\u00e3o volum\u00e9trica, s\u00e3o gerados arquivos .json contendo os coeficientes estimados de cada modelo. Um arquivo <code>.json</code> individual \u00e9 criado para cada iterator, nomeado de acordo com o respectivo identificador.</p> <ul> <li>taper_functions_coefficients_Fazenda 1.json</li> <li>taper_functions_coefficients_Fazenda 2.json</li> <li>volumetrics_functions_coefficients_Fazenda 1.json</li> <li>volumetrics_functions_coefficients_Fazenda 2.json</li> </ul>"},{"location":"pt-BR/volumetrics/#arquivos-pkl","title":"Arquivos <code>.pkl</code>","text":"<p>Da mesma forma, para cada rede neural artificial ajustada para afilamento ou predi\u00e7\u00e3o de volume, \u00e9 gerado um arquivo <code>.pkl</code> contendo o modelo treinado, nomeado de acordo com o respectivo iterator.  </p> <ul> <li>taper_model_ann_Fazenda 1.pkl</li> <li>taper_model_ann_Fazenda 2.pkl</li> <li>volumetric_ann_Fazenda 1.pkl</li> <li>volumetric_ann_Fazenda 2.pkl</li> </ul> <p>Embora n\u00e3o seja poss\u00edvel visualizar diretamente esse tipo de arquivo, ele armazena os par\u00e2metros da rede neural e suas configura\u00e7\u00f5es internas, que ser\u00e3o utilizados posteriormente na gera\u00e7\u00e3o dos sortimentos.</p>"},{"location":"pt-BR/volumetrics/#funcoes-de-afilamento-disponiveis","title":"Fun\u00e7\u00f5es de afilamento dispon\u00edveis","text":""},{"location":"pt-BR/volumetrics/#notacao","title":"Nota\u00e7\u00e3o","text":"<ul> <li>\\( \u03b2_n \\): Par\u00e2metros ajustados</li> <li>\\( p \\): Par\u00e2metro geom\u00e9trico/auxiliar (inicialmente 0.1)</li> <li>\\( d_i \\): Di\u00e2metro (cm)</li> <li>\\( \\text{dap} \\): Di\u00e2metro \u00e0 altura do peito (cm)</li> <li>\\( H \\): Altura total (m)</li> <li>\\( h_i \\): Altura do segmento (m)</li> </ul>"},{"location":"pt-BR/volumetrics/#rede-neural-artificial","title":"Rede Neural Artificial","text":"<p>Ao selecionar o modelo 'RNA', 6 diferentes estruturas de redes neurais artificiais ser\u00e3o testadas. Apenas o resultado de 1 modelo ser\u00e1 retornado. O modelo retornado ser\u00e1 selecionado pela fun\u00e7\u00e3o de classifica\u00e7\u00e3o. Para o modelo 'RNA', utiliza-se o m\u00f3dulo sklearn.neural_network.MLPRegressor.</p> --- title: Par\u00e2metros RNA --- classDiagram     direction LR      class MLPRegressor {       \u00c9pocas: 3000       Fun\u00e7\u00e3o de ativa\u00e7\u00e3o: logistic       Solver: lbfgs       Tamanho do lote: din\u00e2mico       Taxa de aprendizado inicial: 0.1       Modo da taxa de aprendizado: adaptive     }      class Modelo-0 {       Camadas ocultas: (15, 25, 20, 30, 10)     }     class Modelo-1 {       Camadas ocultas: (35, 10, 25, 35, 15)     }     class Modelo-2 {       Camadas ocultas: (25, 15, 30, 20)     }     class Modelo-3 {       Camadas ocultas: (15, 35, 45)     }     class Modelo-4 {       Camadas ocultas: (35, 10, 25, 35, 15)     }     class Modelo-5 {       Camadas ocultas: (35, 10, 25, 35, 15, 20, 15, 30)     }      MLPRegressor &lt;|-- Modelo-0     MLPRegressor &lt;|-- Modelo-1     MLPRegressor &lt;|-- Modelo-2     MLPRegressor &lt;|-- Modelo-3     MLPRegressor &lt;|-- Modelo-4     MLPRegressor &lt;|-- Modelo-5"},{"location":"pt-BR/volumetrics/#modelos-volumetricos-disponiveis","title":"Modelos volum\u00e9tricos dispon\u00edveis","text":""},{"location":"pt-BR/volumetrics/#spurr","title":"<li>spurr</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot (\\text{dap}^2) \\cdot H \\]"},{"location":"pt-BR/volumetrics/#schumacher_hall","title":"<li>schumacher_hall</li>","text":"\\[ \\operatorname{V} = b_0 \\cdot (\\text{dap}^{b_1}) \\cdot (H^{b_2}) \\]"},{"location":"pt-BR/volumetrics/#honner","title":"<li>honner</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dap}^2}{b_1 \\cdot \\left(\\frac{1}{H}\\right)} \\]"},{"location":"pt-BR/volumetrics/#ogaya","title":"<li>ogaya</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dap}^2}{b_1 \\cdot H} \\]"},{"location":"pt-BR/volumetrics/#stoate","title":"<li>stoate</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot \\text{dap}^2 + b_2 \\cdot \\text{dap}^2 \\cdot H + b_3 \\cdot H \\]"},{"location":"pt-BR/volumetrics/#naslund","title":"<li>naslund</li>","text":"\\[ \\operatorname{V} = b_1 \\cdot \\text{dap}^2 + b_2 \\cdot \\text{dap}^2 \\cdot H + b_3 \\cdot \\text{dap} \\cdot H^2 + b_4 \\cdot H^2 \\]"},{"location":"pt-BR/volumetrics/#takata","title":"<li>takata</li>","text":"\\[ \\operatorname{V} = \\frac{\\text{dap}^2 \\cdot H}{b_0 + b_1 \\cdot \\text{dap}} \\]"},{"location":"pt-BR/volumetrics/#spurr_log","title":"<li>spurr_log</li>","text":"\\[ \\operatorname{V} = \\exp(b_0 + b_1 \\cdot \\log(\\text{dap}^2 \\cdot H)) \\]"},{"location":"pt-BR/volumetrics/#meyer","title":"<li>meyer</li>","text":"\\[ \\operatorname{V} = b_0 + b_1 \\cdot \\text{dap}^2 + b_2 \\cdot \\text{dap} + b_3 \\cdot \\text{dap} \\cdot H + b_4 \\cdot \\text{dap}^2 \\cdot H \\]"},{"location":"pt-BR/volumetrics/#rna","title":"<li>RNA</li>","text":"<p>Utilize os mesmos modelos de RNA usados para a fun\u00e7\u00e3o de afilamento.</p>"},{"location":"pt-BR/volumetrics/#notacao_1","title":"Nota\u00e7\u00e3o","text":"<ul> <li>\\( b_n \\): Par\u00e2metros ajustados</li> <li>\\( V \\): Volume estimado (m\u00b3)</li> <li>\\( \\text{dap} \\): Di\u00e2metro \u00e0 altura do peito (cm)</li> <li>\\( H \\): Altura total (m)</li> </ul>"},{"location":"pt-BR/volumetrics/#funcao-de-classificacao","title":"Fun\u00e7\u00e3o de Classifica\u00e7\u00e3o","text":"<p>Para selecionar os modelos com melhor desempenho e classific\u00e1-los adequadamente, s\u00e3o obtidas as seguintes m\u00e9tricas:</p> Nome da m\u00e9trica Estrutura Erro M\u00e9dio Absoluto (MAE) \\( MAE = \\frac{1}{n} \\sum_{i=1}^{n} \\|y_i - \\hat{y}_i\\| \\) Erro M\u00e9dio Percentual Absoluto (MAPE) \\( MAPE = \\frac{100}{n} \\sum_{i=1}^{n} \\left\\|\\frac{y_i - \\hat{y}_i}{y_i}\\right\\| \\) Erro M\u00e9dio Quadr\u00e1tico (MSE) \\( MSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 \\) Raiz do Erro M\u00e9dio Quadr\u00e1tico (RMSE) \\( RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2} \\) R Quadrado (Coeficiente de Determina\u00e7\u00e3o) \\( R^2 = 1 - \\frac{\\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} \\) Vari\u00e2ncia Explicada (EV) \\( EV = 1 - \\frac{Var(y - \\hat{y})}{Var(y)} \\) Erro M\u00e9dio \\( Erro\\ M\u00e9dio = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i) \\)"},{"location":"pt-BR/volumetrics/#notacao_2","title":"Nota\u00e7\u00e3o","text":"<ul> <li>\\( y_i \\): Valor observado para a i-\u00e9sima observa\u00e7\u00e3o  </li> <li>\\( \\hat{y}_i \\): Valor estimado (predito) para a i-\u00e9sima observa\u00e7\u00e3o  </li> <li>\\( n \\): N\u00famero total de observa\u00e7\u00f5es  </li> <li>\\( \\bar{y} \\): M\u00e9dia dos valores observados  </li> </ul> <p>Ap\u00f3s obter as m\u00e9tricas para cada modelo testado, o melhor modelo recebe a pontua\u00e7\u00e3o 10, enquanto os demais recebem pontua\u00e7\u00f5es decrescentes (9, 8 e assim por diante).</p>"},{"location":"pt-BR/volumetrics/#referencias","title":"Refer\u00eancias","text":"<p>BI, H. (2000). Trigonometric variable-form taper equations for Australian eucalypts. Forest Science, 46(3), 397\u2013409.</p> <p>JOHNSON, T. (1911). Taxatariska unders\u00f6kringar om skogstr\u00e4dens form. Skgsvardsf\u00f6reningens tiedskrifle. H\u00e4fte, Berlim, 9(10), 285\u2013329.</p> <p>KOZAK, A. (2004). My last words on taper equations. The Forestry Chronicle, 80(4), 507\u2013515.</p> <p>MATTE, L. (1949). The taper of coniferous species with special reference to Loblolly Pine. Forestry Chronicle, Mattawa, 25(1), 21\u201331.</p> <p>MEYER, H. A. (1940). A mathematical expression for height curves. Journal of Forestry, 38, 415\u2013420.      https://doi.org/10.1093/jof/38.5.415</p> <p>N\u00c4SLUND, M. (1936). Skogsf\u00f6rs\u00f6ksanstaltens gallringsf\u00f6rs\u00f6k i tallskog. Meddelanden fr\u00e5n Statens Skogsf\u00f6rs\u00f6ksanstalt, Swedish Institute of Experimental Forestry, 29: 169.</p> <p>SCH\u00d6EPFER, W. (1966). Automatisierung des Massen-, Sorten- und Wertberechnung stehender Waldbest\u00e4nde. Schriftenreihe Bad. Wurtt-Forstl.</p> <p>SCHUMACHER, F. X.; HALL, F. S. (1933). Logarithmic expression of timber tree volume. Journal of Agricultural Research, Washington, 47(9), 719\u2013734.</p> <p>SCOLFORO, J. R. S. (2005). Biometria Florestal: Parte I: Modelos de regress\u00e3o linear e n\u00e3o-linear; Parte II: Modelos para rela\u00e7\u00e3o hipsom\u00e9trica, volume, afilamento e preso de mat\u00e9ria seca. Lavras: UFLA/FAEPE, pp. 224\u2013226.</p> <p>SPURR, S. R. (1952). Forest inventory. New York: Ronald Press, 476 p.</p> <p>STOATE, I. N. (1945). The use of a volume equation in pine stands. Australian Forestry, Canberra, 9, 48\u201352.</p>"}]}